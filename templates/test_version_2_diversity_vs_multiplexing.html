<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diversity vs Multiplexing Wireless Experiment</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f5f5;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            display: grid;
            grid-template-columns: 300px 1fr 320px;
            gap: 20px;
            max-width: 1800px;
            margin: 0 auto;
            height: calc(100vh - 40px);
        }

        .panel {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            overflow-y: auto;
            border: 1px solid #e0e0e0;
        }

        .panel h2 {
            color: #333;
            margin-bottom: 20px;
            font-size: 20px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }

        .input-group {
            margin-bottom: 20px;
        }

        .input-group label {
            display: block;
            margin-bottom: 5px;
            color: #333;
            font-weight: 600;
            font-size: 14px;
        }

        .input-group input {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        .input-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .input-group small {
            display: block;
            margin-top: 5px;
            color: #666;
            font-size: 12px;
        }

        .btn {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s;
            margin-top: 10px;
        }

        .btn:hover {
            transform: translateY(-2px);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .btn.secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        #simulationCanvas {
            width: 100%;
            height: 100%;
            border-radius: 8px;
        }

        .output-item {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border-left: 4px solid #667eea;
        }

        .output-item h3 {
            color: #667eea;
            font-size: 14px;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .output-item p {
            color: #333;
            font-size: 16px;
            font-weight: 600;
        }

        .output-item small {
            display: block;
            color: #666;
            font-size: 12px;
            margin-top: 5px;
        }

        .error {
            background: #fee;
            border-left-color: #f44;
            color: #c33;
        }

        .success {
            background: #efe;
            border-left-color: #4a4;
            color: #383;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }

        .antenna-info {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 10px;
        }

        .info-card {
            background: white;
            padding: 10px;
            border-radius: 6px;
            text-align: center;
        }

        .info-card .value {
            font-size: 24px;
            font-weight: bold;
            color: #667eea;
        }

        .info-card .label {
            font-size: 11px;
            color: #666;
            margin-top: 5px;
        }

        .snr-list {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .snr-item {
            padding: 8px;
            margin-bottom: 5px;
            background: white;
            border-radius: 4px;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
        }

        .snr-item.multiplexing {
            border-left: 3px solid #4CAF50;
        }

        .snr-item.diversity {
            border-left: 3px solid #FF9800;
        }

        .matrix-display {
            max-height: 300px;
            overflow: auto;
            background: white;
            padding: 10px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            line-height: 1.6;
        }

        .matrix-row {
            white-space: nowrap;
        }

        .matrix-value {
            display: inline-block;
            min-width: 100px;
            text-align: center;
            color: #333;
        }

        .step-indicator {
            background: #e3f2fd;
            padding: 10px 15px;
            border-radius: 6px;
            margin-bottom: 15px;
            border-left: 4px solid #2196F3;
            font-size: 14px;
            color: #1976D2;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Left Panel: Inputs -->
        <div class="panel">
            <h2>Experiment Parameters</h2>
            
            <div class="input-group">
                <label for="txPower">Transmit Power (P)</label>
                <input type="number" id="txPower" value="10" step="0.1" min="0.1">
                <small>Power in Watts</small>
            </div>

            <div class="input-group">
                <label for="numTx">Transmit Antennas (N<sub>t</sub>)</label>
                <input type="number" id="numTx" value="4" step="1" min="1" max="8">
                <small>Number of TX antennas</small>
            </div>

            <div class="input-group">
                <label for="numRx">Receive Antennas (N<sub>r</sub>)</label>
                <input type="number" id="numRx" value="4" step="1" min="1" max="8">
            </div>

            <div class="input-group">
                <label for="numStreams">Multiplexing Streams (r)</label>
                <input type="number" id="numStreams" value="2" step="1" min="1" max="4">
                <small>Must be ≤ min(Nt, Nr)</small>
            </div>

            <div class="input-group">
                <label for="noiseVar">Noise Variance (σ²)</label>
                <input type="number" id="noiseVar" value="0.1" step="0.01" min="0.01">
                <small>Noise power</small>
            </div>

            <div class="input-group">
                <label for="snrThreshold">SNR Threshold (dB)</label>
                <input type="number" id="snrThreshold" value="15" step="0.5" min="0">
                <small>Target SNR for diversity</small>
            </div>

            <button class="btn" id="mainBtn" onclick="handleMainAction()">Generate System</button>
            <button class="btn secondary" onclick="resetExperiment()">Reset</button>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #4CAF50;"></div>
                    <span>Multiplexing</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #FF9800;"></div>
                    <span>Beamforming (Diversity)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #2196F3;"></div>
                    <span>Channel Link</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #FFD700;"></div>
                    <span>Weakest Stream</span>
                </div>
            </div>
        </div>

        <!-- Middle Panel: Simulation -->
        <div class="panel">
            <h2>Antenna System Visualization</h2>
            <div class="step-indicator" id="stepIndicator">Step 1: Enter parameters and generate system</div>
            <canvas id="simulationCanvas"></canvas>
        </div>

        <!-- Right Panel: Outputs -->
        <div class="panel">
            <h2>Results</h2>
            
            <div class="antenna-info" id="antennaInfo" style="display: none;">
                <div class="info-card">
                    <div class="value" id="multiplexCount">0</div>
                    <div class="label">Multiplexing (r)</div>
                </div>
                <div class="info-card">
                    <div class="value" id="diversityCount">0</div>
                    <div class="label">Diversity d(r)</div>
                </div>
            </div>

            <div class="output-item">
                <h3>Channel Matrix</h3>
                <p id="channelDim">-</p>
                <small>Rayleigh fading channel</small>
            </div>

            <div class="output-item" id="matrixSection" style="display: none;">
                <h3>Channel Matrix H</h3>
                <div class="matrix-display" id="matrixDisplay"></div>
                <small>Complex values: a + bi</small>
            </div>

            <div class="output-item" id="selectedMsgSection" style="display: none;">
                <h3>Weakest Stream</h3>
                <p id="selectedMsg">-</p>
                <small>Stream with lowest SNR</small>
            </div>

            <div class="output-item" id="minSNRSection" style="display: none;">
                <h3>Minimum SNR</h3>
                <p id="minSNR">-</p>
                <small>Before diversity allocation</small>
            </div>

            <div class="output-item" id="tradeoffSection" style="display: none;">
                <h3>Tradeoff Plot</h3>
                <canvas id="tradeoffCanvas" style="width: 100%; height: 300px;"></canvas>
                <small>d_opt(r) = (Mt - r)(Mr - r)</small>
            </div>

            <div class="output-item" id="powerAllocSection" style="display: none;">
                <h3>Beamforming Gain</h3>
                <p id="powerAlloc">-</p>
                <small>Effective channel gain |u^H H_sub v|</small>
            </div>

            <div class="output-item" id="snrSection" style="display: none;">
                <h3>SNR Values (dB)</h3>
                <div class="snr-list" id="snrList"></div>
            </div>

            <div class="output-item" id="statusMsg">
                <h3>Status</h3>
                <p>Ready to run experiment</p>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');

        let channelMatrix = [];
        let singularValues = [];
        let beamformingVectors = { v: [], u: [] };
        let antennaConfig = {
            tx: [],
            rx: [],
            multiplexing: [],
            diversity: [],
            selectedMessage: -1
        };
        let systemState = 'initial';

        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            drawAntennaSystem();
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function complexGaussian() {
            const u1 = Math.random();
            const u2 = Math.random();
            const mag = Math.sqrt(-2 * Math.log(u1));
            const phase = 2 * Math.PI * u2;
            return {
                real: mag * Math.cos(phase) / Math.sqrt(2),
                imag: mag * Math.sin(phase) / Math.sqrt(2)
            };
        }

        function generateChannelMatrix(nt, nr) {
            const H = [];
            for (let i = 0; i < nr; i++) {
                H[i] = [];
                for (let j = 0; j < nt; j++) {
                    H[i][j] = complexGaussian();
                }
            }
            return H;
        }

        function computeHHH(H) {
            const nr = H.length;
            const nt = H[0].length;
            const HHH = [];
            
            for (let i = 0; i < nr; i++) {
                HHH[i] = [];
                for (let j = 0; j < nr; j++) {
                    let sumReal = 0, sumImag = 0;
                    for (let k = 0; k < nt; k++) {
                        sumReal += H[i][k].real * H[j][k].real + H[i][k].imag * H[j][k].imag;
                        sumImag += H[i][k].imag * H[j][k].real - H[i][k].real * H[j][k].imag;
                    }
                    HHH[i][j] = { real: sumReal, imag: sumImag };
                }
            }
            return HHH;
        }

        function computeEigenvalues(HHH) {
            const n = HHH.length;
            const eigenvalues = [];
            
            for (let i = 0; i < n; i++) {
                eigenvalues.push(Math.sqrt(Math.abs(HHH[i][i].real)));
            }
            
            eigenvalues.sort((a, b) => b - a);
            return eigenvalues;
        }

        function computeBeamformingVectors(H_sub) {
            const nr = H_sub.length;
            const nt = H_sub[0].length;
            
            if (nt === 0 || nr === 0) {
                return { v: [], u: [], gain: 0 };
            }
            
            const HHH = computeHHH(H_sub);
            
            let u = new Array(nr).fill(0).map(() => ({ real: Math.random(), imag: Math.random() }));
            
            let norm = Math.sqrt(u.reduce((sum, val) => sum + val.real * val.real + val.imag * val.imag, 0));
            u = u.map(val => ({ real: val.real / norm, imag: val.imag / norm }));
            
            for (let iter = 0; iter < 20; iter++) {
                let newU = new Array(nr).fill(0).map(() => ({ real: 0, imag: 0 }));
                for (let i = 0; i < nr; i++) {
                    for (let j = 0; j < nr; j++) {
                        newU[i].real += HHH[i][j].real * u[j].real - HHH[i][j].imag * u[j].imag;
                        newU[i].imag += HHH[i][j].real * u[j].imag + HHH[i][j].imag * u[j].real;
                    }
                }
                norm = Math.sqrt(newU.reduce((sum, val) => sum + val.real * val.real + val.imag * val.imag, 0));
                u = newU.map(val => ({ real: val.real / norm, imag: val.imag / norm }));
            }
            
            let v = new Array(nt).fill(0).map(() => ({ real: 0, imag: 0 }));
            for (let j = 0; j < nt; j++) {
                for (let i = 0; i < nr; i++) {
                    v[j].real += H_sub[i][j].real * u[i].real + H_sub[i][j].imag * u[i].imag;
                    v[j].imag += H_sub[i][j].real * u[i].imag - H_sub[i][j].imag * u[i].real;
                }
            }
            
            norm = Math.sqrt(v.reduce((sum, val) => sum + val.real * val.real + val.imag * val.imag, 0));
            v = v.map(val => ({ real: val.real / norm, imag: val.imag / norm }));
            
            let gain = { real: 0, imag: 0 };
            for (let i = 0; i < nr; i++) {
                for (let j = 0; j < nt; j++) {
                    const hv_real = H_sub[i][j].real * v[j].real - H_sub[i][j].imag * v[j].imag;
                    const hv_imag = H_sub[i][j].real * v[j].imag + H_sub[i][j].imag * v[j].real;
                    gain.real += u[i].real * hv_real + u[i].imag * hv_imag;
                    gain.imag += u[i].real * hv_imag - u[i].imag * hv_real;
                }
            }
            
            const gainMagnitude = Math.sqrt(gain.real * gain.real + gain.imag * gain.imag);
            
            return { v, u, gain: gainMagnitude };
        }

        function generateTradeoffCurve(numTx, numRx, txPower, noiseVar, H) {
            const maxRank = Math.min(numTx, numRx);
            const tradeoffData = [];
            
            const HHH = computeHHH(H);
            const eigenvalues = computeEigenvalues(HHH);
            
            for (let r = 0; r <= maxRank; r++) {
                const multiplexingGain = r;
                const diversityGain = (numTx - r) * (numRx - r);
                
                let totalRate = 0;
                for (let i = 0; i < r; i++) {
                    const eigenvalueSquared = eigenvalues[i] * eigenvalues[i] * eigenvalues[i] * eigenvalues[i];
                    const snr = (eigenvalueSquared * txPower) / noiseVar;
                    totalRate += Math.log2(1 + snr);
                }
                
                let avgDiversitySNR = 0;
                if (r < maxRank) {
                    const H_sub = [];
                    for (let i = r; i < numRx; i++) {
                        H_sub[i - r] = [];
                        for (let j = r; j < numTx; j++) {
                            H_sub[i - r][j - r] = H[i][j];
                        }
                    }
                    
                    const beamforming = computeBeamformingVectors(H_sub);
                    const beamformingGainSquared = beamforming.gain * beamforming.gain;
                    const snr = (beamformingGainSquared * txPower) / noiseVar;
                    avgDiversitySNR = 10 * Math.log10(snr);
                }
                
                tradeoffData.push({
                    multiplexing: multiplexingGain,
                    diversity: diversityGain,
                    rate: totalRate,
                    avgSNR: avgDiversitySNR
                });
            }
            
            return tradeoffData;
        }

        function drawTradeoffPlot(canvasId, tradeoffData, currentMux) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            const padding = 60;
            const plotWidth = canvas.width - 2 * padding;
            const plotHeight = canvas.height - 2 * padding;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, canvas.height - padding);
            ctx.lineTo(canvas.width - padding, canvas.height - padding);
            ctx.stroke();
            
            const maxMux = Math.max(...tradeoffData.map(d => d.multiplexing));
            const maxDiv = Math.max(...tradeoffData.map(d => d.diversity));
            
            // Draw grid
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
                const y = padding + (plotHeight / 5) * i;
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(canvas.width - padding, y);
                ctx.stroke();
                
                const x = padding + (plotWidth / 5) * i;
                ctx.beginPath();
                ctx.moveTo(x, padding);
                ctx.lineTo(x, canvas.height - padding);
                ctx.stroke();
            }
            
            // Draw tradeoff curve (Diversity vs Multiplexing)
            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 3;
            ctx.beginPath();
            tradeoffData.forEach((d, i) => {
                const x = padding + (d.multiplexing / maxMux) * plotWidth;
                const y = canvas.height - padding - (d.diversity / maxDiv) * plotHeight;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            ctx.stroke();
            
            // Draw points
            tradeoffData.forEach((d, i) => {
                const x = padding + (d.multiplexing / maxMux) * plotWidth;
                const y = canvas.height - padding - (d.diversity / maxDiv) * plotHeight;
                
                ctx.fillStyle = d.multiplexing === currentMux ? '#FFD700' : '#667eea';
                ctx.beginPath();
                ctx.arc(x, y, d.multiplexing === currentMux ? 8 : 5, 0, 2 * Math.PI);
                ctx.fill();
                
                if (d.multiplexing === currentMux) {
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(x, y, 12, 0, 2 * Math.PI);
                    ctx.stroke();
                }
            });
            
            // Draw labels
            ctx.fillStyle = '#333';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            
            // X-axis label
            ctx.fillText('Multiplexing Gain (r)', canvas.width / 2, canvas.height - 20);
            
            // Y-axis label
            ctx.save();
            ctx.translate(20, canvas.height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Diversity Gain d(r)', 0, 0);
            ctx.restore();
            
            // Title
            ctx.font = 'bold 16px Arial';
            ctx.fillText('Diversity-Multiplexing Tradeoff', canvas.width / 2, 30);
            
            // Draw axis values
            ctx.font = '11px Arial';
            ctx.fillStyle = '#666';
            
            // X-axis values
            for (let i = 0; i <= maxMux; i++) {
                const x = padding + (i / maxMux) * plotWidth;
                ctx.textAlign = 'center';
                ctx.fillText(i.toString(), x, canvas.height - padding + 20);
            }
            
            // Y-axis values
            ctx.textAlign = 'right';
            for (let i = 0; i <= 5; i++) {
                const y = canvas.height - padding - (plotHeight / 5) * i;
                const value = (maxDiv / 5) * i;
                ctx.fillText(Math.round(value).toString(), padding - 10, y + 5);
            }
            
            // Draw current point info
            const legendY = padding + 20;
            ctx.font = '12px Arial';
            ctx.textAlign = 'left';
            ctx.fillStyle = '#666';
            ctx.fillText(`Current: r = ${tradeoffData[currentMux].multiplexing}, d(r) = ${tradeoffData[currentMux].diversity}`, canvas.width - padding - 180, legendY);
        }

        function handleMainAction() {
            if (systemState === 'initial') {
                generateSystem();
            } else if (systemState === 'generated') {
                optimizeSystem();
            }
        }

        // ----------------------
        // Helper: partition n indices into r groups (round-robin after giving 1 each)
        // ----------------------
        function partitionIndices(n, r) {
            const groups = Array.from({length: r}, ()=>[]);
            // first give 1 to each stream (ensure r <= n always validated earlier)
            for (let i = 0; i < r; i++) groups[i].push(i);
            // distribute remaining indices
            let idx = r;
            let g = 0;
            while (idx < n) {
                groups[g % r].push(idx);
                idx++; g++;
            }
            return groups;
        }

        function generateSystem() {
            const txPower = parseFloat(document.getElementById('txPower').value);
            const numTx = parseInt(document.getElementById('numTx').value);
            const numRx = parseInt(document.getElementById('numRx').value);
            const numStreams = parseInt(document.getElementById('numStreams').value);

            if (numStreams > Math.min(numTx, numRx)) {
                alert('Number of streams must be ≤ min(Nt, Nr)');
                return;
            }

            channelMatrix = generateChannelMatrix(numTx, numRx);
            
            const HHH = computeHHH(channelMatrix);
            singularValues = computeEigenvalues(HHH);

            antennaConfig.tx = Array(numTx).fill(0).map((_, i) => ({x: 0, y: 0, id: i}));
            antennaConfig.rx = Array(numRx).fill(0).map((_, i) => ({x: 0, y: 0, id: i}));
            antennaConfig.multiplexing = [];
            antennaConfig.diversity = [];
            antennaConfig.selectedMessage = -1;

            document.getElementById('channelDim').textContent = `${numRx} × ${numTx}`;
            
            const matrixDisplay = document.getElementById('matrixDisplay');
            matrixDisplay.innerHTML = '';
            for (let i = 0; i < numRx; i++) {
                const row = document.createElement('div');
                row.className = 'matrix-row';
                for (let j = 0; j < numTx; j++) {
                    const val = channelMatrix[i][j];
                    const span = document.createElement('span');
                    span.className = 'matrix-value';
                    span.textContent = `${val.real.toFixed(2)}${val.imag >= 0 ? '+' : ''}${val.imag.toFixed(2)}i`;
                    row.appendChild(span);
                }
                matrixDisplay.appendChild(row);
            }
            document.getElementById('matrixSection').style.display = 'block';

            const statusDiv = document.getElementById('statusMsg');
            statusDiv.className = 'output-item success';
            statusDiv.querySelector('p').textContent = 'System generated. Ready to optimize.';

            document.getElementById('stepIndicator').textContent = 'Step 2: System generated. Click "Optimize System" to allocate antennas';
            document.getElementById('mainBtn').textContent = 'Optimize System';
            
            document.getElementById('antennaInfo').style.display = 'none';
            document.getElementById('selectedMsgSection').style.display = 'none';
            document.getElementById('minSNRSection').style.display = 'none';
            document.getElementById('powerAllocSection').style.display = 'none';
            document.getElementById('snrSection').style.display = 'none';
            document.getElementById('tradeoffSection').style.display = 'none';

            systemState = 'generated';
            drawAntennaSystem();
        }

        function optimizeSystem() {
            const txPower = parseFloat(document.getElementById('txPower').value) || 1e-12;
            const numTx = parseInt(document.getElementById('numTx').value);
            const numRx = parseInt(document.getElementById('numRx').value);
            const r = parseInt(document.getElementById('numStreams').value);
            const noiseVar = parseFloat(document.getElementById('noiseVar').value) || 1e-12;

            if (!channelMatrix || channelMatrix.length === 0) { alert('Generate system first'); return; }
            if (r < 1 || r > Math.min(numTx, numRx)) { alert('r must be between 1 and min(Nt,Nr)'); return; }

            // Partition TX and RX into r groups
            const txGroups = partitionIndices(numTx, r); // arrays of tx indices
            const rxGroups = partitionIndices(numRx, r); // arrays of rx indices

            // Equal power per stream
            const P_per_stream = txPower / r;

            const groups = []; // store group metadata
            for (let s = 0; s < r; s++) {
                const txSet = txGroups[s];
                const rxSet = rxGroups[s];

                // compute effective energy gain = sum |H[rx][tx]|^2 over submatrix
                let totalGain = 0;
                for (const txIdx of txSet) {
                    for (const rxIdx of rxSet) {
                        const c = channelMatrix[rxIdx][txIdx];
                        if (!c) continue;
                        totalGain += (c.real*c.real + c.imag*c.imag);
                    }
                }

                const snrLinear = (P_per_stream * totalGain) / Math.max(noiseVar, 1e-18);
                const snrDB = 10 * Math.log10(snrLinear + 1e-12);

                groups.push({
                    index: s,
                    txSet,
                    rxSet,
                    totalGain,
                    snr: snrLinear,
                    snrDB,
                    label: `x${s+1} (${txSet.length}Tx → ${rxSet.length}Rx)`
                });
            }

            // choose weakest stream
            let minIdx = 0;
            for (let i = 1; i < groups.length; i++) {
                if (groups[i].snr < groups[minIdx].snr) minIdx = i;
            }

            // update antennaConfig (used by draw)
            antennaConfig.groups = groups;
            antennaConfig.selectedMessage = minIdx;
            antennaConfig.multiplexing = groups.slice(0, r).map(g => ({ index: g.index, snr: g.snr, snrDB: g.snrDB }));
            // diversityCount: show d(r) textbook or total extra branches — here show product as in textbook:
            const diversityGain = (numTx - r) * (numRx - r);
            
            // Update UI
            document.getElementById('selectedMsg').textContent = `x${minIdx + 1}`;
            document.getElementById('minSNR').textContent = `${groups[minIdx].snrDB.toFixed(2)} dB`;
            document.getElementById('multiplexCount').textContent = r;
            document.getElementById('diversityCount').textContent = diversityGain;
            document.getElementById('powerAlloc').textContent = `${P_per_stream.toFixed(3)} W / stream (equal split)`;

            // update SNR list UI
            const snrListDiv = document.getElementById('snrList');
            snrListDiv.innerHTML = '';
            groups.forEach(g => {
                const div = document.createElement('div');
                div.className = `snr-item ${g.txSet.length>1 || g.rxSet.length>1 ? 'diversity' : 'multiplexing'}`;
                div.innerHTML = `<span>${g.label}</span><strong>${g.snrDB.toFixed(2)} dB</strong>`;
                snrListDiv.appendChild(div);
            });

            // Tradeoff plot (theoretical D(r))
            document.getElementById('tradeoffSection').style.display = 'block';
            const tradeoffData = generateTradeoffCurve(numTx, numRx, txPower, noiseVar, channelMatrix);
            drawTradeoffPlot('tradeoffCanvas', tradeoffData, r);

            // Show sections and lock button
            document.getElementById('antennaInfo').style.display = 'grid';
            document.getElementById('selectedMsgSection').style.display = 'block';
            document.getElementById('minSNRSection').style.display = 'block';
            document.getElementById('powerAllocSection').style.display = 'block';
            document.getElementById('snrSection').style.display = 'block';
            document.getElementById('statusMsg').className = 'output-item success';
            document.getElementById('statusMsg').querySelector('p').textContent = 'System optimized with grouped parallel streams.';
            document.getElementById('stepIndicator').textContent = 'Step 3: System optimized with grouped parallel streams';
            document.getElementById('mainBtn').textContent = 'Optimized';
            document.getElementById('mainBtn').disabled = true;

            systemState = 'optimized';
            drawAntennaSystem();
        }

        function drawAntennaSystem() {
            if (!antennaConfig.tx || antennaConfig.tx.length === 0) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const numTx = antennaConfig.tx.length;
            const numRx = antennaConfig.rx.length;
            const groups = antennaConfig.groups || [];
            const r = groups.length || 0;

            // Dynamic layout
            const marginX = Math.min(canvas.width * 0.08, 140);
            const marginY = Math.min(canvas.height * 0.08, 80);

            // spacing uses available height but ensures antennas fit
            const spacing = Math.min(50, (canvas.height - 2 * marginY) / Math.max(numTx, numRx));
            const txX = marginX;
            const rxX = canvas.width - marginX;

            // center antennas
            const totalTxHeight = (numTx - 1) * spacing;
            const totalRxHeight = (numRx - 1) * spacing;
            const txStartY = (canvas.height - totalTxHeight) / 2;
            const rxStartY = (canvas.height - totalRxHeight) / 2;

            for (let i = 0; i < numTx; i++) antennaConfig.tx[i].x = txX, antennaConfig.tx[i].y = txStartY + i*spacing;
            for (let i = 0; i < numRx; i++) antennaConfig.rx[i].x = rxX, antennaConfig.rx[i].y = rxStartY + i*spacing;

            // faint full-links
            ctx.strokeStyle = 'rgba(33,150,243,0.06)'; ctx.lineWidth = 1;
            for (let t=0;t<numTx;t++) for (let rcv=0; rcv<numRx; rcv++) {
                ctx.beginPath(); ctx.moveTo(antennaConfig.tx[t].x, antennaConfig.tx[t].y); ctx.lineTo(antennaConfig.rx[rcv].x, antennaConfig.rx[rcv].y); ctx.stroke();
            }

            // Draw group boxes: compute vertical extents for each group's tx set and rx set, place boxes inside margin region
            const boxInset = 28; // how far from antenna column the boxes sit
            const boxWidth = Math.min(90, (canvas.width*0.18));
            const gapBetweenBoxes = Math.min(24, canvas.width * 0.02);

            // For nicer layout, stack group boxes vertically centered around canvas center
            const totalBoxStackHeight = groups.reduce((acc,g)=>{
                const txYs = g.txSet.map(i=>antennaConfig.tx[i].y);
                const rxYs = g.rxSet.map(i=>antennaConfig.rx[i].y);
                const minY = Math.min(...txYs, ...rxYs);
                const maxY = Math.max(...txYs, ...rxYs);
                return acc + (maxY - minY + 40); // approximate needed height
            }, 0);
            // we won't strictly use totalBoxStackHeight but it helps keep center alignment

            // Draw each group's boxes and internal connections
            const centerY = canvas.height / 2;
            let yCursor = centerY - totalBoxStackHeight/2;

            groups.forEach((g, idx) => {
                // compute extents for this group's TX and RX antennas
                const txYs = g.txSet.map(i => antennaConfig.tx[i].y).sort((a,b)=>a-b);
                const rxYs = g.rxSet.map(i => antennaConfig.rx[i].y).sort((a,b)=>a-b);

                const txTop = txYs[0] - 18;
                const txBottom = txYs[txYs.length-1] + 18;
                const rxTop = rxYs[0] - 18;
                const rxBottom = rxYs[rxYs.length-1] + 18;

                // box coordinates
                const txBoxLeft = antennaConfig.tx[g.txSet[0]].x + boxInset;
                const txBoxRight = txBoxLeft + boxWidth;
                const rxBoxRight = antennaConfig.rx[g.rxSet[0]].x - boxInset;
                const rxBoxLeft = rxBoxRight - boxWidth;

                // Draw TX box
                ctx.setLineDash([5,5]); ctx.strokeStyle = '#FFA726'; ctx.lineWidth = 2;
                ctx.strokeRect(txBoxLeft, txTop, txBoxRight - txBoxLeft, txBottom - txTop);
                // Draw RX box
                ctx.strokeRect(rxBoxLeft, rxTop, rxBoxRight - rxBoxLeft, rxBottom - rxTop);
                ctx.setLineDash([]);

                // Label boxes
                ctx.fillStyle = '#FF9800'; ctx.font = 'bold 13px Arial'; ctx.textAlign = 'center';
                ctx.fillText(g.label, (txBoxLeft + txBoxRight)/2, txTop - 8);
                ctx.fillText('', (rxBoxLeft + rxBoxRight)/2, rxTop - 8);

                // Draw internal connections between tx box and rx box (submatrix)
                ctx.strokeStyle = 'rgba(255,152,0,0.45)'; ctx.lineWidth = 2;
                for (const txIdx of g.txSet) {
                    for (const rxIdx of g.rxSet) {
                        ctx.beginPath();
                        ctx.moveTo(txBoxRight, antennaConfig.tx[txIdx].y);
                        ctx.lineTo(rxBoxLeft, antennaConfig.rx[rxIdx].y);
                        ctx.stroke();
                    }
                }

                // Draw fan-in/out wires (visualizing parallel stream)
                const txCenterY = (txTop + txBottom)/2;
                const rxCenterY = (rxTop + rxBottom)/2;
                ctx.strokeStyle = '#FF9800'; ctx.lineWidth = 3;
                ctx.beginPath(); ctx.moveTo(txBoxLeft - 40, txCenterY); ctx.lineTo(txBoxLeft, txCenterY); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(rxBoxRight, rxCenterY); ctx.lineTo(rxBoxRight + 40, rxCenterY); ctx.stroke();

                // Mark the group's antennas with small circles of the group's color
                g.txSet.forEach(ti => {
                    ctx.fillStyle = '#FFB74D'; ctx.beginPath(); ctx.arc(antennaConfig.tx[ti].x, antennaConfig.tx[ti].y, 11, 0, 2*Math.PI); ctx.fill();
                    ctx.strokeStyle='white'; ctx.lineWidth=2; ctx.stroke();
                    ctx.fillStyle='white'; ctx.font='11px Arial'; ctx.textAlign='center'; ctx.fillText(`T${ti+1}`, antennaConfig.tx[ti].x, antennaConfig.tx[ti].y);
                });
                g.rxSet.forEach(ri => {
                    ctx.fillStyle = '#FFB74D'; ctx.beginPath(); ctx.arc(antennaConfig.rx[ri].x, antennaConfig.rx[ri].y, 11, 0, 2*Math.PI); ctx.fill();
                    ctx.strokeStyle='white'; ctx.lineWidth=2; ctx.stroke();
                    ctx.fillStyle='white'; ctx.font='11px Arial'; ctx.textAlign='center'; ctx.fillText(`R${ri+1}`, antennaConfig.rx[ri].x, antennaConfig.rx[ri].y);
                });

                // highlight weakest group
                if (antennaConfig.selectedMessage === g.index) {
                    ctx.strokeStyle = '#FFD700'; ctx.lineWidth = 3;
                    ctx.strokeRect(txBoxLeft-4, txTop-4, (txBoxRight - txBoxLeft)+8, (txBottom - txTop)+8);
                    ctx.strokeRect(rxBoxLeft-4, rxTop-4, (rxBoxRight - rxBoxLeft)+8, (rxBottom - rxTop)+8);
                }
            });

            // Finally draw any leftover single-antenna streams not in groups as plain nodes (already handled inside groups)
            // Draw labels for columns
            ctx.fillStyle = '#333'; ctx.font = 'bold 16px Arial'; ctx.textAlign = 'center';
            ctx.fillText('Transmitters', antennaConfig.tx[0].x, 28);
            ctx.fillText('Receivers', antennaConfig.rx[0].x, 28);
        }

        function resetExperiment() {
            channelMatrix = [];
            singularValues = [];
            beamformingVectors = { v: [], u: [] };
            antennaConfig = {
                tx: [],
                rx: [],
                multiplexing: [],
                diversity: [],
                selectedMessage: -1
            };
            systemState = 'initial';

            document.getElementById('multiplexCount').textContent = '0';
            document.getElementById('diversityCount').textContent = '0';
            document.getElementById('channelDim').textContent = '-';
            document.getElementById('selectedMsg').textContent = '-';
            document.getElementById('minSNR').textContent = '-';
            document.getElementById('powerAlloc').textContent = '-';
            document.getElementById('snrList').innerHTML = '';
            
            const statusDiv = document.getElementById('statusMsg');
            statusDiv.className = 'output-item';
            statusDiv.querySelector('p').textContent = 'Ready to run experiment';

            document.getElementById('stepIndicator').textContent = 'Step 1: Enter parameters and generate system';
            document.getElementById('mainBtn').textContent = 'Generate System';
            document.getElementById('mainBtn').disabled = false;

            document.getElementById('antennaInfo').style.display = 'none';
            document.getElementById('matrixSection').style.display = 'none';
            document.getElementById('selectedMsgSection').style.display = 'none';
            document.getElementById('minSNRSection').style.display = 'none';
            document.getElementById('powerAllocSection').style.display = 'none';
            document.getElementById('snrSection').style.display = 'none';
            document.getElementById('tradeoffSection').style.display = 'none';

            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        setTimeout(resizeCanvas, 100);
    </script>
</body>
</html>