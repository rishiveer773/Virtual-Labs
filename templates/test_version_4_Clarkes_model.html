<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clarke's Model Virtual Lab</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fft.js/4.0.3/fft.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f0f2f5;
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: #333;
        }

        .header h1 {
            font-size: 3rem;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .tabs {
            display: flex;
            justify-content: center;
            margin-bottom: 30px;
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
        }

        .tab-button {
            padding: 15px 40px;
            background: #f8f9fa;
            border: none;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            color: #6c757d;
        }

        .tab-button.active {
            background: #667eea;
            color: white;
        }

        .tab-button:hover:not(.active) {
            background: #e9ecef;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .lab-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .controls-panel, .environment-panel, .chart-panel {
            background: #fff;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            height: fit-content;
        }

        .input-group-container {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .input-group-container .control-group {
            flex: 1;
            min-width: 200px;
            margin-bottom: 0;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            color: #4a5568;
        }

        .control-group input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 16px;
            transition: all 0.3s ease;
        }
        
        .control-group input::-webkit-outer-spin-button,
        .control-group input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        
        .control-group input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .help-text {
            font-size: 12px;
            color: #718096;
            margin-top: 5px;
        }

        .environment-canvas {
            width: 100%;
            height: 400px;
            border-radius: 10px;
            background: #f8fafc;
        }

        .chart-container {
            position: relative;
            height: 300px;
            width: 100%;
        }
        
        .signal-chart-container {
            position: relative;
            height: 400px;
            width: 100%;
        }

        h2 {
            font-size: 1.5rem;
            margin-bottom: 20px;
            color: #2d3748;
        }

        h3 {
            font-size: 1.2rem;
            margin-bottom: 15px;
            color: #4a5568;
        }

        .charts-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        .chart-panel-wrapper {
            display: none;
        }
        
        .info-box {
            background: #f0f4ff;
            border-left: 4px solid #667eea;
            padding: 15px;
            margin-top: 20px;
            border-radius: 5px;
        }

        .info-box h4 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .simulate-button {
            width: 100%;
            padding: 15px;
            border: none;
            border-radius: 8px;
            background-color: #667eea;
            color: white;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .simulate-button:hover {
            background-color: #5a6ac2;
        }

        .checkbox-group {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .checkbox-group label {
            font-weight: 600;
            color: #4a5568;
        }
        .checkbox-group input[type="checkbox"] {
            margin-right: 5px;
        }
        
        .realistic-panels {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        @media (max-width: 1000px) {
            .lab-grid {
                grid-template-columns: 1fr;
            }
            .charts-grid {
                grid-template-columns: 1fr;
            }
            .realistic-panels {
                grid-template-columns: 1fr;
            }
            .input-group-container {
                flex-direction: column;
            }
            .tabs {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Clarke's Model Virtual Lab</h1>
            <p>Interactive simulation of mobile radio channel fading characteristics</p>
        </div>

        <div class="tabs">
            <button class="tab-button active" onclick="switchTab('ideal', event)">Clarke's Model</button>
            <button class="tab-button" onclick="switchTab('realistic', event)">Realistic Model (Sum of Sinusoids)</button>
        </div>

        <div id="ideal" class="tab-content active">
            <div class="lab-grid">
                <div class="controls-panel">
                    <h2>Parameters - Ideal Model</h2>
                    
                    <div class="input-group-container">
                        <div class="control-group">
                            <label for="velocity1">Vehicle 1 Velocity (m/s)</label>
                            <input type="number" id="velocity1" value="30" min="0" max="100" step="1">
                            <div class="help-text">Controls Doppler spread and fading rate.</div>
                        </div>

                        <div class="control-group">
                            <label for="velocity2">Vehicle 2 Velocity (m/s)</label>
                            <input type="number" id="velocity2" value="60" min="0" max="100" step="1">
                            <div class="help-text">Controls Doppler spread and fading rate.</div>
                        </div>
                        
                        <div class="control-group">
                            <label for="velocity3">Vehicle 3 Velocity (m/s)</label>
                            <input type="number" id="velocity3" value="90" min="0" max="100" step="1">
                            <div class="help-text">Controls Doppler spread and fading rate.</div>
                        </div>
                    </div>
                    <div class="input-group-container">
                        <div class="control-group">
                            <label for="frequency">Carrier Frequency (MHz)</label>
                            <input type="number" id="frequency" value="900" min="100" max="6000" step="100">
                            <div class="help-text">Affects wavelength and Doppler frequency.</div>
                        </div>

                        <div class="control-group">
                            <label for="scatterers">Number of Scatterers</label>
                            <input type="number" id="scatterers" value="20" min="6" max="50" step="2">
                            <div class="help-text">More scatterers provide a better approximation of the model.</div>
                        </div>
                    </div>
                    
                    <button class="simulate-button" onclick="simulateIdeal()">Simulate Ideal Model</button>

                    <div class="info-box">
                        <h4>Clarke's Ideal Model</h4>
                        <p>Models multipath fading in mobile communications assuming:</p>
                        <ul style="margin: 10px 0 0 20px; line-height: 1.6;">
                            <li>Scatterers uniformly distributed</li>
                            <li>Equal signal strength from all paths</li>
                            <li>Mobile receiver in motion</li>
                            <li>Theoretical Bessel function autocorrelation</li>
                        </ul>
                    </div>
                </div>

                <div class="environment-panel">
                    <h2>Scattering Environment</h2>
                    <canvas id="environmentCanvas" class="environment-canvas"></canvas>
                </div>
            </div>

            <div class="charts-grid">
                <div class="chart-panel-wrapper" id="autocorrelationPanel">
                    <div class="chart-panel">
                        <h3>Autocorrelation Function R(τ)</h3>
                        <div class="checkbox-group">
                            <label><input type="checkbox" id="v1-autocorr-check" checked> Vehicle 1</label>
                            <label><input type="checkbox" id="v2-autocorr-check" checked> Vehicle 2</label>
                            <label><input type="checkbox" id="v3-autocorr-check" checked> Vehicle 3</label>
                        </div>
                        <div class="chart-container">
                            <canvas id="autocorrelationChart"></canvas>
                        </div>
                    </div>
                </div>

                <div class="chart-panel-wrapper" id="psdPanel">
                    <div class="chart-panel">
                        <h3>Power Spectral Density S(f)</h3>
                        <div class="checkbox-group">
                            <label><input type="checkbox" id="v1-psd-check" checked> Vehicle 1</label>
                            <label><input type="checkbox" id="v2-psd-check" checked> Vehicle 2</label>
                            <label><input type="checkbox" id="v3-psd-check" checked> Vehicle 3</label>
                        </div>
                        <div class="chart-container">
                            <canvas id="psdChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="realistic" class="tab-content">
            <div class="lab-grid">
                <div class="controls-panel">
                    <h2>Parameters - Realistic Model</h2>
                    
                    <div class="input-group-container">
                        <div class="control-group">
                            <label for="velocity-realistic">Vehicle Velocity (m/s)</label>
                            <input type="number" id="velocity-realistic" value="30" min="0" max="100" step="1">
                            <div class="help-text">Controls Doppler spread and fading rate.</div>
                        </div>

                        <div class="control-group">
                            <label for="frequency-realistic">Carrier Frequency (MHz)</label>
                            <input type="number" id="frequency-realistic" value="900" min="100" max="6000" step="100">
                            <div class="help-text">Affects wavelength and Doppler frequency.</div>
                        </div>
                    </div>
                    
                    <div class="input-group-container">
                        <div class="control-group">
                            <label for="multipaths">Number of Multipaths (M)</label>
                            <input type="number" id="multipaths" value="20" min="6" max="50" step="2">
                            <div class="help-text">Number of multipath components in sum of sinusoids.</div>
                        </div>

                        <div class="control-group">
                            <label for="samples">Number of Samples (N)</label>
                            <input type="number" id="samples" value="1024" min="128" max="4096" step="128">
                            <div class="help-text">Number of time samples for simulation (ideally a power of 2 for FFT).</div>
                        </div>
                    </div>
                    
                    <button class="simulate-button" onclick="startRealisticSimulation()">Simulate Realistic Model</button>

                    <div class="info-box">
                        <h4>Clarke's Realistic Model (Sum of Sinusoids)</h4>
                        <p>Implements the practical sum of sinusoids method:</p>
                        <ul style="margin: 10px 0 0 20px; line-height: 1.6;">
                            <li>Finite number of multipath components</li>
                            <li>Discrete angle of arrival simulation</li>
                            <li>Statistical properties approximating ideal model</li>
                            <li>Computational efficient implementation</li>
                        </ul>
                    </div>
                </div>
                
                <div class="realistic-panels">
                    <div class="environment-panel">
                        <h2>System Diagram</h2>
                        <canvas id="realisticEnvironmentCanvas" class="environment-canvas"></canvas>
                    </div>
                    
                    <div class="environment-panel">
                        <h2>Received Signal Plot</h2>
                        <div class="signal-chart-container">
                            <canvas id="realisticSignalChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>

            <div class="charts-grid">
                <div class="chart-panel-wrapper" id="realisticAutocorrelationPanel">
                    <div class="chart-panel">
                        <h3>Autocorrelation Function R(τ) - Realistic vs Ideal</h3>
                        <div class="chart-container">
                            <canvas id="realisticAutocorrelationChart"></canvas>
                        </div>
                    </div>
                </div>

                <div class="chart-panel-wrapper" id="realisticPsdPanel">
                    <div class="chart-panel">
                        <h3>Power Spectral Density S(f) - Realistic vs Ideal</h3>
                        <div class="chart-container">
                            <canvas id="realisticPsdChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Physical constants
        const SPEED_OF_LIGHT = 3e8;

        // Current active tab
        let currentTab = 'ideal';
        let realisticSimulationInterval = null;
        let currentSampleIndex = 0;
        let hI_realtime = [];
        let hQ_realtime = [];
        let envelope_realtime = [];
        let Ts_realtime = 0;
        let M_realtime = 0;
        let N_realtime = 0;
        let fD_realtime = 0;
        let angles_realtime = [];
        let alpha_realtime = [];
        let beta_realtime = [];
        
        // DOM elements - Ideal
        const velocity1Input = document.getElementById('velocity1');
        const velocity2Input = document.getElementById('velocity2');
        const velocity3Input = document.getElementById('velocity3');
        const frequencyInput = document.getElementById('frequency');
        const scatterersInput = document.getElementById('scatterers');
        const envCanvas = document.getElementById('environmentCanvas');
        const envCtx = envCanvas.getContext('2d');

        // DOM elements - Realistic
        const velocityRealisticInput = document.getElementById('velocity-realistic');
        const frequencyRealisticInput = document.getElementById('frequency-realistic');
        const multipathsInput = document.getElementById('multipaths');
        const samplesInput = document.getElementById('samples');
        const realisticEnvCanvas = document.getElementById('realisticEnvironmentCanvas');
        const realisticEnvCtx = realisticEnvCanvas.getContext('2d');
        const simulateRealisticButton = document.querySelector('#realistic .simulate-button');

        // Checkboxes for plots
        const v1AutocorrCheck = document.getElementById('v1-autocorr-check');
        const v2AutocorrCheck = document.getElementById('v2-autocorr-check');
        const v3AutocorrCheck = document.getElementById('v3-autocorr-check');
        const v1PsdCheck = document.getElementById('v1-psd-check');
        const v2PsdCheck = document.getElementById('v2-psd-check');
        const v3PsdCheck = document.getElementById('v3-psd-check');

        // Charts
        let autocorrelationChart = null;
        let psdChart = null;
        let realisticAutocorrelationChart = null;
        let realisticPsdChart = null;
        let realisticSignalChart = null; // New chart instance

        // Switch between tabs
        function switchTab(tabName, event) {
            // Stop any ongoing simulations when switching tabs
            if (realisticSimulationInterval) {
                clearInterval(realisticSimulationInterval);
                realisticSimulationInterval = null;
                simulateRealisticButton.textContent = 'Simulate Realistic Model';
            }

            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // Remove active class from all tab buttons
            document.querySelectorAll('.tab-button').forEach(button => {
                button.classList.remove('active');
            });
            
            // Show selected tab content
            document.getElementById(tabName).classList.add('active');
            
            // Add active class to clicked button
            event.target.classList.add('active');
            
            currentTab = tabName;
            
            // Draw environment for current tab
            if (tabName === 'ideal') {
                drawEnvironment();
            } else {
                drawRealisticEnvironment();
            }
        }

        // Bessel function J0 approximation
        function besselJ0(x) {
            if (Math.abs(x) < 8.0) {
                const y = x * x;
                const ans1 = 57568490574.0 + y * (-13362590354.0 + y * (651619640.7 +
                    y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456)))));
                const ans2 = 57568490411.0 + y * (1029532985.0 + y * (9494680.718 +
                    y * (59272.64853 + y * (267.8532712 + y * 1.0))));
                return ans1 / ans2;
            } else {
                const z = 8.0 / x;
                const y = z * z;
                const xx = x - 0.785398164;
                const ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 +
                    y * (-0.2073370639e-5 + y * 0.2093887211e-6)));
                const ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 +
                    y * (-0.6911147651e-5 + y * (0.7621095161e-6 - y * 0.934935152e-7)));
                return Math.sqrt(0.636619772 / x) * (Math.cos(xx) * ans1 - z * Math.sin(xx) * ans2);
            }
        }

        // Generate Rayleigh fading using sum of sinusoids (realistic model)
        function generateRayleighFading(velocity, frequency, M, N, Ts) {
            const wavelength = SPEED_OF_LIGHT / (frequency * 1e6); // Convert MHz to Hz
            const fD = velocity / wavelength; // Maximum Doppler frequency
            
            const hI = new Array(N).fill(0);
            const hQ = new Array(N).fill(0);
            
            // Generate random phases and angles for a more realistic model
            const angles = new Array(M).fill(0).map(() => Math.random() * 2 * Math.PI);
            const alpha = new Array(M).fill(0).map(() => Math.random() * 2 * Math.PI);
            const beta = new Array(M).fill(0).map(() => Math.random() * 2 * Math.PI);

            for (let n = 0; n < N; n++) {
                const t = n * Ts;
                
                for (let m = 0; m < M; m++) {
                    const angle = angles[m]; 
                    const cosArg = 2 * Math.PI * fD * Math.cos(angle) * t + alpha[m];
                    const sinArg = 2 * Math.PI * fD * Math.cos(angle) * t + beta[m];
                    
                    hI[n] += Math.sqrt(2/M) * Math.cos(cosArg);
                    hQ[n] += Math.sqrt(2/M) * Math.sin(sinArg);
                }
            }
            
            // Calculate envelope
            const envelope = new Array(N);
            for (let n = 0; n < N; n++) {
                envelope[n] = Math.sqrt(hI[n] * hI[n] + hQ[n] * hQ[n]);
            }
            
            return { hI, hQ, envelope };
        }

        // NEW: Generate single sample of Rayleigh fading signal
        function generateSingleRayleighFadingSample(t, fD, M, angles, alpha, beta) {
            let hI = 0;
            let hQ = 0;

            for (let m = 0; m < M; m++) {
                const angle = angles[m]; 
                const cosArg = 2 * Math.PI * fD * Math.cos(angle) * t + alpha[m];
                const sinArg = 2 * Math.PI * fD * Math.cos(angle) * t + beta[m];
                
                hI += Math.sqrt(2/M) * Math.cos(cosArg);
                hQ += Math.sqrt(2/M) * Math.sin(sinArg);
            }

            const envelope = Math.sqrt(hI * hI + hQ * hQ);
            return { hI, hQ, envelope };
        }

        // Corrected: Calculate autocorrelation from complex time series
        function calculateAutocorrelationFromComplexSeries(hI, hQ, maxLag) {
            const N = hI.length;
            const autocorr = [];
            
            for (let lag = 0; lag <= maxLag; lag++) {
                let sumReal = 0;
                let count = 0;
                
                for (let i = 0; i < N - lag; i++) {
                    // R(tau) = E[h(t) * h*(t+tau)]
                    sumReal += (hI[i] * hI[i + lag] + hQ[i] * hQ[i + lag]);
                    count++;
                }
                
                autocorr.push(sumReal / count);
            }
            
            // Normalize
            const R0 = autocorr[0];
            return autocorr.map(val => val / R0);
        }

        // Improved PSD calculation function
        function calculatePSDFromComplexSeries(hI, hQ, N, Ts) {
            const fs = 1 / Ts;
            
            // Use a simple DFT instead of FFT library for better compatibility
            const psd = [];
            const freqs = [];
            const halfN = Math.floor(N / 2);
            
            for (let k = 0; k <= halfN; k++) {
                let realSum = 0;
                let imagSum = 0;
                
                for (let n = 0; n < N; n++) {
                    const angle = -2 * Math.PI * k * n / N;
                    const cosAngle = Math.cos(angle);
                    const sinAngle = Math.sin(angle);
                    
                    realSum += (hI[n] * cosAngle - hQ[n] * sinAngle);
                    imagSum += (hI[n] * sinAngle + hQ[n] * cosAngle);
                }
                
                const magnitude = Math.sqrt(realSum * realSum + imagSum * imagSum) / N;
                psd.push(magnitude);
                freqs.push((k * fs) / N);
            }
            
            // Create symmetric spectrum for display
            const shiftedPSD = [];
            const shiftedFreqs = [];
            
            // Negative frequencies
            for (let i = halfN; i > 0; i--) {
                shiftedFreqs.push(-freqs[i]);
                shiftedPSD.push(psd[i]);
            }
            
            // Positive frequencies
            for (let i = 0; i <= halfN; i++) {
                shiftedFreqs.push(freqs[i]);
                shiftedPSD.push(psd[i]);
            }
            
            // Normalize
            const maxPSD = Math.max(...shiftedPSD);
            const normalizedPSD = maxPSD > 0 ? shiftedPSD.map(p => p / maxPSD) : shiftedPSD;
            
            return {
                freqs: shiftedFreqs,
                psd: normalizedPSD
            };
        }

        // Draw ideal environment
        function drawEnvironment() {
            const width = envCanvas.width = envCanvas.offsetWidth;
            const height = envCanvas.height = envCanvas.offsetHeight;
            
            envCtx.clearRect(0, 0, width, height);
            
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) * 0.35;
            const numScatterers = parseInt(scatterersInput.value);

            // Draw circle
            envCtx.strokeStyle = '#667eea';
            envCtx.lineWidth = 3;
            envCtx.beginPath();
            envCtx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            envCtx.stroke();

            // Draw scatterers
            envCtx.fillStyle = '#48bb78';
            for (let i = 0; i < numScatterers; i++) {
                const angle = (2 * Math.PI * i) / numScatterers;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                
                envCtx.beginPath();
                envCtx.arc(x, y, 6, 0, 2 * Math.PI);
                envCtx.fill();
                
                // Draw path lines
                envCtx.strokeStyle = 'rgba(102, 126, 234, 0.3)';
                envCtx.lineWidth = 1;
                envCtx.beginPath();
                envCtx.moveTo(centerX, centerY);
                envCtx.lineTo(x, y);
                envCtx.stroke();
            }

            // Draw mobile receiver
            envCtx.fillStyle = '#e53e3e';
            envCtx.beginPath();
            envCtx.arc(centerX, centerY, 10, 0, 2 * Math.PI);
            envCtx.fill();
            
            // Add label
            envCtx.fillStyle = '#2d3748';
            envCtx.font = 'bold 14px Arial';
            envCtx.textAlign = 'center';
            envCtx.fillText('Rx', centerX, centerY + 5);

            // Add velocity arrow
            const velocity = parseFloat(velocity1Input.value);
            if (velocity > 0) {
                envCtx.strokeStyle = '#e53e3e';
                envCtx.lineWidth = 3;
                envCtx.beginPath();
                envCtx.moveTo(centerX, centerY - 20);
                envCtx.lineTo(centerX + 30, centerY - 20);
                envCtx.stroke();
                
                // Arrow head
                envCtx.beginPath();
                envCtx.moveTo(centerX + 30, centerY - 20);
                envCtx.lineTo(centerX + 25, centerY - 25);
                envCtx.moveTo(centerX + 30, centerY - 20);
                envCtx.lineTo(centerX + 25, centerY - 15);
                envCtx.stroke();
                
                envCtx.fillStyle = '#2d3748';
                envCtx.font = '12px Arial';
                envCtx.fillText(`v = ${velocity} m/s`, centerX + 15, centerY - 30);
            }
        }

        // Draw realistic environment with scatterers between the last two rings
        function drawRealisticEnvironment() {
            const width = realisticEnvCanvas.width = realisticEnvCanvas.offsetWidth;
            const height = realisticEnvCanvas.height = realisticEnvCanvas.offsetHeight;
            
            realisticEnvCtx.clearRect(0, 0, width, height);
            
            const centerX = width / 2;
            const centerY = height / 2;
            const maxRadius = Math.min(width, height) * 0.4;
            const numMultipaths = parseInt(multipathsInput.value);
            
            // Draw three concentric circles
            for (let r = 1; r <= 3; r++) {
                realisticEnvCtx.strokeStyle = `rgba(102, 126, 234, ${0.3 - r * 0.08})`;
                realisticEnvCtx.lineWidth = 2;
                realisticEnvCtx.beginPath();
                realisticEnvCtx.arc(centerX, centerY, maxRadius * r / 3, 0, 2 * Math.PI);
                realisticEnvCtx.stroke();
            }
            
            // Define the radial bounds for the scatterers
            const innerRadius = maxRadius * 2 / 3;
            const outerRadius = maxRadius;

            // Draw multipath components with random angles and radii within the specified bounds
            realisticEnvCtx.fillStyle = '#48bb78';
            for (let i = 0; i < numMultipaths; i++) {
                const angle = Math.random() * 2 * Math.PI; // Random angle [0, 2*pi]
                const r = innerRadius + Math.random() * (outerRadius - innerRadius); // Random radius between the rings
                const x = centerX + r * Math.cos(angle);
                const y = centerY + r * Math.sin(angle);
                
                realisticEnvCtx.beginPath();
                realisticEnvCtx.arc(x, y, 4, 0, 2 * Math.PI);
                realisticEnvCtx.fill();
                
                // Draw path lines
                realisticEnvCtx.strokeStyle = 'rgba(102, 126, 234, 0.4)';
                realisticEnvCtx.lineWidth = 1;
                realisticEnvCtx.beginPath();
                realisticEnvCtx.moveTo(centerX, centerY);
                realisticEnvCtx.lineTo(x, y);
                realisticEnvCtx.stroke();
            }

            // Draw mobile receiver
            realisticEnvCtx.fillStyle = '#e53e3e';
            realisticEnvCtx.beginPath();
            realisticEnvCtx.arc(centerX, centerY, 10, 0, 2 * Math.PI);
            realisticEnvCtx.fill();
            
            // Add label
            realisticEnvCtx.fillStyle = '#2d3748';
            realisticEnvCtx.font = 'bold 14px Arial';
            realisticEnvCtx.textAlign = 'center';
            realisticEnvCtx.fillText('Rx', centerX, centerY + 5);

            // Add velocity arrow
            const velocity = parseFloat(velocityRealisticInput.value);
            if (velocity > 0) {
                realisticEnvCtx.strokeStyle = '#e53e3e';
                realisticEnvCtx.lineWidth = 3;
                realisticEnvCtx.beginPath();
                realisticEnvCtx.moveTo(centerX, centerY - 20);
                realisticEnvCtx.lineTo(centerX + 30, centerY - 20);
                realisticEnvCtx.stroke();
                
                // Arrow head
                realisticEnvCtx.beginPath();
                realisticEnvCtx.moveTo(centerX + 30, centerY - 20);
                realisticEnvCtx.lineTo(centerX + 25, centerY - 25);
                realisticEnvCtx.moveTo(centerX + 30, centerY - 20);
                realisticEnvCtx.lineTo(centerX + 25, centerY - 15);
                realisticEnvCtx.stroke();
                
                realisticEnvCtx.fillStyle = '#2d3748';
                realisticEnvCtx.font = '12px Arial';
                realisticEnvCtx.fillText(`v = ${velocity} m/s`, centerX + 15, centerY - 30);
            }
        }

        // Calculate autocorrelation function for ideal model
        function calculateAutocorrelation(velocity, frequency, maxTau) {
            const wavelength = SPEED_OF_LIGHT / (frequency * 1e6); // Convert MHz to Hz
            const fD = velocity / wavelength;
            const numPoints = 100;
            const tauStep = maxTau / numPoints;
            
            const data = [];
            for (let i = 0; i <= numPoints; i++) {
                const tau = i * tauStep;
                const correlation = besselJ0(2 * Math.PI * fD * tau);
                data.push({ x: tau * 1000, y: correlation });
            }
            
            return data;
        }

        // Calculate power spectral density (Jakes spectrum) for ideal model
        function calculatePSD(velocity, frequency) {
            const wavelength = SPEED_OF_LIGHT / frequency;
            const fD = velocity / wavelength;

            if (fD === 0) {
                return [{ x: 0, y: 1 }];
            }

            const numPoints = 200;
            const data = [];
            
            for (let i = 0; i <= numPoints; i++) {
                const f = (-fD * 1.5) + (i * 3 * fD) / numPoints;
                let psd = 0;
                
                if (Math.abs(f) < fD * 0.999) {
                    psd = 1 / (Math.PI * fD * Math.sqrt(1 - (f / fD) ** 2));
                }
                
                data.push({ x: f, y: psd });
            }
            
            return data;
        }

        // Simulate ideal model
        function simulateIdeal() {
            updateIdealPlots();
            drawEnvironment();
        }

        // NEW: Starts the real-time simulation for the realistic model
        function startRealisticSimulation() {
            if (realisticSimulationInterval) {
                // If a simulation is running, stop it and reset the button
                clearInterval(realisticSimulationInterval);
                realisticSimulationInterval = null;
                simulateRealisticButton.textContent = 'Simulate Realistic Model';
                updateStaticPlots();
            } else {
                // Otherwise, start a new simulation
                simulateRealisticButton.textContent = 'Stop Simulation';
                
                // Get parameters from inputs
                const velocity = parseFloat(velocityRealisticInput.value);
                const frequency = parseFloat(frequencyRealisticInput.value); // Keep in MHz for now
                M_realtime = parseInt(multipathsInput.value);
                N_realtime = parseInt(samplesInput.value);

                // Calculate Doppler frequency and sampling rate
                const wavelength = SPEED_OF_LIGHT / (frequency * 1e6);
                fD_realtime = velocity / wavelength;
                Ts_realtime = 1 / (20 * Math.max(fD_realtime, 1));
                
                // Reset data and index
                hI_realtime = [];
                hQ_realtime = [];
                envelope_realtime = [];
                currentSampleIndex = 0;
                
                // Generate the static random phases and angles once
                angles_realtime = new Array(M_realtime).fill(0).map(() => Math.random() * 2 * Math.PI);
                alpha_realtime = new Array(M_realtime).fill(0).map(() => Math.random() * 2 * Math.PI);
                beta_realtime = new Array(M_realtime).fill(0).map(() => Math.random() * 2 * Math.PI);
                
                // Initialise the chart for real-time plotting
                initRealisticSignalChart();

                // Start the interval
                realisticSimulationInterval = setInterval(() => {
                    if (currentSampleIndex < N_realtime) {
                        const t = currentSampleIndex * Ts_realtime;
                        const sample = generateSingleRayleighFadingSample(t, fD_realtime, M_realtime, angles_realtime, alpha_realtime, beta_realtime);
                        
                        // Push new data to arrays
                        hI_realtime.push(sample.hI);
                        hQ_realtime.push(sample.hQ);
                        envelope_realtime.push(sample.envelope);

                        // Add new data point to chart and update
                        realisticSignalChart.data.labels.push((t * 1000).toFixed(2));
                        realisticSignalChart.data.datasets[0].data.push(sample.envelope);
                        realisticSignalChart.update('none'); // 'none' for smooth animation
                        
                        currentSampleIndex++;
                    } else {
                        // Stop simulation when all samples are generated
                        clearInterval(realisticSimulationInterval);
                        realisticSimulationInterval = null;
                        simulateRealisticButton.textContent = 'Simulate Realistic Model';
                        updateStaticPlots();
                    }
                }, 10); // Update every 10ms for a smooth animation
            }
        }
        
        // NEW: Function to initialize the real-time signal chart
        function initRealisticSignalChart() {
            if (realisticSignalChart) {
                realisticSignalChart.destroy();
            }
            realisticSignalChart = new Chart(document.getElementById('realisticSignalChart'), {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Received Signal Envelope |h(t)|',
                        data: [],
                        borderColor: '#667eea',
                        backgroundColor: 'rgba(102, 126, 234, 0.1)',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.4,
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Time (ms)'
                            },
                            grid: { color: 'rgba(0,0,0,0.1)' }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Signal Envelope Magnitude'
                            },
                            min: 0,
                            grid: { color: 'rgba(0,0,0,0.1)' }
                        }
                    },
                    animation: false // Disable default animation
                }
            });
            document.getElementById('realisticAutocorrelationPanel').style.display = 'none';
            document.getElementById('realisticPsdPanel').style.display = 'none';
        }

        // NEW: This function calculates and plots the static graphs once the simulation is complete
        function updateStaticPlots() {
            if (envelope_realtime.length === 0) return;
            
            // Calculate autocorrelation
            const maxLag = Math.min(Math.floor(N_realtime / 4), 50);
            const realisticAutocorr = calculateAutocorrelationFromComplexSeries(hI_realtime, hQ_realtime, maxLag);
            
            // Calculate ideal autocorrelation for comparison
            const idealAutocorr = [];
            const autocorrTimeAxis = [];
            
            for (let i = 0; i <= maxLag; i++) {
                const tau = i * Ts_realtime;
                autocorrTimeAxis.push(tau * 1000); // Convert to ms
                idealAutocorr.push(besselJ0(2 * Math.PI * fD_realtime * tau));
            }
            
            // Prepare autocorrelation data
            const realisticAutocorrData = realisticAutocorr.map((val, idx) => ({
                x: autocorrTimeAxis[idx],
                y: val
            }));
            
            const idealAutocorrData = idealAutocorr.map((val, idx) => ({
                x: autocorrTimeAxis[idx],
                y: val
            }));
            
            // Calculate PSD
            const realisticPSDResult = calculatePSDFromComplexSeries(hI_realtime, hQ_realtime, N_realtime, Ts_realtime);
            const idealPSD = calculatePSD(parseFloat(velocityRealisticInput.value), parseFloat(frequencyRealisticInput.value) * 1e6); // Convert to Hz
            
            // Prepare PSD data
            const realisticPSDData = realisticPSDResult.psd.map((val, idx) => ({
                x: realisticPSDResult.freqs[idx],
                y: val
            }));
            
            // Update autocorrelation chart
            if (realisticAutocorrelationChart) {
                realisticAutocorrelationChart.destroy();
            }
            
            realisticAutocorrelationChart = new Chart(document.getElementById('realisticAutocorrelationChart'), {
                type: 'line',
                data: {
                    datasets: [
                        {
                            label: 'Realistic (Sum of Sinusoids)',
                            data: realisticAutocorrData,
                            borderColor: '#e53e3e',
                            backgroundColor: 'rgba(229, 62, 62, 0.1)',
                            borderWidth: 2,
                            fill: false,
                            tension: 0.1,
                            pointRadius: 0
                        },
                        {
                            label: 'Ideal (Bessel J0)',
                            data: idealAutocorrData,
                            borderColor: '#667eea',
                            backgroundColor: 'rgba(102, 126, 234, 0.1)',
                            borderWidth: 2,
                            fill: false,
                            tension: 0.4,
                            pointRadius: 0,
                            borderDash: [5, 5]
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: true }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Time Lag τ (ms)'
                            },
                            grid: { color: 'rgba(0,0,0,0.1)' }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'R(τ)'
                            },
                            min: -1,
                            max: 1,
                            grid: { color: 'rgba(0,0,0,0.1)' }
                        }
                    }
                }
            });
            
            // Update PSD chart
            if (realisticPsdChart) {
                realisticPsdChart.destroy();
            }
            
            realisticPsdChart = new Chart(document.getElementById('realisticPsdChart'), {
                type: 'line',
                data: {
                    datasets: [
                        {
                            label: 'Realistic (Sum of Sinusoids)',
                            data: realisticPSDData,
                            borderColor: '#e53e3e',
                            backgroundColor: 'rgba(229, 62, 62, 0.1)',
                            borderWidth: 2,
                            fill: false,
                            tension: 0.1,
                            pointRadius: 0
                        },
                        {
                            label: 'Ideal (Jakes Spectrum)',
                            data: idealPSD,
                            borderColor: '#667eea',
                            backgroundColor: 'rgba(102, 126, 234, 0.1)',
                            borderWidth: 2,
                            fill: false,
                            tension: 0.2,
                            pointRadius: 0,
                            borderDash: [5, 5]
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: true }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Frequency (Hz)'
                            },
                            grid: { color: 'rgba(0,0,0,0.1)' }
                        },
                        y: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Power Spectral Density S(f)'
                            },
                            min: 0,
                            grid: { color: 'rgba(0,0,0,0.1)' }
                        }
                    }
                }
            });

            // Make plot sections visible
            document.getElementById('realisticAutocorrelationPanel').style.display = 'block';
            document.getElementById('realisticPsdPanel').style.display = 'block';
        }

        // Updates ideal model plots
        function updateIdealPlots() {
            const velocities = [
                parseFloat(velocity1Input.value),
                parseFloat(velocity2Input.value),
                parseFloat(velocity3Input.value)
            ];
            const frequency = parseFloat(frequencyInput.value) * 1e6;
            const colors = ['#667eea', '#48bb78', '#fc8181'];
            
            // Determine maxTau for autocorrelation
            const enabledVelocities = [];
            if (v1AutocorrCheck.checked) enabledVelocities.push(velocities[0]);
            if (v2AutocorrCheck.checked) enabledVelocities.push(velocities[1]);
            if (v3AutocorrCheck.checked) enabledVelocities.push(velocities[2]);
            
            let maxTau = 0;
            if (enabledVelocities.length > 0) {
                const maxF_d = Math.max(...enabledVelocities.map(v => v / (SPEED_OF_LIGHT / frequency)));
                maxTau = 2 / Math.max(maxF_d, 1e-9);
            }
            
            // Autocorrelation chart
            if (autocorrelationChart) {
                autocorrelationChart.destroy();
            }
            
            const autocorrDatasets = [];
            if (v1AutocorrCheck.checked) {
                autocorrDatasets.push({
                    label: `Vehicle 1 (v=${velocities[0]} m/s)`,
                    data: calculateAutocorrelation(velocities[0], frequency, maxTau),
                    borderColor: colors[0],
                    backgroundColor: 'rgba(102, 126, 234, 0.1)',
                    borderWidth: 2,
                    fill: false,
                    tension: 0.4,
                    pointRadius: 0
                });
            }
            if (v2AutocorrCheck.checked) {
                autocorrDatasets.push({
                    label: `Vehicle 2 (v=${velocities[1]} m/s)`,
                    data: calculateAutocorrelation(velocities[1], frequency, maxTau),
                    borderColor: colors[1],
                    backgroundColor: 'rgba(72, 187, 120, 0.1)',
                    borderWidth: 2,
                    fill: false,
                    tension: 0.4,
                    pointRadius: 0
                });
            }
            if (v3AutocorrCheck.checked) {
                autocorrDatasets.push({
                    label: `Vehicle 3 (v=${velocities[2]} m/s)`,
                    data: calculateAutocorrelation(velocities[2], frequency, maxTau),
                    borderColor: colors[2],
                    backgroundColor: 'rgba(252, 129, 129, 0.1)',
                    borderWidth: 2,
                    fill: false,
                    tension: 0.4,
                    pointRadius: 0
                });
            }

            autocorrelationChart = new Chart(document.getElementById('autocorrelationChart'), {
                type: 'line',
                data: { datasets: autocorrDatasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: true }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Delay τ (ms)'
                            },
                            grid: { color: 'rgba(0,0,0,0.1)' }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Correlation'
                            },
                            min: -1,
                            max: 1,
                            grid: { color: 'rgba(0,0,0,0.1)' }
                        }
                    }
                }
            });

            // PSD chart
            if (psdChart) {
                psdChart.destroy();
            }
            
            const psdDatasets = [];
            if (v1PsdCheck.checked) {
                psdDatasets.push({
                    label: `Vehicle 1 (v=${velocities[0]} m/s)`,
                    data: calculatePSD(velocities[0], frequency),
                    borderColor: colors[0],
                    backgroundColor: 'rgba(102, 126, 234, 0.1)',
                    borderWidth: 2,
                    fill: true,
                    tension: 0.2,
                    pointRadius: 0
                });
            }
            if (v2PsdCheck.checked) {
                psdDatasets.push({
                    label: `Vehicle 2 (v=${velocities[1]} m/s)`,
                    data: calculatePSD(velocities[1], frequency),
                    borderColor: colors[1],
                    backgroundColor: 'rgba(72, 187, 120, 0.1)',
                    borderWidth: 2,
                    fill: true,
                    tension: 0.2,
                    pointRadius: 0
                });
            }
            if (v3PsdCheck.checked) {
                psdDatasets.push({
                    label: `Vehicle 3 (v=${velocities[2]} m/s)`,
                    data: calculatePSD(velocities[2], frequency),
                    borderColor: colors[2],
                    backgroundColor: 'rgba(252, 129, 129, 0.1)',
                    borderWidth: 2,
                    fill: true,
                    tension: 0.2,
                    pointRadius: 0
                });
            }

            psdChart = new Chart(document.getElementById('psdChart'), {
                type: 'line',
                data: { datasets: psdDatasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: true }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Frequency (Hz)'
                            },
                            grid: { color: 'rgba(0,0,0,0.1)' }
                        },
                        y: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Power Density'
                            },
                            min: 0,
                            grid: { color: 'rgba(0,0,0,0.1)' }
                        }
                    }
                }
            });
            
            // Make plot sections visible
            document.getElementById('autocorrelationPanel').style.display = 'block';
            document.getElementById('psdPanel').style.display = 'block';
        }
        
        // Event listeners for ideal model
        velocity1Input.addEventListener('input', drawEnvironment);
        velocity2Input.addEventListener('input', drawEnvironment);
        velocity3Input.addEventListener('input', drawEnvironment);
        frequencyInput.addEventListener('input', drawEnvironment);
        scatterersInput.addEventListener('input', drawEnvironment);

        // Event listeners for realistic model 
        velocityRealisticInput.addEventListener('input', drawRealisticEnvironment);
        frequencyRealisticInput.addEventListener('input', drawRealisticEnvironment);
        multipathsInput.addEventListener('input', drawRealisticEnvironment);
        samplesInput.addEventListener('input', () => {
            // Stop and restart simulation if parameters change
            if (realisticSimulationInterval) {
                startRealisticSimulation(); 
            }
        });

        // Listeners for checkboxes to update ideal plots
        v1AutocorrCheck.addEventListener('change', updateIdealPlots);
        v2AutocorrCheck.addEventListener('change', updateIdealPlots);
        v3AutocorrCheck.addEventListener('change', updateIdealPlots);
        v1PsdCheck.addEventListener('change', updateIdealPlots);
        v2PsdCheck.addEventListener('change', updateIdealPlots);
        v3PsdCheck.addEventListener('change', updateIdealPlots);
        
        window.addEventListener('resize', () => {
            setTimeout(() => {
                if (currentTab === 'ideal' && autocorrelationChart) {
                    updateIdealPlots();
                    drawEnvironment();
                } else if (currentTab === 'realistic' && realisticAutocorrelationChart) {
                    drawRealisticEnvironment();
                    if(!realisticSimulationInterval) {
                        updateStaticPlots();
                    }
                }
            }, 100);
        });

        // Initial state
        document.getElementById('autocorrelationPanel').style.display = 'none';
        document.getElementById('psdPanel').style.display = 'none';
        document.getElementById('realisticAutocorrelationPanel').style.display = 'none';
        document.getElementById('realisticPsdPanel').style.display = 'none';
        drawEnvironment();
    </script>
</body>
</html>