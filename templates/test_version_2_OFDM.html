<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OFDM Virtual Experiment</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 2.5rem 1rem;
            box-sizing: border-box;
        }

        .container {
            background-color: #ffffff;
            border-radius: 1.5rem;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.1);
            padding: 2rem;
            width: 100%;
            max-width: 1600px;
            min-height: 600px;
        }

        @media (max-width: 1400px) {
            .container {
                grid-template-columns: 260px 1fr 320px;
                gap: 1rem;
            }
        }

        @media (max-width: 1200px) {
            .container {
                grid-template-columns: 1fr;
                gap: 2rem;
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 1.5rem;
            }
        }

        .block-diagram-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 1.5rem;
            overflow: visible;
            padding: 10px;
            width: 100%;
        }

        h2 {
            font-size: 1.5rem;
            font-weight: 700;
            color: #1e293b;
            text-align: center;
            margin-bottom: 1.5rem;
        }

        @media (max-width: 768px) {
            h2 {
                font-size: 1.25rem;
            }
        }

        .input-section {
            border-right: 2px solid #e2e8f0;
            padding-right: 1.5rem;
            min-width: 280px;
        }

        @media (max-width: 1200px) {
            .input-section {
                border-right: none;
                border-bottom: 2px solid #e2e8f0;
                padding-right: 0;
                padding-bottom: 2rem;
            }
        }

        .input-group {
            display: flex;
            flex-direction: column;
            margin-bottom: 1rem;
        }

        .input-group label {
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: #475569;
        }

        .input-group input, .input-group select {
            padding: 0.75rem 1rem;
            border: 1px solid #cbd5e1;
            border-radius: 0.5rem;
            font-size: 1rem;
            color: #334155;
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }

        .input-group input:focus, .input-group select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }

        .button-primary {
            background-color: #3b82f6;
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            border: none;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            width: 100%;
        }

        .button-primary:hover {
            background-color: #2563eb;
            transform: translateY(-1px);
        }

        .button-primary:active {
            background-color: #1d4ed8;
            transform: translateY(0);
        }

        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3b82f6;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            display: none;
            margin: 1rem auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-message {
            color: #ef4444;
            background-color: #fee2e2;
            border: 1px solid #fca5a5;
            padding: 0.75rem;
            border-radius: 0.5rem;
            margin-top: 1rem;
            display: none;
        }

        .simulation-area {
            grid-column: 2;
            min-width: 0;
        }

        @media (max-width: 1200px) {
            .simulation-area {
                grid-column: 1;
            }
        }

        .ofdm-block {
            fill: #e0e7ff;
            stroke: #3b82f6;
            stroke-width: 2;
            transition: fill 0.3s ease, stroke 0.3s ease, transform 0.3s ease;
        }

        .ofdm-block-text {
            font-family: 'Inter', sans-serif;
            font-size: 12px;
            font-weight: 600;
            fill: #1e293b;
            text-anchor: middle;
            dominant-baseline: central;
            pointer-events: none;
        }

        .ofdm-block.highlighted {
            fill: #93c5fd;
            stroke: #1d4ed8;
            stroke-width: 3;
            transform: scale(1.05);
        }

        .ofdm-block-text.highlighted {
            font-weight: 700;
        }

        .arrow {
            stroke: #64748b;
            stroke-width: 2;
            fill: none;
            marker-end: url(#arrowhead);
            transition: stroke 0.3s ease;
        }

        .arrowhead {
            fill: #64748b;
        }

        .arrow.highlighted {
            stroke: #1d4ed8;
        }

        .chart-container {
            margin-top: 1.5rem;
            width: 100%;
            overflow: hidden;
        }

        .chart-container canvas {
            max-width: 100% !important;
            max-height: 350px !important;
            height: 350px !important;
            width: 100% !important;
        }

        .chart-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: #374151;
            text-align: center;
            margin-bottom: 1rem;
        }

        @media (max-width: 768px) {
            .chart-title {
                font-size: 1.125rem;
            }
        }

        /* Find the .nav-buttons style (around line 247) and replace with: */
        .nav-buttons {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1.5rem;
            flex-wrap: wrap;
        }

        .nav-buttons button {
            min-width: 120px;
            flex: 1 1 auto;
            max-width: 200px; /* Prevents buttons from getting too wide */
        }

        .output-area {
            grid-column: 3;
            border-left: 2px solid #e2e8f0;
            padding-left: 1.5rem;
            min-width: 350px;
        }

        @media (max-width: 1200px) {
            .output-area {
                grid-column: 1;
                border-left: none;
                border-top: 2px solid #e2e8f0;
                padding-left: 0;
                padding-top: 2rem;
            }
        }

        .simulation-info {
            background-color: #f1f5f9;
            border-radius: 0.75rem;
            padding: 1.5rem;
            margin-top: 1.5rem;
            border: 1px solid #e2e8f0;
        }

        .simulation-info h3 {
            font-size: 1.125rem;
            font-weight: 600;
            color: #1e293b;
            margin-bottom: 0.75rem;
        }

        .simulation-info p {
            font-family: 'monospace', sans-serif;
            font-size: 0.875rem;
            color: #334155;
            line-height: 1.5;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 200px;
            overflow-y: auto;
        }

        #ofdmBlockDiagram {
            max-width: 100%;
            height: auto;
            width: 500px;
            max-height: 280px;
        }

        .symbol-item {
            min-width: 45px;
            height: 28px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: 600;
            border: 1.5px solid;
            white-space: nowrap;
            text-overflow: ellipsis;
            overflow: hidden;
            position: relative;
        }

        .symbol-item.data {
            background: #dbeafe;
            border-color: var(--primary-blue);
            color: var(--text-primary);
        }

        .symbol-item.cp {
            background: #fed7d7;
            border-color: var(--error-red);
            color: var(--error-red);
            font-weight: 700;
        }

        .symbol-item.ellipsis {
            background: #f1f5f9;
            border-color: var(--secondary-gray);
            color: var(--text-secondary);
            border-style: dashed;
            min-width: 30px;
        }

        .symbol-separator {
            font-size: 14px;
            color: var(--text-secondary);
            margin: 0 4px;
            font-weight: bold;
        }

        /* === Add this entire block to your main.css file === */
        .symbol-display {
            display: flex;
            flex-wrap: wrap;
            gap: 3px;
            justify-content: center;
            align-items: flex-end; /* Changed from flex-start to flex-end */
            margin-top: 12px;
            padding: 20px 12px;
            background-color: #f1f5f9;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Menlo', 'Monaco', monospace;
            min-height: 120px;
        }

        .symbol-item {
            min-width: 50px;
            height: 30px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: 600;
            border: 1.5px solid;
            white-space: nowrap;
            text-overflow: ellipsis;
            overflow: hidden;
            position: relative;
            padding: 0 5px;
        }

        .symbol-item.data {
            background: #dbeafe;   /* Light blue */
            border-color: #60a5fa;  /* Blue border */
            color: #1e3a8a;       /* Dark blue text */
        }

        .symbol-item.cp {
            background: #fee2e2;   /* Light red */
            border-color: #fca5a5;  /* Red border */
            color: #991b1b;       /* Dark red text */
            font-weight: 700;
        }

        .symbol-item.ellipsis {
            background: #f1f5f9;
            border-color: #94a3b8; /* Gray border */
            color: #475569;      /* Gray text */
            border-style: dashed;
            min-width: 30px;
        }

        .symbol-separator {
            font-size: 16px;
            color: #64748b;
            margin: 0 4px;
            font-weight: bold;
        }

        @media (max-width: 768px) {
            #ofdmBlockDiagram {
                width: 100%;
                max-width: 450px;
            }
        }

        .tab-nav {
            display: flex;
            justify-content: center;
            margin-bottom: 2rem;
            border-bottom: 2px solid #e2e8f0;
        }

        .tab-link {
            padding: 0.75rem 1.5rem;
            background: none;
            border: none;
            font-size: 1rem;
            font-weight: 600;
            color: #64748b;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.3s ease;
        }

        .tab-link:hover {
            color: #3b82f6;
        }

        .tab-link.active {
            color: #3b82f6;
            border-bottom-color: #3b82f6;
        }

        .tab-content {
            display: none;
        }

        .main-content-grid {
            display: grid;
            grid-template-columns: 280px 1fr 350px;
            gap: 1.5rem;
            min-height: 600px;
        }

        .symbol-item.with-bracket {
            display: inline-flex;
            flex-direction: column;
            align-items: center;
            gap: 0;
            min-width: auto;
            padding: 0; /* Increased bottom padding from 4px to 8px */
            border: none;
            background: transparent;
            position: relative;
            margin-bottom: 8px; /* Increased from 12px to 16px */
        }

        .symbol-bits-box {
            min-width: 50px;
            height: 20px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: 600;
            border: 1.5px solid;
            letter-spacing: 3px;
            padding: 0 8px;
        }

        .symbol-bits-box.data {
            background: #dbeafe;
            border-color: #60a5fa;
            color: #1e3a8a;
        }

        .symbol-bits-box.cp {
            background: #fee2e2;
            border-color: #fca5a5;
            color: #991b1b;
        }

        .symbol-bracket-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 2px; /* Slight spacing from box */
            min-height: 32px; /* Ensure space for bracket and label */
        }

        .symbol-bracket {
            font-size: 20px;
            line-height: 1;
            color: #64748b;
            font-weight: 400;
        }

        .symbol-label {
            font-size: 11px;
            font-weight: 700;
            margin-top: 2px;
            color: #475569;
            white-space: nowrap; /* Prevent label from wrapping */

        }

        @media (max-width: 1400px) {
            .main-content-grid {
                grid-template-columns: 260px 1fr 320px;
                gap: 1rem;
            }
        }

        @media (max-width: 1200px) {
            .main-content-grid {
                grid-template-columns: 1fr;
                gap: 2rem;
            }
            
            .input-section {
                border-right: none;
                border-bottom: 2px solid #e2e8f0;
                padding-right: 0;
                padding-bottom: 2rem;
            }
            
            .output-area {
                border-left: none;
                border-top: 2px solid #e2e8f0;
                padding-left: 0;
                padding-top: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="w-full col-span-full">
            <h2 class="text-3xl font-bold text-center text-gray-800 mb-6">OFDM Virtual Experiment</h2>
            
            <div class="tab-nav">
                <button class="tab-link active" onclick="openTab(event, 'simulationTab')">Signal Flow Simulation</button>
                <button class="tab-link" onclick="openTab(event, 'berAnalysisTab')">BER Performance Analysis</button>
            </div>
        </div>

        <!-- Signal Flow Simulation Tab -->
        <div id="simulationTab" class="tab-content" style="display: block;">
            <div class="main-content-grid">
                <div class="input-section">
                    <h3 class="text-xl font-bold text-gray-800 mb-4">Step-by-Step Controls</h3>
                    <!-- Your existing input controls here -->
                    <div class="input-group">
                        <label for="nFFTSize">FFT Size (N):</label>
                        <input type="number" id="nFFTSize" value="64" min="16" step="16">
                    </div>
                    <div class="input-group">
                        <label for="numSubcarriers">Number of Data Subcarriers:</label>
                        <input type="number" id="numSubcarriers" value="52" min="12" step="4">
                    </div>
                    <div class="input-group">
                        <label for="modulationScheme">Modulation Scheme:</label>
                        <select id="modulationScheme">
                            <option value="BPSK">BPSK</option>
                            <option value="QPSK">QPSK</option>
                            <option value="16QAM">16-QAM</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label for="cpLength">Cyclic Prefix Length:</label>
                        <input type="number" id="cpLength" value="16" min="4" step="4">
                    </div>
                    <div class="input-group">
                        <label for="snrDb">SNR (dB) for Plots:</label>
                        <input type="number" id="snrDb" value="20" min="-10" max="50" step="1">
                    </div>
                    <div class="input-group">
                        <label for="equalization">Equalization Method:</label>
                        <select id="equalization">
                            <option value="ZF">Zero-Forcing (ZF)</option>
                            <option value="MMSE">MMSE</option>
                        </select>
                    </div>
                    <button id="runStepByStepBtn" class="button-primary">Run Simulation</button>
                    <div id="loadingSpinner" class="loading-spinner"></div>
                    <div id="errorMessage" class="error-message"></div>
                </div>

                <div class="simulation-area">
                    <h3 class="text-xl font-bold text-center text-gray-800 mb-4">OFDM Signal Flow</h3>
                    <div class="block-diagram-container">
                    <svg id="ofdmBlockDiagram" viewBox="0 0 490 240" xmlns="http://www.w3.org/2000/svg">
                        <defs>
                            <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#1e293b" />
                            </marker>
                            <style>
                                .ofdm-block { fill: #e0e7ff; stroke: #3b82f6; stroke-width: 2; }
                                .ofdm-block-text { font-family: Arial, sans-serif; font-size: 12px; text-anchor: middle; dominant-baseline: middle; fill: #1e293b; }
                                .arrow { stroke: #1e293b; stroke-width: 2; marker-end: url(#arrowhead); fill: none; }
                                .arrowhead { fill: #1e293b; }
                            </style>
                        </defs>
                        
                        <!-- Top row: Transmitter blocks with uniform 20px spacing -->
                        <rect id="block-tx" class="ofdm-block" x="10" y="10" width="90" height="45" rx="6"></rect>
                        <text class="ofdm-block-text" x="55" y="27">S/P</text>
                        <text class="ofdm-block-text" x="55" y="42">+ Mapping</text>
                        
                        <line id="mapping-to-idft" class="arrow" x1="100" y1="32.5" x2="120" y2="32.5" />
                        
                        <rect id="block-idft" class="ofdm-block" x="120" y="10" width="90" height="45" rx="6"></rect>
                        <text class="ofdm-block-text" x="165" y="32.5">IDFT</text>
                        
                        <line id="idft-to-addcp" class="arrow" x1="210" y1="32.5" x2="230" y2="32.5" />
                        
                        <rect id="block-addcp" class="ofdm-block" x="230" y="10" width="90" height="45" rx="6"></rect>
                        <text class="ofdm-block-text" x="275" y="32.5">Add CP</text>
                        
                        <!-- Channel block aligned with uniform spacing -->
                        <rect id="block-channel" class="ofdm-block" x="340" y="75" width="90" height="45" rx="6"></rect>
                        <text class="ofdm-block-text" x="385" y="97.5">Channel</text>
                        
                        <!-- AWGN summer symbol positioned between Channel and Remove CP -->
                        <circle cx="385" cy="140" r="12" fill="#fef3c7" stroke="#f59e0b" stroke-width="2"/>
                        <line x1="379" y1="140" x2="391" y2="140" stroke="#1e293b" stroke-width="1.5"/>
                        <line x1="385" y1="134" x2="385" y2="146" stroke="#1e293b" stroke-width="1.5"/>
                        
                        <!-- AWGN noise source -->
                        <line class="arrow" x1="340" y1="140" x2="370" y2="140" />
                        <text class="ofdm-block-text" x="320" y="141">AWGN</text>

                        <!-- Bottom row: Receiver blocks with uniform 20px spacing -->
                        <rect id="block-rx" class="ofdm-block" x="10" y="180" width="90" height="45" rx="6"></rect>
                        <text class="ofdm-block-text" x="55" y="197">Demapping</text>
                        <text class="ofdm-block-text" x="55" y="212">+ P/S</text>
                        
                        <line id="equalizer-to-demapping" class="arrow" x1="120" y1="202.5" x2="100" y2="202.5" />
                        
                        <rect id="block-equalizer" class="ofdm-block" x="120" y="180" width="90" height="45" rx="6"></rect>
                        <text class="ofdm-block-text" x="165" y="202.5">Equalizer</text>
                        
                        <line id="fft-to-equalizer" class="arrow" x1="230" y1="202.5" x2="210" y2="202.5" />
                        
                        <rect id="block-fft" class="ofdm-block" x="230" y="180" width="90" height="45" rx="6"></rect>
                        <text class="ofdm-block-text" x="275" y="202.5">FFT</text>
                        
                        <line id="removecp-to-fft" class="arrow" x1="340" y1="202.5" x2="320" y2="202.5" />
                        
                        <rect id="block-removecp" class="ofdm-block" x="340" y="180" width="90" height="45" rx="6"></rect>
                        <text class="ofdm-block-text" x="385" y="202.5">Remove CP</text>
                        
                        <!-- Connecting arrows with updated positions -->
                        <polyline id="addcp-to-channel" class="arrow" points="320,32.5 385,32.5 385,75" />
                        <line id="channel-to-awgn" class="arrow" x1="385" y1="120" x2="385" y2="128" />
                        <line id="awgn-to-removecp" class="arrow" x1="385" y1="152" x2="385" y2="180" />
                    </svg>
                    </div>

                    <div class="simulation-info">
                        <h3 id="blockOutputTitle">Simulation Step Output</h3>
                        <div id="symbolDisplay" class="symbol-display" style="display: none;"></div>
                        <p id="blockOutputDisplay">Run a simulation to see the step-by-step output here.</p>
                    </div>

                    <div class="nav-buttons">
                        <button id="prevBlockBtn" class="button-primary" disabled>Previous</button>
                        <button id="nextBlockBtn" class="button-primary" disabled>Next</button>
                    </div>
                </div>

                <div class="output-area">
                    <!-- Chart containers for simulation tab -->
                    <div class="chart-container">
                        <h3 class="chart-title" id="constellationChartTitle">Transmitted Constellation</h3>
                        <canvas id="constellationChart"></canvas>
                    </div>
                    <div class="chart-container" style="display: none;">
                        <h3 class="chart-title" id="preChannelSpectrumChartTitle">Pre-Channel Spectrum</h3>
                        <canvas id="preChannelSpectrumChart"></canvas>
                    </div>
                    <div class="chart-container" style="display: none;">
                        <h3 class="chart-title" id="postChannelSpectrumChartTitle">Post-Channel Spectrum</h3>
                        <canvas id="postChannelSpectrumChart"></canvas>
                    </div>
                    <div class="chart-container" style="display: none;">
                        <h3 class="chart-title" id="equalizedSpectrumChartTitle">Equalized Signal Spectrum</h3>
                        <canvas id="equalizedSpectrumChart"></canvas>
                    </div>
                    <div class="chart-container" style="display: none;">
                        <h3 class="chart-title" id="receivedConstellationChartTitle">Received Constellation</h3>
                        <canvas id="receivedConstellationChart"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <!-- BER Analysis Tab -->
        <div id="berAnalysisTab" class="tab-content" style="display: none;">
            <div class="main-content-grid">
                <div class="input-section">
                    <h3 class="text-xl font-bold text-gray-800 mb-4">BER Simulation Controls</h3>
                    <div class="input-group">
                        <label for="ber_ofdmLength">Length of OFDM Data (L):</label>
                        <input type="number" id="ber_ofdmLength" value="64" min="16" step="16">
                    </div>
                    <div class="input-group">
                        <label for="ber_cpLength">Cyclic Prefix Length (Ncp):</label>
                        <input type="number" id="ber_cpLength" value="4" min="1" max="16">
                    </div>
                    <div class="input-group">
                        <label for="ber_modulationScheme">Modulation Scheme:</label>
                        <select id="ber_modulationScheme">
                            <option value="16QAM" selected>16-QAM</option>
                            <option value="QPSK">QPSK</option>
                            <option value="BPSK">BPSK</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label for="ber_snrIncrement">SNR Increment (dB):</label>
                        <input type="number" id="ber_snrIncrement" value="1" min="0.5" max="5" step="0.5">
                    </div>
                    <button id="runBerSimBtn" class="button-primary">Run BER Simulation</button>
                    <div id="loadingSpinnerBER" class="loading-spinner"></div>
                    <div id="errorMessageBER" class="error-message"></div>
                </div>
                
                <div class="w-full" style="grid-column: 2 / -1;">
                    <div class="chart-container" style="display: none;">
                        <h3 class="chart-title" id="berCurveChartTitle">BER vs. SNR Performance</h3>
                        <canvas id="berCurveChart"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Complex Number Class and DSP Helper Functions ---
        class Complex {
            constructor(re, im = 0) {
                this.re = re;
                this.im = im;
            }
            add(other) {
                return new Complex(this.re + other.re, this.im + other.im);
            }
            sub(other) {
                return new Complex(this.re - other.re, this.im - other.im);
            }
            mul(other) {
                return new Complex(
                    this.re * other.re - this.im * other.im,
                    this.re * other.im + this.im * other.re
                );
            }
            div(other) {
                if (other.re === 0 && other.im === 0) return new Complex(Infinity, Infinity);
                const den = other.re * other.re + other.im * other.im;
                return new Complex(
                    (this.re * other.re + this.im * other.im) / den,
                    (this.im * other.re - this.re * other.im) / den
                );
            }
            magSq() {
                return this.re * this.re + this.im * this.im;
            }
            mag() {
                return Math.sqrt(this.magSq());
            }
            conj() {
                return new Complex(this.re, -this.im);
            }
            toString() {
                if (this.im === 0) return this.re.toFixed(3);
                if (this.re === 0) return `${this.im.toFixed(3)}i`;
                const sign = this.im > 0 ? '+' : '';
                return `${this.re.toFixed(3)}${sign}${this.im.toFixed(3)}i`;
            }
        }
        function fft(x) {
            const N = x.length;
            if (N <= 1) return x;
            const even = [];
            const odd = [];
            for (let i = 0; i < N / 2; i++) {
                even[i] = x[i * 2];
                odd[i] = x[i * 2 + 1];
            }
            const Y_even = fft(even);
            const Y_odd = fft(odd);
            const Y = new Array(N);
            for (let k = 0; k < N / 2; k++) {
                const t = new Complex(Math.cos(-2 * Math.PI * k / N), Math.sin(-2 * Math.PI * k / N)).mul(Y_odd[k]);
                Y[k] = Y_even[k].add(t);
                Y[k + N / 2] = Y_even[k].sub(t);
            }
            return Y;
        }
        function ifft(X) {
            const N = X.length;
            if (N <= 1) return X;
            const X_conj = X.map(c => new Complex(c.re, -c.im));
            const y_conj = fft(X_conj);
            return y_conj.map(c => new Complex(c.re / N, -c.im / N));
        }
        function fftshift(arr) {
            const mid = Math.floor(arr.length / 2);
            return [...arr.slice(mid), ...arr.slice(0, mid)];
        }
        function dbToLinear(db) {
            return Math.pow(10, db / 10);
        }
        function linearToDb(linear) {
            if (linear <= 0 || !isFinite(linear)) return -100;
            const dbValue = 10 * Math.log10(linear);
            return isFinite(dbValue) ? dbValue : -100;
        }
        function randn() {
            let u = 0, v = 0;
            while (u === 0) u = Math.random();
            while (v === 0) v = Math.random();
            return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
        }
        function bpskModulate(bit) { return new Complex(2 * bit - 1); }
        function qpskModulate(bits) {
            const real = (2 * bits[0] - 1) / Math.sqrt(2);
            const imag = (2 * bits[1] - 1) / Math.sqrt(2);
            return new Complex(real, imag);
        }
        function qam16Modulate(bits) {
            const map = {
                "0000": new Complex(-3 / Math.sqrt(10), -3 / Math.sqrt(10)), "0001": new Complex(-3 / Math.sqrt(10), -1 / Math.sqrt(10)),
                "0010": new Complex(-3 / Math.sqrt(10), 3 / Math.sqrt(10)), "0011": new Complex(-3 / Math.sqrt(10), 1 / Math.sqrt(10)),
                "0100": new Complex(-1 / Math.sqrt(10), -3 / Math.sqrt(10)), "0101": new Complex(-1 / Math.sqrt(10), -1 / Math.sqrt(10)),
                "0110": new Complex(-1 / Math.sqrt(10), 3 / Math.sqrt(10)), "0111": new Complex(-1 / Math.sqrt(10), 1 / Math.sqrt(10)),
                "1000": new Complex(3 / Math.sqrt(10), -3 / Math.sqrt(10)), "1001": new Complex(3 / Math.sqrt(10), -1 / Math.sqrt(10)),
                "1010": new Complex(3 / Math.sqrt(10), 3 / Math.sqrt(10)), "1011": new Complex(3 / Math.sqrt(10), 1 / Math.sqrt(10)),
                "1100": new Complex(1 / Math.sqrt(10), -3 / Math.sqrt(10)), "1101": new Complex(1 / Math.sqrt(10), -1 / Math.sqrt(10)),
                "1110": new Complex(1 / Math.sqrt(10), 3 / Math.sqrt(10)), "1111": new Complex(1 / Math.sqrt(10), 1 / Math.sqrt(10)),
            };
            return map[bits.join('')];
        }
        function bpskDemodulate(symbol) { return symbol.re > 0 ? 1 : 0; }
        function qpskDemodulate(symbol) {
            return [symbol.re > 0 ? 1 : 0, symbol.im > 0 ? 1 : 0];
        }
        function qam16Demodulate(symbol) {
            const constellationPoints = {
                "0000": new Complex(-3 / Math.sqrt(10), -3 / Math.sqrt(10)), "0001": new Complex(-3 / Math.sqrt(10), -1 / Math.sqrt(10)),
                "0010": new Complex(-3 / Math.sqrt(10), 3 / Math.sqrt(10)), "0011": new Complex(-3 / Math.sqrt(10), 1 / Math.sqrt(10)),
                "0100": new Complex(-1 / Math.sqrt(10), -3 / Math.sqrt(10)), "0101": new Complex(-1 / Math.sqrt(10), -1 / Math.sqrt(10)),
                "0110": new Complex(-1 / Math.sqrt(10), 3 / Math.sqrt(10)), "0111": new Complex(-1 / Math.sqrt(10), 1 / Math.sqrt(10)),
                "1000": new Complex(3 / Math.sqrt(10), -3 / Math.sqrt(10)), "1001": new Complex(3 / Math.sqrt(10), -1 / Math.sqrt(10)),
                "1010": new Complex(3 / Math.sqrt(10), 3 / Math.sqrt(10)), "1011": new Complex(3 / Math.sqrt(10), 1 / Math.sqrt(10)),
                "1100": new Complex(1 / Math.sqrt(10), -3 / Math.sqrt(10)), "1101": new Complex(1 / Math.sqrt(10), -1 / Math.sqrt(10)),
                "1110": new Complex(1 / Math.sqrt(10), 3 / Math.sqrt(10)), "1111": new Complex(1 / Math.sqrt(10), 1 / Math.sqrt(10)),
            };
            let minDistanceSq = Infinity;
            let demodulatedBits = '';
            for (const bitString in constellationPoints) {
                const idealPoint = constellationPoints[bitString];
                const distanceSq = (symbol.re - idealPoint.re) ** 2 + (symbol.im - idealPoint.im) ** 2;
                if (distanceSq < minDistanceSq) {
                    minDistanceSq = distanceSq;
                    demodulatedBits = bitString;
                }
            }
            return demodulatedBits.split('').map(Number);
        }

        function generateBits(numBits) { return Array.from({ length: numBits }, () => Math.random() > 0.5 ? 1 : 0); }

        function openTab(evt, tabName) {
            // Hide all tab contents
            const tabContents = document.getElementsByClassName("tab-content");
            for (let i = 0; i < tabContents.length; i++) {
                tabContents[i].style.display = "none";
            }

            // Remove active class from all tab links
            const tabLinks = document.getElementsByClassName("tab-link");
            for (let i = 0; i < tabLinks.length; i++) {
                tabLinks[i].classList.remove("active");
            }

            // Show the selected tab and mark button as active
            document.getElementById(tabName).style.display = "block";
            evt.currentTarget.classList.add("active");

            // Reset charts and UI state when switching tabs
            if (tabName === 'simulationTab') {
                // Show the first chart when entering simulation tab
                updateChartVisibility(0);
            } else {
                hideStepByStepCharts();
            }
            hideOutputCharts();
            
            if (tabName === 'simulationTab') {
                // Reset to first block for step-by-step
                currentBlockIndex = 0;
                highlightBlock(currentBlockIndex);
            }
        }

        function modulate(bits, modulationScheme, bitsPerSymbol) {
            const modulatedSymbols = [];
            let modulateFunc;
            switch (modulationScheme) {
                case 'BPSK': modulateFunc = bpskModulate; break;
                case 'QPSK': modulateFunc = qpskModulate; break;
                case '16QAM': modulateFunc = qam16Modulate; break;
                default: throw new Error('Invalid modulation scheme.');
            }
            for (let i = 0; i < bits.length; i += bitsPerSymbol) {
                const currentBits = bits.slice(i, i + bitsPerSymbol);
                if (bitsPerSymbol === 1) {
                    modulatedSymbols.push(modulateFunc(currentBits[0]));
                } else {
                    modulatedSymbols.push(modulateFunc(currentBits));
                }
            }
            return modulatedSymbols;
        }
        
        function mapToSubcarriers(symbols, nFFTSize, numSubcarriers) {
            const inputiFFT = Array.from({ length: nFFTSize }, () => new Complex(0));
            let symbolIdx = 0;
            
            if (nFFTSize === 64 && numSubcarriers === 52) {
                // 802.11a standard mapping
                const subcarrierIndices = [
                    -26,-25,-24,-23,-22,-21,-20,-19,-18,-17,-16,-15,-14,-13,-12,-11,
                    -10,-9,-8,-7,-6,-5,-4,-3,-2,-1,
                    1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26
                ];
                for (const scIdx of subcarrierIndices) {
                    let arrayIdx = scIdx > 0 ? scIdx : nFFTSize + scIdx;
                    if (symbolIdx < symbols.length) {
                        inputiFFT[arrayIdx] = symbols[symbolIdx++];
                    }
                }
            } else {
                // Generic symmetric mapping - must match extraction
                const halfSubcarriers = Math.floor(numSubcarriers / 2);
                const extraSubcarrier = numSubcarriers % 2;
                
                // Map to positive frequencies first
                for (let i = 1; i <= halfSubcarriers + extraSubcarrier && symbolIdx < symbols.length; i++) {
                    inputiFFT[i] = symbols[symbolIdx++];
                }
                
                // Map to negative frequencies
                for (let i = nFFTSize - halfSubcarriers; i < nFFTSize && symbolIdx < symbols.length; i++) {
                    inputiFFT[i] = symbols[symbolIdx++];
                }
            }
            
            return inputiFFT;
        }

        function addCyclicPrefix(signal, cpLength) {
            const cyclicPrefix = signal.slice(signal.length - cpLength);
            return [...cyclicPrefix, ...signal];
        }

        // --- Replace the existing applyMultitapChannel and addAwgn functions ---

        function applyMultitapChannel(signal, numTaps) {
            // Generate channel coefficients (normalized so E[||h||^2] = 1)
            const h = Array.from({ length: numTaps }, () => {
                const h_real = randn() / Math.sqrt(2 * numTaps);
                const h_imag = randn() / Math.sqrt(2 * numTaps);
                return new Complex(h_real, h_imag);
            });
            
            // Apply convolution: y[n] = sum(h[l] * x[n-l])
            const fadedSignal = new Array(signal.length).fill(new Complex(0));
            for (let n = 0; n < signal.length; n++) {
                for (let l = 0; l < numTaps && n - l >= 0; l++) {
                    fadedSignal[n] = fadedSignal[n].add(signal[n - l].mul(h[l]));
                }
            }
            
            return { fadedSignal, channelCoeffs: h };
        }

        // Fix 3: Improved AWGN function for better noise scaling
        function addAwgn(signal, snrDb, nFFT, cpLen, numDataCarriers) {
            // Calculate signal power from actual signal samples
            const signalPower = signal.reduce((sum, s) => sum + s.magSq(), 0) / signal.length;
            if (signalPower === 0) return signal;

            // Convert SNR to linear scale
            const snrLinear = dbToLinear(snrDb);
            
            // Calculate noise power: P_noise = P_signal / SNR
            const noisePower = signalPower / snrLinear;
            const noiseStdDev = Math.sqrt(noisePower / 2); // /2 because complex noise has two dimensions

            const noisySignal = signal.map(sample => {
                const noiseReal = randn() * noiseStdDev;
                const noiseImag = randn() * noiseStdDev;
                return sample.add(new Complex(noiseReal, noiseImag));
            });
            
            return noisySignal;
        }

        function removeCyclicPrefix(signalWithCP, cpLength, nFFTSize) {
            return signalWithCP.slice(cpLength, cpLength + nFFTSize);
        }

        // Replace your existing equalize function with this one
        function equalize(receivedSymbolsFFT, channelGainsFFT, method, snrDb) {
            const snrLinear = dbToLinear(snrDb);
            return receivedSymbolsFFT.map((sym, i) => {
                const channelGain = channelGainsFFT[i];
                if (channelGain.magSq() < 1e-10) {
                    return new Complex(0, 0); // Avoid division by zero
                }

                let equalizedSymbol;
                switch (method) {
                    case 'MMSE':
                        const channelMagSq = channelGain.magSq();
                        const mmseWeight = channelGain.conj().div(new Complex(channelMagSq + 1 / snrLinear));
                        equalizedSymbol = sym.mul(mmseWeight);
                        break;
                    
                    case 'ZF':
                    default:
                        equalizedSymbol = sym.div(channelGain);
                        break;
                }

                // Safety check for huge numbers after equalization
                if (!isFinite(equalizedSymbol.re) || !isFinite(equalizedSymbol.im) || Math.abs(equalizedSymbol.re) > 100 || Math.abs(equalizedSymbol.im) > 100) {
                    return new Complex(0, 0);
                }
                return equalizedSymbol;
            });
        }

        function demodulate(symbols, modulationScheme) {
            const demodulatedBits = [];
            let demodulateFunc;
            switch (modulationScheme) {
                case 'BPSK': demodulateFunc = bpskDemodulate; break;
                case 'QPSK': demodulateFunc = qpskDemodulate; break;
                case '16QAM': demodulateFunc = qam16Demodulate; break;
                default: throw new Error('Invalid modulation scheme.');
            }
            for (const symbol of symbols) {
                const bits = demodulateFunc(symbol);
                if (Array.isArray(bits)) {
                    demodulatedBits.push(...bits);
                } else {
                    demodulatedBits.push(bits);
                }
            }
            return demodulatedBits;
        }

        function calculateBer(originalBits, receivedBits) {
            if (!originalBits || !receivedBits) return 1.0;
            
            let errors = 0;
            const minLength = Math.min(originalBits.length, receivedBits.length);
            
            if (minLength === 0) return 1.0;
            
            for (let i = 0; i < minLength; i++) {
                if (originalBits[i] !== receivedBits[i]) {
                    errors++;
                }
            }
            
            return errors / minLength;
        }

        // --- Utility Functions ---
        function formatComplexArrayForDisplay(arr, count = 5) {
            if (!arr || arr.length === 0) return "N/A";
            const sample = arr.slice(0, count).map(c => c.toString()).join(', ');
            return `[${sample}${arr.length > count ? ', ...' : ''}]`;
        }
        function formatBitArrayForDisplay(arr, count = 20) {
            if (!arr || arr.length === 0) return "N/A";
            const sample = arr.slice(0, count).join('');
            return `${sample}${arr.length > count ? '...' : ''}`;
        }
        
        // --- Global Variables & Simulation Logic ---
        let globalTransmittedBits = [];
        let globalModulatedSymbols = [];
        let globalTxWaveformPreChannel = [];
        let globalRxWaveformPostChannel = [];
        let globalRxNoCP = [];
        let globalRxFFTOutput = [];
        let globalReceivedSymbols = [];
        let globalChannelGainsFFT = [];

        // --- BER Plotting Globals for Multi-Curve Support (New) ---
        let berChartDatasets = [];
        const MAX_BER_PLOTS = 6;
        const BER_COLORS = [
            'rgb(59, 130, 246)',    // Blue
            'rgb(239, 68, 68)',     // Red
            'rgb(34, 197, 94)',     // Green
            'rgb(234, 179, 8)',     // Yellow
            'rgb(168, 85, 247)',    // Purple
            'rgb(14, 165, 233)'     // Cyan
        ];

        const fsMHz = 20;
        const fftLengthForSpectrum = 4096;
        const frequencies = Array.from({ length: fftLengthForSpectrum }, (_, i) =>
            (i - fftLengthForSpectrum / 2) * fsMHz / fftLengthForSpectrum
        );

        // Fix 1: Corrected Post-Channel Spectrum Calculation
        // Replace the existing runStepByStepSimulation function's spectrum calculation part:

        async function runStepByStepSimulation() {
            // --- 1. Get Parameters from UI ---
            const nFFTSize = parseInt(document.getElementById('nFFTSize').value);
            const numSubcarriers = parseInt(document.getElementById('numSubcarriers').value);
            const modulationScheme = document.getElementById('modulationScheme').value;
            const cpLength = parseInt(document.getElementById('cpLength').value);
            const snrDb = parseFloat(document.getElementById('snrDb').value);
            const equalizationMethod = document.getElementById('equalization').value;

            // --- 2. Setup UI ---
            document.getElementById('loadingSpinner').style.display = 'block';
            document.getElementById('errorMessage').style.display = 'none';
            document.getElementById('errorMessage').textContent = '';

            const bitsPerSymbol = (modulationScheme === 'BPSK') ? 1 : (modulationScheme === 'QPSK' ? 2 : 4);
            const numBitsPerOFDMSymbol = numSubcarriers * bitsPerSymbol;

            try {
                // --- 3. Transmitter Chain ---
                globalTransmittedBits = generateBits(numBitsPerOFDMSymbol);
                globalModulatedSymbols = modulate(globalTransmittedBits, modulationScheme, bitsPerSymbol);
                let ifftInput = mapToSubcarriers(globalModulatedSymbols, nFFTSize, numSubcarriers);
                let ifftOutput = ifft(ifftInput);
                globalTxWaveformPreChannel = addCyclicPrefix(ifftOutput, cpLength);

                // --- 4. Channel Simulation ---
                const { fadedSignal, channelCoeffs } = applyMultitapChannel(globalTxWaveformPreChannel, 5);
                globalRxWaveformPostChannel = addAwgn(fadedSignal, snrDb, nFFTSize, cpLength, numSubcarriers);

                // --- 5. Receiver Chain ---
                globalRxNoCP = removeCyclicPrefix(globalRxWaveformPostChannel, cpLength, nFFTSize);
                globalRxFFTOutput = fft(globalRxNoCP);
                const channelPadded = [...channelCoeffs];
                while (channelPadded.length < nFFTSize) channelPadded.push(new Complex(0));
                globalChannelGainsFFT = fft(channelPadded);
                globalReceivedSymbols = equalize(globalRxFFTOutput, globalChannelGainsFFT, equalizationMethod, snrDb);

                // --- 6. PLOTTING LOGIC (with error color-coding) ---

                // Update standard charts first
                updateTransmittedConstellationChart(globalModulatedSymbols, modulationScheme);

                const preChannelPadded = [...globalTxWaveformPreChannel, ...Array(fftLengthForSpectrum - globalTxWaveformPreChannel.length).fill(new Complex(0))];
                updateSpectrumChart(preChannelSpectrumChart, frequencies, fftshift(fft(preChannelPadded)).map(c => linearToDb(c.magSq())));

                const postChannelPadded = [...globalRxWaveformPostChannel, ...Array(fftLengthForSpectrum - globalRxWaveformPostChannel.length).fill(new Complex(0))];
                updateSpectrumChart(postChannelSpectrumChart, frequencies, fftshift(fft(postChannelPadded)).map(c => linearToDb(c.magSq())));
                
                const equalizedTimeWaveform = ifft(globalReceivedSymbols);
                const equalizedPadded = [...equalizedTimeWaveform, ...Array(fftLengthForSpectrum - equalizedTimeWaveform.length).fill(new Complex(0))];
                updateSpectrumChart(equalizedSpectrumChart, frequencies, fftshift(fft(equalizedPadded)).map(c => linearToDb(c.magSq())));

                // **NEW**: Sort symbols into correct and incorrect arrays for plotting
                const receivedDataSymbols = extractDataSubcarriers(globalReceivedSymbols, nFFTSize, numSubcarriers);
                const decidedBits = demodulate(receivedDataSymbols, modulationScheme);
                const decidedIdealSymbols = modulate(decidedBits, modulationScheme);
                
                // --- Find this section in runStepByStepSimulation and REPLACE the 'for' loop ---

                const correctlyMappedSymbols = [];
                const incorrectlyMappedSymbols = [];

                // This loop now safely checks for undefined symbols and compares numbers correctly
                for (let i = 0; i < receivedDataSymbols.length; i++) {
                    const originalSymbol = globalModulatedSymbols[i];
                    const receivedSymbol = receivedDataSymbols[i];

                    if (originalSymbol && receivedSymbol) {
                        // Use demodulation to determine if the symbol was decoded correctly
                        const originalBits = demodulateSymbol(originalSymbol, modulationScheme);
                        const receivedBits = demodulateSymbol(receivedSymbol, modulationScheme);
                        
                        // Compare the actual bit sequences
                        const isCorrect = arraysEqual(originalBits, receivedBits);
                        
                        if (isCorrect) {
                            correctlyMappedSymbols.push(receivedSymbol);
                        } else {
                            incorrectlyMappedSymbols.push(receivedSymbol);
                        }
                    } else {
                        incorrectlyMappedSymbols.push(receivedSymbol);
                    }
                }
                
                // Update the Received Constellation chart with the color-coded symbols
                updateReceivedConstellationChart(receivedConstellationChart, correctlyMappedSymbols, incorrectlyMappedSymbols, modulationScheme);

                // --- 7. Final UI updates ---
                currentBlockIndex = 0;
                highlightBlock(currentBlockIndex);
                document.getElementById('nextBlockBtn').disabled = false;
                document.getElementById('prevBlockBtn').disabled = true;

            } catch (error) {
                console.error("Step-by-step simulation error:", error);
                displayError(`Step-by-step simulation failed: ${error.message}. Please check inputs.`);
            } finally {
                document.getElementById('loadingSpinner').style.display = 'none';
            }
        }

        // --- Add this new helper function to your main script ---

        function extractDataSubcarriers(allSymbols, nFFTSize, numSubcarriers) {
            const dataSymbols = [];
            if (!allSymbols || allSymbols.length !== nFFTSize) {
                console.warn(`Invalid FFT output: expected ${nFFTSize} symbols, got ${allSymbols ? allSymbols.length : 0}`);
                return dataSymbols;
            }

            if (nFFTSize === 64 && numSubcarriers === 52) {
                // 802.11a standard subcarrier mapping (matches the mapping function)
                const subcarrierIndices = [
                    -26,-25,-24,-23,-22,-21,-20,-19,-18,-17,-16,-15,-14,-13,-12,-11,
                    -10,-9,-8,-7,-6,-5,-4,-3,-2,-1,
                    1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26
                ];
                
                for (const scIdx of subcarrierIndices) {
                    const arrayIdx = scIdx > 0 ? scIdx : nFFTSize + scIdx;
                    if (arrayIdx >= 0 && arrayIdx < nFFTSize) {
                        dataSymbols.push(allSymbols[arrayIdx]);
                    }
                }
            } else {
                // Generic symmetric extraction
                const halfSubcarriers = Math.floor(numSubcarriers / 2);
                const extraSubcarrier = numSubcarriers % 2;
                
                // Positive frequencies
                for (let i = 1; i <= halfSubcarriers + extraSubcarrier && i < nFFTSize; i++) {
                    dataSymbols.push(allSymbols[i]);
                }
                
                // Negative frequencies
                for (let i = nFFTSize - halfSubcarriers; i < nFFTSize; i++) {
                    dataSymbols.push(allSymbols[i]);
                }
            }
            
            if (dataSymbols.length !== numSubcarriers) {
                console.warn(`Subcarrier extraction mismatch: expected ${numSubcarriers}, extracted ${dataSymbols.length}`);
            }
            
            return dataSymbols;
        }

        // Matrix transpose function
        function transpose(matrix) {
            if (!matrix || matrix.length === 0) return [];
            const rows = matrix.length;
            const cols = matrix[0].length;
            const result = [];
            
            for (let j = 0; j < cols; j++) {
                const newRow = [];
                for (let i = 0; i < rows; i++) {
                    newRow.push(matrix[i][j]);
                }
                result.push(newRow);
            }
            return result;
        }

        // AWGN function matching MATLAB's awgn with 'measured' mode
        function addAwgnMatlab(signal, snrDb) {
            return signal.map(row => {
                // Calculate signal power
                const signalPower = row.reduce((sum, s) => sum + s.magSq(), 0) / row.length;
                if (signalPower === 0) return row;

                // Convert SNR to linear scale
                const snrLinear = dbToLinear(snrDb);
                
                // Calculate noise power
                const noisePower = signalPower / snrLinear;
                const noiseStdDev = Math.sqrt(noisePower / 2);

                return row.map(sample => {
                    const noiseReal = randn() * noiseStdDev;
                    const noiseImag = randn() * noiseStdDev;
                    return sample.add(new Complex(noiseReal, noiseImag));
                });
            });
        }

        // Fix 2 & 3: Optimized BER Simulation with Corrected Logic
        // === Corrected BER Simulation Function ===
        async function runBerSimulation() {
            document.getElementById('loadingSpinnerBER').style.display = 'block';
            document.getElementById('errorMessageBER').style.display = 'none';

            const L = parseInt(document.getElementById('ber_ofdmLength').value);
            const Ncp = parseInt(document.getElementById('ber_cpLength').value);
            const modulationScheme = document.getElementById('ber_modulationScheme').value;
            const SNRincrement = parseFloat(document.getElementById('ber_snrIncrement').value);
            
            const configLabel = `${modulationScheme} (L=${L}, Ncp=${Ncp})`;

            if (berChartDatasets.length >= MAX_BER_PLOTS) {
                displayErrorBER(`Maximum of ${MAX_BER_PLOTS} plots reached. Please clear existing plots before running a new simulation.`);
                document.getElementById('loadingSpinnerBER').style.display = 'none';
                return;
            }

            // Check if this configuration already exists (optional, but good practice)
            if (berChartDatasets.some(d => d.label === configLabel)) {
                displayErrorBER(`Configuration '${configLabel}' already plotted. Clear or change parameters.`);
                document.getElementById('loadingSpinnerBER').style.display = 'none';
                return;
            }


            if (Ncp >= L) {
                displayErrorBER('Cyclic Prefix length must be less than OFDM data length');
                document.getElementById('loadingSpinnerBER').style.display = 'none';
                return;
            }

            const bitsPerSymbol = (modulationScheme === 'BPSK') ? 1 : (modulationScheme === 'QPSK' ? 2 : 4);
            const maxSymbolValue = Math.pow(2, bitsPerSymbol) - 1;
            const numOfdmSymbols = 100;
            const snrRange = [];
            const berResults = [];
            
            const BER_SATURATION_THRESHOLD = 1e-6; // BER threshold for saturation
            const SATURATION_COUNT = 3; // Number of consecutive saturated points needed

            try {
                let consecutiveSaturatedPoints = 0;
                let snr = 0;
                
                console.log(`BER Simulation: L=${L}, Ncp=${Ncp}, Symbols=${numOfdmSymbols}, Modulation=${modulationScheme}`);

                while (consecutiveSaturatedPoints < SATURATION_COUNT) {
                    snrRange.push(snr);
                    let totalErrors = 0;
                    let totalBits = 0;

                    for (let symIdx = 0; symIdx < numOfdmSymbols; symIdx++) {
                        // === TRANSMITTER ===
                        const Tx_data = [];
                        for (let i = 0; i < L; i++) {
                            const row = [];
                            for (let j = 0; j < Ncp; j++) {
                                row.push(Math.floor(Math.random() * (maxSymbolValue + 1)));
                            }
                            Tx_data.push(row);
                        }

                        const mod_data = Tx_data.map(row =>
                            row.map(symbolInt => modulateBER(symbolInt, modulationScheme))
                        );

                        const s2p = transposeBER(mod_data);
                        const ifftOutput = s2p.map(col => ifftBER(col));
                        const p2s = transposeBER(ifftOutput);
                        const txSignal = p2s.map(row => {
                            const cpPart = row.slice(row.length - Ncp);
                            return [...cpPart, ...row];
                        });

                        // === CHANNEL: AWGN ===
                        const snrLinear = Math.pow(10, snr / 10);
                        let signalPower = 0;
                        let sampleCount = 0;
                        for (const row of txSignal) {
                            for (const sample of row) {
                                signalPower += sample.magSq();
                                sampleCount++;
                            }
                        }
                        signalPower /= sampleCount;

                        const noiseVar = signalPower / (2 * snrLinear);
                        const noiseStd = Math.sqrt(noiseVar);

                        const rxSignal = txSignal.map(row =>
                            row.map(sample => {
                                const noiseRe = randnBER() * noiseStd;
                                const noiseIm = randnBER() * noiseStd;
                                return sample.add(new ComplexBER(noiseRe, noiseIm));
                            })
                        );

                        // === RECEIVER ===
                        const rxNoCp = rxSignal.map(row => row.slice(Ncp));
                        const rxS2P = transposeBER(rxNoCp);
                        const fftOutput = rxS2P.map(col => fftBER(col));
                        const rxP2S = transposeBER(fftOutput);

                        const Rx_data = rxP2S.map(row =>
                            row.map(symbol => demodulateBER(symbol, modulationScheme))
                        );

                        // === BER CALCULATION ===
                        for (let i = 0; i < L; i++) {
                            for (let j = 0; j < Ncp; j++) {
                                const txSym = Tx_data[i][j];
                                const rxSym = Rx_data[i][j];
                                let diff = txSym ^ rxSym;
                                while (diff > 0) {
                                    totalErrors += (diff & 1);
                                    diff >>= 1;
                                }
                                totalBits += bitsPerSymbol;
                            }
                        }
                    }

                    const ber = totalBits > 0 ? totalErrors / totalBits : 1.0;
                    const clampedBER = Math.max(ber, 1e-6);
                    berResults.push(clampedBER);

                    console.log(`SNR: ${snr} dB | BER: ${ber.toExponential(2)} | Errors: ${totalErrors}/${totalBits}`);

                    // Check for saturation
                    if (ber <= BER_SATURATION_THRESHOLD) {
                        consecutiveSaturatedPoints++;
                    } else {
                        consecutiveSaturatedPoints = 0;
                    }

                    snr += SNRincrement;
                    
                    // Safety limit to prevent infinite loops
                    if (snr > 50) {
                        console.log('Reached maximum SNR limit of 50 dB');
                        break;
                    }
                }

                // Plot only up to the saturation point
                const plotSnrRange = snrRange.slice(0, -SATURATION_COUNT + 1);
                const plotBerResults = berResults.slice(0, -SATURATION_COUNT + 1);

                // --- NEW PLOTTING LOGIC FOR MULTIPLE CURVES ---
                berChartDatasets.push({
                    label: configLabel,
                    data: plotBerResults.map((ber, index) => ({ x: plotSnrRange[index], y: ber })),
                    color: BER_COLORS[(berChartDatasets.length) % BER_COLORS.length]
                });
                
                updateBerChart(); // Call without arguments
                document.getElementById('berCurveChart').parentElement.style.display = 'block';

            } catch (error) {
                console.error("BER simulation error:", error);
                displayErrorBER(`BER simulation failed: ${error.message}`);
            } finally {
                document.getElementById('loadingSpinnerBER').style.display = 'none';
            }
        }


        // ============================================
        // BER ANALYSIS SECTION - INDEPENDENT FUNCTIONS
        // ============================================

        // Complex number operations for BER section
        class ComplexBER {
            constructor(re, im = 0) {
                this.re = re;
                this.im = im;
            }
            add(other) {
                return new ComplexBER(this.re + other.re, this.im + other.im);
            }
            mul(other) {
                return new ComplexBER(
                    this.re * other.re - this.im * other.im,
                    this.re * other.im + this.im * other.re
                );
            }
            magSq() {
                return this.re * this.re + this.im * this.im;
            }
        }

        // Gaussian random number generator for BER
        function randnBER() {
            let u = 0, v = 0;
            while (u === 0) u = Math.random();
            while (v === 0) v = Math.random();
            return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
        }

        // Matrix transpose for BER
        function transposeBER(matrix) {
            if (!matrix || matrix.length === 0) return [];
            const rows = matrix.length;
            const cols = matrix[0].length;
            const result = [];
            
            for (let j = 0; j < cols; j++) {
                const newRow = [];
                for (let i = 0; i < rows; i++) {
                    newRow.push(matrix[i][j]);
                }
                result.push(newRow);
            }
            return result;
        }

        // FFT implementation for BER
        function fftBER(x) {
            const N = x.length;
            if (N <= 1) return x;
            
            const even = [];
            const odd = [];
            for (let i = 0; i < N / 2; i++) {
                even[i] = x[i * 2];
                odd[i] = x[i * 2 + 1];
            }
            
            const Y_even = fftBER(even);
            const Y_odd = fftBER(odd);
            const Y = new Array(N);
            
            for (let k = 0; k < N / 2; k++) {
                const angle = -2 * Math.PI * k / N;
                const twiddle = new ComplexBER(Math.cos(angle), Math.sin(angle));
                const t = twiddle.mul(Y_odd[k]);
                Y[k] = Y_even[k].add(t);
                Y[k + N / 2] = Y_even[k].add(new ComplexBER(-t.re, -t.im));
            }
            return Y;
        }

        // IFFT implementation for BER
        function ifftBER(X) {
            const N = X.length;
            if (N <= 1) return X;
            
            // Conjugate input
            const X_conj = X.map(c => new ComplexBER(c.re, -c.im));
            
            // Apply FFT
            const y_conj = fftBER(X_conj);
            
            // Conjugate output and scale
            return y_conj.map(c => new ComplexBER(c.re / N, -c.im / N));
        }

        // QAM modulation for BER (supporting BPSK, QPSK, 16QAM)
        function modulateBER(symbolInt, modulationScheme) {
            const bitsPerSymbol = (modulationScheme === 'BPSK') ? 1 : (modulationScheme === 'QPSK' ? 2 : 4);
            
            // Convert integer to bits
            const bits = [];
            let val = symbolInt;
            for (let b = 0; b < bitsPerSymbol; b++) {
                bits.unshift(val % 2);
                val = Math.floor(val / 2);
            }
            
            if (modulationScheme === 'BPSK') {
                return new ComplexBER(2 * bits[0] - 1, 0);
            } else if (modulationScheme === 'QPSK') {
                const scale = 1 / Math.sqrt(2);
                return new ComplexBER((2 * bits[0] - 1) * scale, (2 * bits[1] - 1) * scale);
            } else { // 16QAM
                const qamMap = {
                    0: [-3, -3], 1: [-3, -1], 2: [-3, 3], 3: [-3, 1],
                    4: [-1, -3], 5: [-1, -1], 6: [-1, 3], 7: [-1, 1],
                    8: [3, -3], 9: [3, -1], 10: [3, 3], 11: [3, 1],
                    12: [1, -3], 13: [1, -1], 14: [1, 3], 15: [1, 1]
                };
                const scale = 1 / Math.sqrt(10);
                const [re, im] = qamMap[symbolInt];
                return new ComplexBER(re * scale, im * scale);
            }
        }

        // QAM demodulation for BER
        function demodulateBER(symbol, modulationScheme) {
            if (modulationScheme === 'BPSK') {
                return symbol.re > 0 ? 1 : 0;
            } else if (modulationScheme === 'QPSK') {
                const bit0 = symbol.re > 0 ? 1 : 0;
                const bit1 = symbol.im > 0 ? 1 : 0;
                return bit0 * 2 + bit1;
            } else { // 16QAM
                const qamPoints = [
                    [-3, -3], [-3, -1], [-3, 3], [-3, 1],
                    [-1, -3], [-1, -1], [-1, 3], [-1, 1],
                    [3, -3], [3, -1], [3, 3], [3, 1],
                    [1, -3], [1, -1], [1, 3], [1, 1]
                ];
                const scale = 1 / Math.sqrt(10);
                
                let minDist = Infinity;
                let symbolInt = 0;
                
                for (let i = 0; i < 16; i++) {
                    const [re, im] = qamPoints[i];
                    const dist = Math.pow(symbol.re - re * scale, 2) + Math.pow(symbol.im - im * scale, 2);
                    if (dist < minDist) {
                        minDist = dist;
                        symbolInt = i;
                    }
                }
                return symbolInt;
            }
        }

        function displayErrorBER(message) {
            const errorMessageDiv = document.getElementById('errorMessageBER');
            errorMessageDiv.textContent = message;
            errorMessageDiv.style.display = 'block';
            document.getElementById('loadingSpinnerBER').style.display = 'none';
        }
        
        // Find and modify these arrays
        const allOfdmBlockIds = ['block-tx', 'block-idft', 'block-addcp', 'block-channel', 'block-removecp', 'block-fft', 'block-equalizer', 'block-rx'];
        const blockOutputTitles = [
            'S/P & Mapping Output',
            'IDFT Output',
            'Add CP Output',
            'Channel Output',
            'Remove CP Output',
            'FFT Output',
            'Equalizer Output', // New title
            'Demapping & P/S Output'
        ];
        let currentBlockIndex = 0;

        function demodulateSymbol(symbol, modulationScheme) {
            switch (modulationScheme) {
                case 'BPSK': return [bpskDemodulate(symbol)];
                case 'QPSK': return qpskDemodulate(symbol);
                case '16QAM': return qam16Demodulate(symbol);
                default: return [];
            }
        }

        function arraysEqual(arr1, arr2) {
            if (!arr1 || !arr2 || arr1.length !== arr2.length) return false;
            for (let i = 0; i < arr1.length; i++) {
                if (arr1[i] !== arr2[i]) return false;
            }
            return true;
        }

        // Also update the highlightBlock function where it highlights arrows:
        function highlightBlock(index) {
            const nextBtn = document.getElementById('nextBlockBtn');
            const prevBtn = document.getElementById('prevBlockBtn');
            
            // Enable/disable buttons based on index
            nextBtn.disabled = (index >= allOfdmBlockIds.length - 1);
            prevBtn.disabled = (index <= 0);

            // Remove all highlights
            allOfdmBlockIds.forEach(id => {
                const block = document.getElementById(id);
                if (block) {
                    block.classList.remove('highlighted');
                    const texts = block.querySelectorAll('.ofdm-block-text');
                    texts.forEach(t => t.classList.remove('highlighted'));
                }
            });
            
            document.querySelectorAll('.arrow').forEach(arrow => arrow.classList.remove('highlighted'));

            // Add highlight to current block
            if (index >= 0 && index < allOfdmBlockIds.length) {
                const currentBlockElement = document.getElementById(allOfdmBlockIds[index]);
                if (currentBlockElement) {
                    currentBlockElement.classList.add('highlighted');
                    currentBlockElement.querySelectorAll('.ofdm-block-text').forEach(t => t.classList.add('highlighted'));
                }
                
                // Highlight the arrow leading to this block
                if (index > 0) {
                    const prevArrowIds = getArrowId(index - 1, index);
                    prevArrowIds.forEach(arrowId => {
                        const arrowElement = document.getElementById(arrowId);
                        if (arrowElement) arrowElement.classList.add('highlighted');
                    });
                }
            }

            updateChartVisibility(index);
            updateBlockOutputDisplayContent(index);
        }
        
        // Replace your getArrowId function with this improved version that handles multiple arrows:
        function getArrowId(fromIndex, toIndex) {
            const transitions = {
                '0-1': ['mapping-to-idft'],
                '1-2': ['idft-to-addcp'],
                '2-3': ['addcp-to-channel'],
                '3-4': ['channel-to-awgn', 'awgn-to-removecp'],
                '4-5': ['removecp-to-fft'],
                '5-6': ['fft-to-equalizer'],
                '6-7': ['equalizer-to-demapping']
            };
            return transitions[`${fromIndex}-${toIndex}`] || [];
        }

        function hideStepByStepCharts() {
            const stepByStepCharts = [
                'constellationChart', 'preChannelSpectrumChart', 
                'postChannelSpectrumChart', 'receivedConstellationChart'
            ];
            
            stepByStepCharts.forEach(chartId => {
                document.getElementById(chartId).parentElement.style.display = 'none';
            });
        }

        function showOutputChart(chartId) {
            hideOutputCharts();
            document.getElementById(chartId).parentElement.style.display = 'block';
        }

        function hideOutputCharts() {
            document.getElementById('receivedConstellationChart').parentElement.style.display = 'none';
            document.getElementById('berCurveChart').parentElement.style.display = 'none';
        }

        function updateChartVisibility(blockIndex) {
            // Hide all charts first
            const allChartContainers = [
                'constellationChart', 'preChannelSpectrumChart', 
                'postChannelSpectrumChart', 'receivedConstellationChart',
                'equalizedSpectrumChart' // <-- FIX: Added the new chart here
            ];
            
            allChartContainers.forEach(chartId => {
                const chartEl = document.getElementById(chartId);
                if(chartEl) chartEl.parentElement.style.display = 'none';
            });
            
            // Show the relevant chart for the current block
            switch (allOfdmBlockIds[blockIndex]) {
                case 'block-tx':
                    document.getElementById('constellationChart').parentElement.style.display = 'block';
                    break;
                case 'block-addcp':
                    document.getElementById('preChannelSpectrumChart').parentElement.style.display = 'block';
                    break;
                case 'block-channel':
                    document.getElementById('postChannelSpectrumChart').parentElement.style.display = 'block';
                    break;
                case 'block-equalizer':
                    document.getElementById('equalizedSpectrumChart').parentElement.style.display = 'block';
                    break;
                case 'block-rx':
                    document.getElementById('receivedConstellationChart').parentElement.style.display = 'block';
                    break;
            }
        }

        function showChart(chartId) {
            document.getElementById(chartId).parentElement.style.display = 'block';
        }

        /**
         * Updates the step-by-step info panel with a text description and styled symbol boxes.
         */
        function updateBlockOutputDisplayContent(blockIndex) {
            const titleDiv = document.getElementById('blockOutputTitle');
            const descriptionDiv = document.getElementById('blockOutputDisplay');
            titleDiv.textContent = blockOutputTitles[blockIndex];

            const nFFTSize = parseInt(document.getElementById('nFFTSize').value);
            const cpLength = parseInt(document.getElementById('cpLength').value);
            
            let description = "Run a simulation to see the step-by-step output here.";
            let showSymbols = false;
            let symbolData = [];

            switch (allOfdmBlockIds[blockIndex]) {
                case 'block-tx':
                    if (globalTransmittedBits.length) {
                        description = `Generated Bits: ${formatBitArrayForDisplay(globalTransmittedBits)}\n`
                                    + `Modulated to ${globalModulatedSymbols.length} ${document.getElementById('modulationScheme').value} symbols.`;
                        showSymbols = true;
                        symbolData = formatSymbolDisplay(
                            globalModulatedSymbols.map((s, i) => ({
                                value: s,
                                label: `X[${i}]`, // Capital X for frequency-domain
                                type: 'data'
                            }))
                        );
                    }
                    break;

                case 'block-idft':
                    if (globalTxWaveformPreChannel.length) {
                        description = `Converted frequency-domain symbols to a time-domain signal of ${nFFTSize} samples.`;
                        showSymbols = true;
                        symbolData = formatSymbolDisplay(
                            globalTxWaveformPreChannel.slice(cpLength).map((s, i) => ({
                                value: s,
                                label: `x[${i}]`, // Lowercase x for time-domain
                                type: 'data'
                            }))
                        );
                    }
                    break;

                case 'block-addcp':
                    if (globalTxWaveformPreChannel.length) {
                        description = `Prepended ${cpLength} samples from the end to the beginning. Total signal length is now ${nFFTSize + cpLength}.`;
                        showSymbols = true;
                        symbolData = formatCPSymbolDisplay(globalTxWaveformPreChannel, nFFTSize, cpLength);
                    }
                    break;

                case 'block-channel':
                    if (globalRxWaveformPostChannel.length) {
                        description = `Signal passed through a simulated channel with fading and noise.`;
                        showSymbols = true;
                        symbolData = formatSymbolDisplay(
                            globalRxWaveformPostChannel.map((s, i) => ({
                                value: s,
                                label: `y[${i}]`,
                                type: 'data'
                            }))
                        );
                    }
                    break;

                case 'block-removecp':
                    if (globalRxNoCP.length) {
                        description = `Removed the ${cpLength}-sample cyclic prefix. Remaining signal length is ${globalRxNoCP.length}.`;
                        showSymbols = true;
                        symbolData = formatSymbolDisplay(
                            globalRxNoCP.map((s, i) => ({
                                value: s,
                                label: `r[${i}]`,
                                type: 'data'
                            }))
                        );
                    }
                    break;

                case 'block-fft':
                    if (globalRxFFTOutput.length) {
                        description = `Converted the time-domain signal back to the frequency domain to recover symbols on each subcarrier.`;
                        showSymbols = true;
                        symbolData = formatSymbolDisplay(
                            globalRxFFTOutput.map((s, i) => ({
                                value: s,
                                label: `R[${i}]`,
                                type: 'data'
                            }))
                        );
                    }
                    break;

                // Add this new case for the equalizer
                case 'block-equalizer':
                    if (globalReceivedSymbols.length) {
                        const method = document.getElementById('equalization').value;
                        const nFFTSize = parseInt(document.getElementById('nFFTSize').value);
                        const numSubcarriers = parseInt(document.getElementById('numSubcarriers').value);
                        
                        // Extract only data symbols for display
                        const dataSymbols = extractDataSubcarriers(globalReceivedSymbols, nFFTSize, numSubcarriers);
                        
                        description = `Applied ${method} equalization to compensate for channel distortion and noise. Extracted ${dataSymbols.length} data symbols.`;
                        showSymbols = true;
                        symbolData = formatSymbolDisplay(
                            dataSymbols.map((s, i) => ({
                                value: s,
                                label: `X[${i}]`,
                                type: 'data'
                            }))
                        );
                    }
                    break;

                case 'block-rx':
                    if (globalReceivedSymbols.length) {
                        const nFFTSize = parseInt(document.getElementById('nFFTSize').value);
                        const numSubcarriers = parseInt(document.getElementById('numSubcarriers').value);
                        const modulationScheme = document.getElementById('modulationScheme').value;
                        const bitsPerSymbol = (modulationScheme === 'BPSK') ? 1 : (modulationScheme === 'QPSK' ? 2 : 4);

                        // Extract only the data symbols from the correct subcarrier positions
                        const receivedDataSymbols = extractDataSubcarriers(globalReceivedSymbols, nFFTSize, numSubcarriers);
                        
                        // Demodulate the extracted data symbols
                        const receivedBits = demodulate(receivedDataSymbols, modulationScheme);

                        // Calculate BER correctly
                        const ber = calculateBer(globalTransmittedBits, receivedBits);
                        
                        description = `Demapped symbols into a bitstream.\nFinal Bit Error Rate (BER): ${ber.toExponential(2)}`;
                        showSymbols = true;
                        
<<<<<<< HEAD
                        // Display bit-to-symbol mapping with EXPLICIT CURLEY BRACKETS AND SYMBOL LABEL
                        const maxSymbolsToShow = 8; // Show first 8 symbols
                        const displayBitCount = Math.min(maxSymbolsToShow * bitsPerSymbol, receivedBits.length);
=======
                        // Display symbol-wise demapping (groups of bits per symbol)
                        const numSymbolsToDisplay = Math.min(10, globalModulatedSymbols.length); // Show first 10 symbols
>>>>>>> 8b8df1809f269821c8436aadd2b3dfd289e76b35
                        symbolData = [];
                        
                        for (let i = 0; i < numSymbolsToDisplay; i++) {
                            const startBitIdx = i * bitsPerSymbol;
                            const endBitIdx = startBitIdx + bitsPerSymbol;
                            
                            // Get transmitted bits for this symbol
                            const txBits = globalTransmittedBits.slice(startBitIdx, endBitIdx);
                            // Get received bits for this symbol
                            const rxBits = receivedBits.slice(startBitIdx, endBitIdx);
                            
<<<<<<< HEAD
                            // 1. Generate the Constellation Symbol Label
                            let symbolLabel;
                            if (modulationScheme === 'BPSK') {
                                symbolLabel = bitGroup[0] === 1 ? '+1' : '-1';
                            } else if (modulationScheme === 'QPSK') {
                                const qpskMap = { 
                                    '00': 'A', 
                                    '01': 'A', 
                                    '10': 'A', 
                                    '11': 'A' 
                                };
                                symbolLabel = qpskMap[bitGroup.join('')] || '?';
                            } else { // 16-QAM
                                const bitString = bitGroup.join('');
                                const decimalValue = parseInt(bitString, 2);
                                symbolLabel = `S${decimalValue}`;
                            }

                            // 2. Format the grouped bits with curly brackets for the 'label' property
                            const groupedBitsLabel = `{${bitGroup.join('')}}`;
                            
                            // 3. Create the data object using the standard symbol-item style
                            symbolData.push({
                                // Use the symbol label as the main display content
                                label: symbolLabel, 
                                // Store the grouped bits in the value field for hover tooltip
                                value: `Bits: ${bitGroup.join('')}`, 
                                type: hasError ? 'cp' : 'data' // cp = error (red), data = correct (blue)
                            });

                            // 4. Add the curly bracket and bit representation
                            symbolData.push({
                                label: groupedBitsLabel, 
                                type: 'ellipsis', // Use ellipsis style (grey dashed border) for the bracketed text
                                value: `Demapped to ${symbolLabel}`
                            });

                            // Add separator between symbol groups (except after last)
                            if (i + bitsPerSymbol < displayBitCount) {
                                symbolData.push({ label: '|', type: 'separator' });
                            }
=======
                            // Check if all bits in the symbol match
                            const isSymbolCorrect = txBits.every((bit, idx) => bit === rxBits[idx]);
                            
                            // Format bit strings
                            const txBitString = txBits.join('');
                            const rxBitString = rxBits.map(b => b !== undefined ? b : '?').join('');
                            
                            symbolData.push({
                                value: `Symbol ${i}: Tx[${txBitString}]  Rx[${rxBitString}]`,
                                label: `${txBitString}${rxBitString}`,
                                type: isSymbolCorrect ? 'data' : 'cp' // 'data' for correct (green), 'cp' for error (red)
                            });
>>>>>>> 8b8df1809f269821c8436aadd2b3dfd289e76b35
                        }
                        
                        // Add ellipsis if there are more symbols
                        if (globalModulatedSymbols.length > numSymbolsToDisplay) {
                            symbolData.push({ label: '...', type: 'ellipsis' });
                            symbolData.push({
                                value: `Total: ${globalModulatedSymbols.length} symbols`,
                                label: `(${globalModulatedSymbols.length} total)`,
                                type: 'ellipsis'
                            });
                        }
                    }
                    break;
            }

            descriptionDiv.textContent = description;
            updateSymbolDisplay(showSymbols, symbolData);
        }

        function clearAllChartData() {
            const charts = [constellationChart, preChannelSpectrumChart, postChannelSpectrumChart, receivedConstellationChart, equalizedSpectrumChart, berCurveChart];
            charts.forEach(chart => {
                if (chart) {
                    chart.data.labels = [];
                    chart.data.datasets.forEach(dataset => { dataset.data = []; });
                    chart.update();
                }
            });
        }

        function resetSimulation() {
            clearAllChartData();
            hideStepByStepCharts();
            hideOutputCharts();

            currentBlockIndex = 0;
            highlightBlock(currentBlockIndex);
            
            document.getElementById('errorMessage').style.display = 'none';
            document.getElementById('loadingSpinner').style.display = 'none';
            document.getElementById('blockOutputTitle').textContent = "Simulation Step Output";
            document.getElementById('blockOutputDisplay').innerHTML = "Run a simulation to see the step-by-step output here.";

            document.getElementById('nFFTSize').value = 64;
            document.getElementById('numSubcarriers').value = 52;
            document.getElementById('modulationScheme').value = 'BPSK';
            document.getElementById('cpLength').value = 16;
            document.getElementById('snrDb').value = 20;
            document.getElementById('numSymbolsBer').value = 1000;
        }
        
        function getIdealConstellationPoints(modulationScheme) {
            switch (modulationScheme) {
                case 'BPSK':
                    return [new Complex(-1), new Complex(1)];
                case 'QPSK':
                    const qpskScale = 1 / Math.sqrt(2);
                    return [
                        new Complex(qpskScale, qpskScale), new Complex(qpskScale, -qpskScale),
                        new Complex(-qpskScale, qpskScale), new Complex(-qpskScale, -qpskScale)
                    ];
                case '16QAM':
                    const qam16Scale = 1 / Math.sqrt(10);
                    const levels = [-3, -1, 1, 3];
                    const points = [];
                    for (const re of levels) {
                        for (const im of levels) {
                            points.push(new Complex(re * qam16Scale, im * qam16Scale));
                        }
                    }
                    return points;
                default:
                    return [];
            }
        }

        let constellationChart, preChannelSpectrumChart, postChannelSpectrumChart, equalizedSpectrumChart, receivedConstellationChart, berCurveChart;

        // Updated initializeCharts function for better responsiveness
        function initializeCharts() {
            // Set canvas dimensions based on container size
            const setCanvasDimensions = (id) => {
                const canvas = document.getElementById(id);
                if (canvas) {
                    const container = canvas.parentElement;
                    const containerWidth = container.offsetWidth;
                    canvas.style.width = '100%';
                    canvas.style.height = '350px';
                    canvas.width = Math.min(containerWidth, 800);
                    canvas.height = 350;
                }
            };

        const canvases = ['constellationChart', 'preChannelSpectrumChart', 'postChannelSpectrumChart', 'receivedConstellationChart', 'equalizedSpectrumChart', 'berCurveChart'];
            canvases.forEach(setCanvasDimensions);

            // --- Find the initializeCharts function and REPLACE the constellationConfig object with this CORRECTED version ---

        const constellationConfig = {
            type: 'scatter',
            data: { datasets: [{ label: 'Constellation Diagram', data: [], backgroundColor: 'rgb(34, 197, 94)', pointRadius: 5, pointHoverRadius: 7 }] },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: { display: false },
                    legend: { display: false },
                    tooltip: { callbacks: { label: c => `(${c.parsed.x.toFixed(2)}, ${c.parsed.y.toFixed(2)}i)` } }
                },
                scales: {
                    x: {
                        type: 'linear',
                        position: 'bottom',
                        min: -2,
                        max: 2,
                        title: { display: true, text: 'In-phase (Real)', font: { size: 12, weight: 'bold' }, color: '#4b5563' },
                        grid: {
                            // --- AXIS HIGHLIGHT (Chart.js v3+) ---
                            color: context => (context.tick.value === 0 ? '#6b7280' : '#e5e7eb'),
                            lineWidth: context => (context.tick.value === 0 ? 2 : 1)
                        },
                        ticks: { color: '#6b7280', font: { size: 10 } }
                    },
                    y: {
                        type: 'linear',
                        position: 'left',
                        min: -2,
                        max: 2,
                        title: { display: true, text: 'Quadrature (Imaginary)', font: { size: 12, weight: 'bold' }, color: '#4b5563' },
                        grid: {
                            // --- AXIS HIGHLIGHT (Chart.js v3+) ---
                            color: context => (context.tick.value === 0 ? '#6b7280' : '#e5e7eb'),
                            lineWidth: context => (context.tick.value === 0 ? 2 : 1)
                        },
                        ticks: { color: '#6b7280', font: { size: 10 } }
                    }
                }
            }
        };

            const spectrumConfig = {
                type: 'line',
                data: { datasets: [{ data: [], borderWidth: 2, pointRadius: 0, fill: false, tension: 0.1 }] },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        x: { 
                            title: { display: true, text: 'Frequency (MHz)', font: { size: 12, weight: 'bold' }, color: '#4b5563' }, 
                            grid: { color: '#e2e8f0' },
                            ticks: { font: { size: 10 } }
                        },
                        y: { 
                            title: { display: true, text: 'PSD (dB)', font: { size: 12, weight: 'bold' }, color: '#4b5563' }, 
                            grid: { color: '#e2e8f0' },
                            ticks: { font: { size: 10 } }
                        }
                    }
                }
            };

            // Also, in initializeCharts(), replace the berConfig with this:
            const berConfig = {
                type: 'scatter', // Changed from 'line' to 'scatter' to support {x,y} data format
                data: { datasets: [] },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { 
                        legend: { 
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `${context.dataset.label}: SNR=${context.parsed.x}dB, BER=${context.parsed.y.toExponential(2)}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: { 
                            type: 'linear', // Explicitly set to linear
                            min: 0, 
                            max: 25,
                            title: { display: true, text: 'SNR (dB)', font: { size: 12, weight: 'bold' }, color: '#4b5563' },
                            ticks: { font: { size: 10 } }
                        },
                        y: { 
                            type: 'logarithmic',
                            title: { display: true, text: 'BER', font: { size: 12, weight: 'bold' }, color: '#4b5563' }, 
                            min: 1e-6, 
                            max: 1,
                            ticks: { 
                                callback: v => {
                                    const exp = Math.log10(v);
                                    if (Number.isInteger(exp) && exp >= -6 && exp <= 0) {
                                        return v.toExponential(0);
                                    }
                                    return null;
                                },
                                font: { size: 10 }
                            }
                        }
                    }
                }
            };

            constellationChart = new Chart(document.getElementById('constellationChart').getContext('2d'), constellationConfig);
            preChannelSpectrumChart = new Chart(document.getElementById('preChannelSpectrumChart').getContext('2d'), { ...spectrumConfig, data: { datasets: [{ ...spectrumConfig.data.datasets[0], borderColor: 'rgb(59, 130, 246)', backgroundColor: 'rgba(59, 130, 246, 0.2)' }] } });
            postChannelSpectrumChart = new Chart(document.getElementById('postChannelSpectrumChart').getContext('2d'), { ...spectrumConfig, data: { datasets: [{ ...spectrumConfig.data.datasets[0], borderColor: 'rgb(234, 88, 12)', backgroundColor: 'rgba(234, 88, 12, 0.2)' }] } });
            equalizedSpectrumChart = new Chart(document.getElementById('equalizedSpectrumChart').getContext('2d'), { ...spectrumConfig, data: { datasets: [{ ...spectrumConfig.data.datasets[0], borderColor: 'rgb(132, 204, 22)', backgroundColor: 'rgba(132, 204, 22, 0.2)' }] } });
            receivedConstellationChart = new Chart(document.getElementById('receivedConstellationChart').getContext('2d'), { ...constellationConfig, data: { datasets: [{ ...constellationConfig.data.datasets[0], label: 'Received Constellation', backgroundColor: 'rgb(34, 197, 94)' }] } });
            berCurveChart = new Chart(document.getElementById('berCurveChart').getContext('2d'), berConfig);

            // Add window resize handler
            window.addEventListener('resize', () => {
                setTimeout(() => {
                    canvases.forEach(setCanvasDimensions);
                    [constellationChart, preChannelSpectrumChart, postChannelSpectrumChart, receivedConstellationChart, berCurveChart].forEach(chart => {
                        if (chart) chart.resize();
                    });
                }, 100);
            });
        }

        /**
         * Renders the symbol boxes in the dedicated symbol display area.
         */
        function updateSymbolDisplay(show, symbolData) {
            const symbolDisplay = document.getElementById('symbolDisplay');
            if (!symbolDisplay) return;

            if (show && symbolData && symbolData.length > 0) {
                symbolDisplay.innerHTML = '';
                symbolDisplay.style.display = 'flex';

                symbolData.forEach(symbol => {
                    if (symbol.type === 'separator') {
                        const separator = document.createElement('div');
                        separator.className = 'symbol-separator';
                        separator.textContent = symbol.label;
                        symbolDisplay.appendChild(separator);
                    } else if (symbol.symbolLabel) {
                        // Special rendering for bit-to-symbol mapping with grouped bits and label
                        const container = document.createElement('div');
                        container.className = 'symbol-item with-bracket';
                        
                        // 1. Bits in colored box (Top)
                        const bitsBox = document.createElement('div');
                        bitsBox.className = `symbol-bits-box ${symbol.type}`;
                        bitsBox.textContent = symbol.label; // e.g., "0 1"
                        bitsBox.style.padding = '0 5px'; // Adjust padding
                        bitsBox.style.letterSpacing = '1px'; // Reduce letter spacing for clarity
                        
                        // 2. Bracket and label container (Bottom)
                        const labelContainer = document.createElement('div');
                        labelContainer.className = 'symbol-bracket-container';
                        labelContainer.style.minHeight = '30px'; // Ensure space
                        labelContainer.style.marginTop = '4px'; // Space below bits box

                        // Instead of a special character , we use text styling
                        const symbolDiv = document.createElement('div');
                        symbolDiv.className = 'symbol-label';
                        symbolDiv.style.fontWeight = 'bold';
                        symbolDiv.style.borderTop = '1px solid #64748b'; // Horizontal line
                        symbolDiv.style.lineHeight = '1.2';
                        symbolDiv.style.marginTop = '2px';
                        symbolDiv.style.color = '#475569';
                        symbolDiv.textContent = ` <${symbol.symbolLabel}> `; // Use angular brackets

                        labelContainer.appendChild(symbolDiv);
                        
                        container.appendChild(bitsBox);
                        container.appendChild(labelContainer);
                        symbolDisplay.appendChild(container);
                    } else {
                        const item = document.createElement('div');
                        item.className = `symbol-item ${symbol.type}`;
                        item.textContent = symbol.label;
                        
                        if (symbol.value) {
                            item.title = `${symbol.label}: ${symbol.value.toString()}`;
                        }
                        symbolDisplay.appendChild(item);
                    }
                });
            } else {
                symbolDisplay.style.display = 'none';
            }
        }

        /**
         * Formats a long array of symbols to show the first few, an ellipsis, and the last one.
         */
        function formatSymbolDisplay(symbols) {
            if (symbols.length <= 12) {
                return symbols;
            }
            // Show first 5, ellipsis, and last 2
            return [
                ...symbols.slice(0, 5),
                { label: '...', type: 'ellipsis' },
                ...symbols.slice(symbols.length - 2)
            ];
        }

        /**
         * Specifically formats the signal with a styled cyclic prefix.
         */
        function formatCPSymbolDisplay(cpAddedSignal, M, L) {
            const result = [];
            const cpData = cpAddedSignal.slice(0, L).map((s, i) => ({
                label: `x[${M - L + i}]`,
                type: 'cp',
                value: s
            }));
            
            const dataPart = cpAddedSignal.slice(L).map((s, i) => ({
                label: `x[${i}]`,
                type: 'data',
                value: s
            }));

            if (L > 4) {
                result.push(cpData[0], { label: '...', type: 'ellipsis' }, cpData[L - 1]);
            } else {
                result.push(...cpData);
            }

            result.push({ label: '|', type: 'separator' });

            if (M > 8) {
                result.push(...dataPart.slice(0, 3), { label: '...', type: 'ellipsis' }, ...dataPart.slice(M - 2));
            } else {
                result.push(...dataPart);
            }
            return result;
        }

        function updateSpectrumChart(chartInstance, labels, data) {
            if (chartInstance) {
                const validLabels = [];
                const validData = [];
                
                for (let i = 0; i < data.length; i++) {
                    const value = data[i];
                    if (isFinite(value) && !isNaN(value) && value > -200 && value < 100) {
                        validLabels.push(parseFloat(labels[i]).toFixed(2));
                        validData.push(value);
                    }
                }
                
                chartInstance.data.labels = validLabels;
                chartInstance.data.datasets[0].data = validData;
                chartInstance.update();
            }
        }
        
        function updateConstellationChart(chart, symbols, modulationScheme) {
    if (!chart) return;

    let maxMag = 0;
    const idealPoints = getIdealConstellationPoints(modulationScheme);
    if (idealPoints.length > 0) {
        maxMag = Math.max(...idealPoints.map(p => Math.max(Math.abs(p.re), Math.abs(p.im))));
    }
    
    // Set a minimum axis range and ensure it's finite
    let axisMax = Math.max(maxMag * 1.5, 2.0); // Minimum range of 2.0
    
    // Safety check to prevent infinite or NaN values
    if (!isFinite(axisMax) || axisMax <= 0) {
        axisMax = 2.0; // Default fallback value
    }
    
    // Cap the maximum range to prevent overly large plots
    axisMax = Math.min(axisMax, 10.0); // Maximum range of 10.0

    const validData = symbols.filter(s => 
        isFinite(s.re) && isFinite(s.im) &&
        Math.abs(s.re) <= 20 && Math.abs(s.im) <= 20 // Filter out extreme values
    ).map(s => ({ x: s.re, y: s.im }));

    chart.options.scales.x.min = -axisMax;
    chart.options.scales.x.max = axisMax;
    chart.options.scales.y.min = -axisMax;
    chart.options.scales.y.max = axisMax;

    chart.data.datasets[0].data = validData;
    chart.update();
}
        
        function updateTransmittedConstellationChart(symbols, modulationScheme) {
            updateConstellationChart(constellationChart, symbols, modulationScheme);
        }

        // --- REPLACE the old updateReceivedConstellationChart function with this ---

        // --- REPLACE your existing updateReceivedConstellationChart function with this ---

        function updateReceivedConstellationChart(chart, correctSymbols, incorrectSymbols, modulationScheme) {
            if (!chart) return;

            const idealPoints = getIdealConstellationPoints(modulationScheme);
            const maxMag = Math.max(...idealPoints.map(p => Math.max(Math.abs(p.re), Math.abs(p.im))));
            const axisMax = Math.min(Math.max(maxMag * 1.5, 1.5), 10.0);

            chart.options.scales.x.min = -axisMax;
            chart.options.scales.x.max = axisMax;
            chart.options.scales.y.min = -axisMax;
            chart.options.scales.y.max = axisMax;
            chart.options.plugins.legend.display = true;

            chart.data.datasets = [
                {
                    label: 'Ideal Points',
                    data: idealPoints.map(s => ({ x: s.re, y: s.im })),
                    backgroundColor: 'rgba(0, 0, 0, 0.5)',
                    pointStyle: 'crossRot',
                    radius: 8,
                    order: 1 // Render in the back
                },
                {
                    label: 'Correctly Demapped',
                    data: correctSymbols.map(s => ({ x: s.re, y: s.im })),
                    backgroundColor: 'rgb(34, 197, 94)', // Green
                    pointRadius: 5,
                    pointHoverRadius: 7,
                    order: 2
                },
                {
                    label: 'Incorrectly Demapped',
                    data: incorrectSymbols.map(s => ({ x: s.re, y: s.im })),
                    backgroundColor: 'rgb(239, 68, 68)', // Red
                    pointRadius: 5,
                    pointHoverRadius: 7,
                    order: 3
                }
            ];

            chart.update();
        }

        // Replace the updateBerChart function with this corrected version:
        function updateBerChart() {
            if (!berCurveChart) return;

            // Clear existing labels (not needed for scatter plot mode)
            berCurveChart.data.labels = [];

            // Convert global array into Chart.js datasets
            berCurveChart.data.datasets = berChartDatasets.map((config, index) => ({
                label: config.label,
                data: config.data, // Already in {x, y} format
                borderColor: config.color,
                backgroundColor: config.color.replace('rgb', 'rgba').replace(')', ', 0.2)'),
                borderWidth: 2,
                pointRadius: 3,
                pointBackgroundColor: config.color,
                fill: false,
                tension: 0.1,
                showLine: true
            }));

            // Determine max SNR for X-axis scaling
            let maxSNR = 25; // Default max
            if (berChartDatasets.length > 0) {
                maxSNR = Math.max(...berChartDatasets.flatMap(d => d.data.map(p => p.x)));
            }
            
            // Update Chart options
            berCurveChart.options.scales.x.min = 0;
            berCurveChart.options.scales.x.max = maxSNR > 0 ? Math.ceil(maxSNR) + 2 : 25;
            berCurveChart.options.plugins.legend.display = berChartDatasets.length > 1; // Show legend if multiple plots
            
            berCurveChart.update();
        }

        function displayError(message) {
            const errorMessageDiv = document.getElementById('errorMessage');
            errorMessageDiv.textContent = message;
            errorMessageDiv.style.display = 'block';
            document.getElementById('loadingSpinner').style.display = 'none';
        }

        // Replace your window.onload section with this version that includes debugging:
        window.onload = function() {
            initializeCharts();
            document.getElementById('runStepByStepBtn').addEventListener('click', runStepByStepSimulation);
            document.getElementById('runBerSimBtn').addEventListener('click', runBerSimulation);
            
            // Debug: Log when Next button is clicked
            document.getElementById('nextBlockBtn').addEventListener('click', () => {
                console.log('Next button clicked! Current index:', currentBlockIndex, 'Max index:', allOfdmBlockIds.length - 1);
                if (currentBlockIndex < allOfdmBlockIds.length - 1) {
                    currentBlockIndex++;
                    console.log('Moving to index:', currentBlockIndex);
                    highlightBlock(currentBlockIndex);
                } else {
                    console.log('Already at last block');
                }
            });
            
            document.getElementById('prevBlockBtn').addEventListener('click', () => {
                console.log('Previous button clicked! Current index:', currentBlockIndex);
                if (currentBlockIndex > 0) {
                    currentBlockIndex--;
                    console.log('Moving to index:', currentBlockIndex);
                    highlightBlock(currentBlockIndex);
                } else {
                    console.log('Already at first block');
                }
            });
            
            // Show the simulation tab by default
            document.getElementById('simulationTab').style.display = 'block';
            resetSimulation();
        };
    </script>
</body>
</html>