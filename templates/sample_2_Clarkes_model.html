<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wireless Channel Modeling Virtual Lab</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f0f2f5;
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: #333;
        }

        .header h1 {
            font-size: 3rem;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .tabs {
            display: flex;
            justify-content: center;
            margin-bottom: 30px;
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
        }

        .tab-button {
            padding: 15px 40px;
            background: #f8f9fa;
            border: none;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            color: #6c757d;
        }

        .tab-button.active {
            background: #667eea;
            color: white;
        }

        .tab-button:hover:not(.active) {
            background: #e9ecef;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .lab-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .controls-panel, .environment-panel, .chart-panel {
            background: #fff;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            height: fit-content;
        }

        .input-group-container {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .input-group-container .control-group {
            flex: 1;
            min-width: 200px;
            margin-bottom: 0;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            color: #4a5568;
        }

        .control-group input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 16px;
            transition: all 0.3s ease;
        }
        
        .control-group input::-webkit-outer-spin-button,
        .control-group input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        
        .control-group input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .help-text {
            font-size: 12px;
            color: #718096;
            margin-top: 5px;
        }

        .environment-canvas {
            width: 100%;
            height: 400px;
            border-radius: 10px;
            background: #f8fafc;
        }

        .chart-container {
            position: relative;
            height: 300px;
            width: 100%;
        }

        h2 {
            font-size: 1.5rem;
            margin-bottom: 20px;
            color: #2d3748;
        }

        h3 {
            font-size: 1.2rem;
            margin-bottom: 15px;
            color: #4a5568;
        }

        .charts-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        .chart-panel-wrapper {
            display: none;
        }
        
        .info-box {
            background: #f0f4ff;
            border-left: 4px solid #667eea;
            padding: 15px;
            margin-top: 20px;
            border-radius: 5px;
        }

        .info-box h4 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .simulate-button {
            width: 100%;
            padding: 15px;
            border: none;
            border-radius: 8px;
            background-color: #667eea;
            color: white;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .simulate-button:hover {
            background-color: #5a6ac2;
        }

        .checkbox-group {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .checkbox-group label {
            font-weight: 600;
            color: #4a5568;
        }
        .checkbox-group input[type="checkbox"] {
            margin-right: 5px;
        }

        @media (max-width: 1000px) {
            .lab-grid {
                grid-template-columns: 1fr;
            }
            .charts-grid {
                grid-template-columns: 1fr;
            }
            .input-group-container {
                flex-direction: column;
            }
            .tabs {
                flex-direction: column;
            }
        }

        /* Add this to the existing CSS media query */
        @media (max-width: 1000px) {
            .lab-grid {
                grid-template-columns: 1fr;
            }
            .charts-grid {
                grid-template-columns: 1fr;
            }
            .input-group-container {
                flex-direction: column;
            }
            .tabs {
                flex-direction: column;
            }
            /* Add this new rule for the environment panels grid */
            .environment-panel + .environment-panel {
                margin-top: 20px;
            }
            /* Make the environment panels stack on small screens */
            div[style*="grid-template-columns: 1fr 1fr"] {
                display: block !important;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Wireless Channel Modeling Virtual Lab</h1>
            <p>Interactive simulation of mobile radio channel fading characteristics</p>
        </div>

        <div class="tabs">
            <button class="tab-button active" onclick="switchTab('clarkes', event)">Clarke's Ideal Model</button>
            <button class="tab-button" onclick="switchTab('realistic', event)">Realistic Model</button>
        </div>

        <div id="clarkes" class="tab-content active">
            <div class="lab-grid">
                <div class="controls-panel">
                    <h2>Parameters - Clarke's Ideal Model</h2>
                    
                    <div class="input-group-container">
                        <div class="control-group">
                            <label for="velocity1">Vehicle 1 Velocity (m/s)</label>
                            <input type="number" id="velocity1" value="30" min="0" max="100" step="1">
                            <div class="help-text">Controls Doppler spread and fading rate.</div>
                        </div>

                        <div class="control-group">
                            <label for="velocity2">Vehicle 2 Velocity (m/s)</label>
                            <input type="number" id="velocity2" value="60" min="0" max="100" step="1">
                            <div class="help-text">Controls Doppler spread and fading rate.</div>
                        </div>
                        
                        <div class="control-group">
                            <label for="velocity3">Vehicle 3 Velocity (m/s)</label>
                            <input type="number" id="velocity3" value="90" min="0" max="100" step="1">
                            <div class="help-text">Controls Doppler spread and fading rate.</div>
                        </div>
                    </div>
                    <div class="input-group-container">
                        <div class="control-group">
                            <label for="frequency">Carrier Frequency (MHz)</label>
                            <input type="number" id="frequency" value="900" min="100" max="6000" step="100">
                            <div class="help-text">Affects wavelength and Doppler frequency.</div>
                        </div>

                        <div class="control-group">
                            <label for="scatterers">Number of Scatterers</label>
                            <input type="number" id="scatterers" value="20" min="6" max="50" step="2">
                            <div class="help-text">More scatterers provide a better approximation of the model.</div>
                        </div>
                    </div>
                    
                    <button class="simulate-button" onclick="simulateIdeal()">Simulate Clarke's Ideal Model</button>

                    <div class="info-box">
                        <h4>Clarke's Ideal Model</h4>
                        <p>This model is based on statistical properties rather than direct simulation. It assumes isotropic scattering, meaning signals arrive from all directions with equal probability, leading to a theoretical Bessel function for autocorrelation and a classic "bathtub" shape for the Doppler power spectrum.</p>
                        <ul style="margin: 10px 0 0 20px; line-height: 1.6;">
                            <li>Scatterers are uniformly distributed around the receiver.</li>
                            <li>Each signal path has equal average power.</li>
                        </ul>
                    </div>
                </div>

                <div class="environment-panel">
                    <h2>Scattering Environment</h2>
                    <canvas id="environmentCanvas" class="environment-canvas"></canvas>
                </div>
            </div>

            <div class="charts-grid">
                <div class="chart-panel-wrapper" id="autocorrelationPanel">
                    <div class="chart-panel">
                        <h3>Autocorrelation Function R(τ)</h3>
                        <div class="checkbox-group">
                            <label><input type="checkbox" id="v1-autocorr-check" checked> Vehicle 1</label>
                            <label><input type="checkbox" id="v2-autocorr-check" checked> Vehicle 2</label>
                            <label><input type="checkbox" id="v3-autocorr-check" checked> Vehicle 3</label>
                        </div>
                        <div class="chart-container">
                            <canvas id="autocorrelationChart"></canvas>
                        </div>
                    </div>
                </div>

                <div class="chart-panel-wrapper" id="psdPanel">
                    <div class="chart-panel">
                        <h3>Power Spectral Density S(f)</h3>
                        <div class="checkbox-group">
                            <label><input type="checkbox" id="v1-psd-check" checked> Vehicle 1</label>
                            <label><input type="checkbox" id="v2-psd-check" checked> Vehicle 2</label>
                            <label><input type="checkbox" id="v3-psd-check" checked> Vehicle 3</label>
                        </div>
                        <div class="chart-container">
                            <canvas id="psdChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="realistic" class="tab-content">
            <div class="lab-grid">
                <div class="controls-panel">
                    <h2>Parameters - Realistic Model</h2>
                    
                    <div class="input-group-container">
                        <div class="control-group">
                            <label for="velocity-realistic">Vehicle Velocity (m/s)</label>
                            <input type="number" id="velocity-realistic" value="30" min="0" max="100" step="1">
                            <div class="help-text">Controls Doppler spread and fading rate.</div>
                        </div>

                        <div class="control-group">
                            <label for="frequency-realistic">Carrier Frequency (MHz)</label>
                            <input type="number" id="frequency-realistic" value="900" min="100" max="6000" step="100">
                            <div class="help-text">Affects wavelength and Doppler frequency.</div>
                        </div>
                    </div>
                    
                    <div class="input-group-container">
                        <div class="control-group">
                            <label for="multipaths">Number of Multipaths (N)</label>
                            <input type="number" id="multipaths" value="20" min="6" max="50" step="2">
                            <div class="help-text">Number of multipath components in sum of sinusoids.</div>
                        </div>

                        <div class="control-group">
                            <label for="samples">Number of Samples (N)</label>
                            <input type="number" id="samples" value="1024" min="128" max="4096" step="128">
                            <div class="help-text">Number of time samples for simulation.</div>
                        </div>
                    </div>
                    
                    <button class="simulate-button" onclick="simulateRealistic()">Simulate Realistic Model</button>

                    <div class="info-box">
                        <h4>Realistic Model (Sum of Sinusoids)</h4>
                        <p>This model is a practical implementation of a Rayleigh fading channel using a **sum of sinusoids**. It simulates the channel's response by adding up a finite number of sinusoidal waves, each with a different frequency and random phase.</p>
                        <ul style="margin: 10px 0 0 20px; line-height: 1.6;">
                            <li>Simulates the channel response, not the received signal itself.</li>
                            <li>Generates an envelope that approximates a Rayleigh distribution.</li>
                            <li>The resulting autocorrelation function and power spectral density (PSD) can be compared to the ideal theoretical curves.</li>
                        </ul>
                    </div>
                </div>

                <!-- Change this section to include the signal plot -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                    <div class="environment-panel">
                        <h2>Multipath Environment</h2>
                        <canvas id="realisticEnvironmentCanvas" class="environment-canvas"></canvas>
                    </div>
                    
                    <!-- Add the new signal plot panel -->
                    <div class="environment-panel">
                        <h2>Received Signal Envelope |r(t)|</h2>
                        <div class="chart-container" style="height: 350px;">
                            <canvas id="receivedSignalChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>

            <div class="charts-grid">
                <div class="chart-panel-wrapper" id="realisticAutocorrelationPanel">
                    <div class="chart-panel">
                        <h3>Autocorrelation Function R(τ) - Simulated vs. Ideal</h3>
                        <div class="chart-container">
                            <canvas id="realisticAutocorrelationChart"></canvas>
                        </div>
                    </div>
                </div>

                <div class="chart-panel-wrapper" id="realisticPsdPanel">
                    <div class="chart-panel">
                        <h3>Power Spectral Density S(f) - Simulated vs. Ideal</h3>
                        <div class="chart-container">
                            <canvas id="realisticPsdChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Physical constants
        const SPEED_OF_LIGHT = 3e8;

        // Current active tab
        let currentTab = 'clarkes';

        // Add this variable declaration with other chart variables
        let receivedSignalChart = null;

        // DOM elements - Clarke's Ideal Model
        const velocity1Input = document.getElementById('velocity1');
        const velocity2Input = document.getElementById('velocity2');
        const velocity3Input = document.getElementById('velocity3');
        const frequencyInput = document.getElementById('frequency');
        const scatterersInput = document.getElementById('scatterers');
        const envCanvas = document.getElementById('environmentCanvas');
        const envCtx = envCanvas.getContext('2d');

        // DOM elements - Realistic Model
        const velocityRealisticInput = document.getElementById('velocity-realistic');
        const frequencyRealisticInput = document.getElementById('frequency-realistic');
        const multipathsInput = document.getElementById('multipaths');
        const samplesInput = document.getElementById('samples');
        const realisticEnvCanvas = document.getElementById('realisticEnvironmentCanvas');
        const realisticEnvCtx = realisticEnvCanvas.getContext('2d');

        // Checkboxes for plots
        const v1AutocorrCheck = document.getElementById('v1-autocorr-check');
        const v2AutocorrCheck = document.getElementById('v2-autocorr-check');
        const v3AutocorrCheck = document.getElementById('v3-autocorr-check');
        const v1PsdCheck = document.getElementById('v1-psd-check');
        const v2PsdCheck = document.getElementById('v2-psd-check');
        const v3PsdCheck = document.getElementById('v3-psd-check');

        // Charts
        let autocorrelationChart = null;
        let psdChart = null;
        let realisticAutocorrelationChart = null;
        let realisticPsdChart = null;

        // Switch between tabs
        function switchTab(tabName, event) {
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.querySelectorAll('.tab-button').forEach(button => {
                button.classList.remove('active');
            });
            document.getElementById(tabName).classList.add('active');
            event.target.classList.add('active');
            currentTab = tabName;
            
            if (tabName === 'clarkes') {
                drawEnvironment();
            } else {
                drawRealisticEnvironment();
            }
        }

        // Bessel function J0 approximation
        function besselJ0(x) {
            if (Math.abs(x) < 8.0) {
                const y = x * x;
                const ans1 = 57568490574.0 + y * (-13362590354.0 + y * (651619640.7 +
                    y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456)))));
                const ans2 = 57568490411.0 + y * (1029532985.0 + y * (9494680.718 +
                    y * (59272.64853 + y * (267.8532712 + y * 1.0))));
                return ans1 / ans2;
            } else {
                const z = 8.0 / x;
                const y = z * z;
                const xx = x - 0.785398164;
                const ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 +
                    y * (-0.2073370639e-5 + y * 0.2093887211e-6)));
                const ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 +
                    y * (-0.6911147651e-5 + y * (0.7621095161e-6 - y * 0.934935152e-7)));
                return Math.sqrt(0.636619772 / x) * (Math.cos(xx) * ans1 - z * Math.sin(xx) * ans2);
            }
        }

        // Generate Rayleigh fading using Jakes' sum of sinusoids model (corrected)
        function generateJakesRayleighFading(velocity, frequency, N, numSamples, Ts) {
            const wavelength = SPEED_OF_LIGHT / (frequency * 1e6);
            const fD = velocity / wavelength;
            
            const hI = new Array(numSamples).fill(0);
            const hQ = new Array(numSamples).fill(0);
            
            // Jakes' model parameters - angles are deterministic, phases are random
            const alpha_m = new Array(N).fill(0).map((_, m) => (2 * Math.PI * m) / N);
            const a_m = new Array(N).fill(0).map(() => Math.random() * 2 * Math.PI);
            const b_m = new Array(N).fill(0).map(() => Math.random() * 2 * Math.PI);

            for (let n = 0; n < numSamples; n++) {
                const t = n * Ts;
                for (let m = 0; m < N; m++) {
                    const angle = alpha_m[m];
                    // Corrected: Doppler frequency is fD * cos(alpha_m)
                    const doppler_freq = fD * Math.cos(angle);
                    const cos_arg = 2 * Math.PI * doppler_freq * t + a_m[m];
                    const sin_arg = 2 * Math.PI * doppler_freq * t + b_m[m];

                    hI[n] += Math.cos(cos_arg);
                    hQ[n] += Math.sin(sin_arg);
                }
            }
            
            // Normalize as per Jakes' formula: Cn = 1/sqrt(N)
            const norm = 1 / Math.sqrt(N);
            const hIn = hI.map(val => val * norm);
            const hQn = hQ.map(val => val * norm);
            
            return { hI: hIn, hQ: hQn };
        }

        // Add this missing function for updating realistic plots
        function updateRealisticPlots() {
            if (realisticAutocorrelationChart) {
                simulateRealistic();
            }
        }

        // Also add this missing function for updating ideal plots
        function updateIdealPlots() {
            const velocities = [
                parseFloat(velocity1Input.value),
                parseFloat(velocity2Input.value),
                parseFloat(velocity3Input.value)
            ];
            const frequency = parseFloat(frequencyInput.value);
            const maxTau = 0.1; // 100ms

            const datasets = [];
            const colors = ['#e53e3e', '#48bb78', '#9f7aea'];
            const labels = ['Vehicle 1', 'Vehicle 2', 'Vehicle 3'];
            const checks = [v1AutocorrCheck, v2AutocorrCheck, v3AutocorrCheck];

            // Autocorrelation datasets
            for (let i = 0; i < 3; i++) {
                if (checks[i].checked) {
                    const data = calculateAutocorrelation(velocities[i], frequency, maxTau);
                    datasets.push({
                        label: `${labels[i]} (${velocities[i]} m/s)`,
                        data: data,
                        borderColor: colors[i],
                        backgroundColor: colors[i] + '20',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.4,
                        pointRadius: 0
                    });
                }
            }

            // Update autocorrelation chart
            if (autocorrelationChart) {
                autocorrelationChart.destroy();
            }

            autocorrelationChart = new Chart(document.getElementById('autocorrelationChart'), {
                type: 'line',
                data: { datasets: datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: true }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Time τ (ms)'
                            },
                            grid: { color: 'rgba(0,0,0,0.1)' }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'R(τ)'
                            },
                            min: -1,
                            max: 1,
                            grid: { color: 'rgba(0,0,0,0.1)' }
                        }
                    }
                }
            });

            // PSD datasets
            const psdDatasets = [];
            const psdChecks = [v1PsdCheck, v2PsdCheck, v3PsdCheck];

            for (let i = 0; i < 3; i++) {
                if (psdChecks[i].checked) {
                    const data = calculatePSD(velocities[i], frequency);
                    psdDatasets.push({
                        label: `${labels[i]} (${velocities[i]} m/s)`,
                        data: data,
                        borderColor: colors[i],
                        backgroundColor: colors[i] + '20',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.2,
                        pointRadius: 0
                    });
                }
            }

            // Update PSD chart
            if (psdChart) {
                psdChart.destroy();
            }

            psdChart = new Chart(document.getElementById('psdChart'), {
                type: 'line',
                data: { datasets: psdDatasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: true }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Frequency (Hz)'
                            },
                            grid: { color: 'rgba(0,0,0,0.1)' }
                        },
                        y: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Power Spectral Density S(f)'
                            },
                            min: 0,
                            grid: { color: 'rgba(0,0,0,0.1)' }
                        }
                    }
                }
            });

            // Show the panels
            document.getElementById('autocorrelationPanel').style.display = 'block';
            document.getElementById('psdPanel').style.display = 'block';
        }

        // Calculate autocorrelation from complex time series
        function calculateAutocorrelationFromComplexSeries(hI, hQ) {
            const N = hI.length;
            const autocorr = [];
            const maxLag = Math.floor(N / 4);
            
            for (let lag = 0; lag <= maxLag; lag++) {
                let sumReal = 0;
                let count = 0;
                
                for (let i = 0; i < N - lag; i++) {
                    sumReal += (hI[i] * hI[i + lag] + hQ[i] * hQ[i + lag]);
                    count++;
                }
                
                autocorr.push(sumReal / count);
            }
            
            const R0 = autocorr[0];
            return autocorr.map(val => val / R0);
        }

        // Calculate PSD from complex time series
        function calculatePSDFromComplexSeries(hI, hQ, N, Ts) {
            const fs = 1 / Ts;
            
            const psd = [];
            const freqs = [];
            const halfN = Math.floor(N / 2);
            
            for (let k = 0; k < N; k++) {
                let realSum = 0;
                let imagSum = 0;
                
                for (let n = 0; n < N; n++) {
                    const angle = -2 * Math.PI * k * n / N;
                    const cosAngle = Math.cos(angle);
                    const sinAngle = Math.sin(angle);
                    
                    const h_real = hI[n];
                    const h_imag = hQ[n];
                    
                    realSum += (h_real * cosAngle - h_imag * sinAngle);
                    imagSum += (h_real * sinAngle + h_imag * cosAngle);
                }
                
                const magnitude = (realSum * realSum + imagSum * imagSum);
                psd.push(magnitude);
                freqs.push((k * fs) / N);
            }
            
            const shiftedPSD = [...psd.slice(halfN), ...psd.slice(0, halfN)];
            const shiftedFreqs = [...freqs.slice(halfN).map(f => f - fs / 2), ...freqs.slice(0, halfN).map(f => f + fs / 2)];

            const maxPSD = Math.max(...shiftedPSD);
            const normalizedPSD = maxPSD > 0 ? shiftedPSD.map(p => p / maxPSD) : shiftedPSD;
            
            return {
                freqs: shiftedFreqs,
                psd: normalizedPSD
            };
        }

        // Draw Clarke's environment
        function drawEnvironment() {
            const width = envCanvas.width = envCanvas.offsetWidth;
            const height = envCanvas.height = envCanvas.offsetHeight;
            
            envCtx.clearRect(0, 0, width, height);
            
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) * 0.35;
            const numScatterers = parseInt(scatterersInput.value);

            envCtx.strokeStyle = '#667eea';
            envCtx.lineWidth = 3;
            envCtx.beginPath();
            envCtx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            envCtx.stroke();

            envCtx.fillStyle = '#48bb78';
            for (let i = 0; i < numScatterers; i++) {
                const angle = (2 * Math.PI * i) / numScatterers;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                
                envCtx.beginPath();
                envCtx.arc(x, y, 6, 0, 2 * Math.PI);
                envCtx.fill();
                
                envCtx.strokeStyle = 'rgba(102, 126, 234, 0.3)';
                envCtx.lineWidth = 1;
                envCtx.beginPath();
                envCtx.moveTo(centerX, centerY);
                envCtx.lineTo(x, y);
                envCtx.stroke();
            }

            envCtx.fillStyle = '#e53e3e';
            envCtx.beginPath();
            envCtx.arc(centerX, centerY, 10, 0, 2 * Math.PI);
            envCtx.fill();
            
            envCtx.fillStyle = '#2d3748';
            envCtx.font = 'bold 14px Arial';
            envCtx.textAlign = 'center';
            envCtx.fillText('Rx', centerX, centerY + 5);

            const velocity = parseFloat(velocity1Input.value);
            if (velocity > 0) {
                envCtx.strokeStyle = '#e53e3e';
                envCtx.lineWidth = 3;
                envCtx.beginPath();
                envCtx.moveTo(centerX, centerY - 20);
                envCtx.lineTo(centerX + 30, centerY - 20);
                envCtx.stroke();
                
                envCtx.beginPath();
                envCtx.moveTo(centerX + 30, centerY - 20);
                envCtx.lineTo(centerX + 25, centerY - 25);
                envCtx.moveTo(centerX + 30, centerY - 20);
                envCtx.lineTo(centerX + 25, centerY - 15);
                envCtx.stroke();
                
                envCtx.fillStyle = '#2d3748';
                envCtx.font = '12px Arial';
                envCtx.fillText(`v = ${velocity} m/s`, centerX + 15, centerY - 30);
            }
        }

        // Draw realistic environment
        function drawRealisticEnvironment() {
            const width = realisticEnvCanvas.width = realisticEnvCanvas.offsetWidth;
            const height = realisticEnvCanvas.height = realisticEnvCanvas.offsetHeight;
            
            realisticEnvCtx.clearRect(0, 0, width, height);
            
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) * 0.35;
            const numMultipaths = parseInt(multipathsInput.value);

            for (let r = 1; r <= 3; r++) {
                realisticEnvCtx.strokeStyle = `rgba(102, 126, 234, ${0.3 - r * 0.08})`;
                realisticEnvCtx.lineWidth = 2;
                realisticEnvCtx.beginPath();
                realisticEnvCtx.arc(centerX, centerY, radius * r / 3, 0, 2 * Math.PI);
                realisticEnvCtx.stroke();
            }

            realisticEnvCtx.fillStyle = '#48bb78';
            for (let i = 0; i < numMultipaths; i++) {
                const angle = (2 * Math.PI * i) / numMultipaths;
                const r = radius * (0.6 + 0.4 * Math.random());
                const x = centerX + r * Math.cos(angle);
                const y = centerY + r * Math.sin(angle);
                
                realisticEnvCtx.beginPath();
                realisticEnvCtx.arc(x, y, 4, 0, 2 * Math.PI);
                realisticEnvCtx.fill();
                
                realisticEnvCtx.strokeStyle = 'rgba(102, 126, 234, 0.4)';
                realisticEnvCtx.lineWidth = 1;
                realisticEnvCtx.beginPath();
                realisticEnvCtx.moveTo(centerX, centerY);
                realisticEnvCtx.lineTo(x, y);
                realisticEnvCtx.stroke();
            }

            realisticEnvCtx.fillStyle = '#e53e3e';
            realisticEnvCtx.beginPath();
            realisticEnvCtx.arc(centerX, centerY, 10, 0, 2 * Math.PI);
            realisticEnvCtx.fill();
            
            realisticEnvCtx.fillStyle = '#2d3748';
            realisticEnvCtx.font = 'bold 14px Arial';
            realisticEnvCtx.textAlign = 'center';
            realisticEnvCtx.fillText('Rx', centerX, centerY + 5);

            const velocity = parseFloat(velocityRealisticInput.value);
            if (velocity > 0) {
                realisticEnvCtx.strokeStyle = '#e53e3e';
                realisticEnvCtx.lineWidth = 3;
                realisticEnvCtx.beginPath();
                realisticEnvCtx.moveTo(centerX, centerY - 20);
                realisticEnvCtx.lineTo(centerX + 30, centerY - 20);
                realisticEnvCtx.stroke();
                
                realisticEnvCtx.beginPath();
                realisticEnvCtx.moveTo(centerX + 30, centerY - 20);
                realisticEnvCtx.lineTo(centerX + 25, centerY - 25);
                realisticEnvCtx.moveTo(centerX + 30, centerY - 20);
                realisticEnvCtx.lineTo(centerX + 25, centerY - 15);
                realisticEnvCtx.stroke();
                
                realisticEnvCtx.fillStyle = '#2d3748';
                realisticEnvCtx.font = '12px Arial';
                realisticEnvCtx.fillText(`v = ${velocity} m/s`, centerX + 15, centerY - 30);
            }
        }

        // Calculate ideal autocorrelation for Clarke's model
        function calculateAutocorrelation(velocity, frequency, maxTau) {
            const wavelength = SPEED_OF_LIGHT / (frequency * 1e6);
            const fD = velocity / wavelength;
            const numPoints = 100;
            const tauStep = maxTau / numPoints;
            
            const data = [];
            for (let i = 0; i <= numPoints; i++) {
                const tau = i * tauStep;
                const correlation = besselJ0(2 * Math.PI * fD * tau);
                data.push({ x: tau * 1000, y: correlation });
            }
            
            return data;
        }

        // Calculate power spectral density (Jakes spectrum) for Clarke's model
        function calculatePSD(velocity, frequency) {
            const wavelength = SPEED_OF_LIGHT / (frequency * 1e6);
            const fD = velocity / wavelength;

            if (fD === 0) {
                return [{ x: 0, y: 1 }];
            }

            const numPoints = 200;
            const data = [];
            
            for (let i = 0; i <= numPoints; i++) {
                const f = (-fD * 1.5) + (i * 3 * fD) / numPoints;
                let psd = 0;
                
                if (Math.abs(f) < fD * 0.999) {
                    psd = 1 / (Math.PI * fD * Math.sqrt(1 - (f / fD) ** 2));
                }
                
                data.push({ x: f, y: psd });
            }
            
            return data;
        }

        // Generate Rayleigh fading using sum of sinusoids (realistic model)
        function generateRayleighFading(velocity, frequency, N, numSamples, Ts) {
            const wavelength = SPEED_OF_LIGHT / (frequency * 1e6);
            const fD = velocity / wavelength;
            
            const hI = new Array(numSamples).fill(0);
            const hQ = new Array(numSamples).fill(0);
            
            const alpha_m = new Array(N).fill(0).map((_, m) => (2 * Math.PI * m) / N);
            const a_m = new Array(N).fill(0).map(() => Math.random() * 2 * Math.PI);
            const b_m = new Array(N).fill(0).map(() => Math.random() * 2 * Math.PI);

            for (let n = 0; n < numSamples; n++) {
                const t = n * Ts;
                for (let m = 0; m < N; m++) {
                    const angle = alpha_m[m];
                    const cos_arg = 2 * Math.PI * fD * Math.cos(angle) * t + a_m[m];
                    const sin_arg = 2 * Math.PI * fD * Math.sin(angle) * t + b_m[m];

                    hI[n] += Math.cos(cos_arg);
                    hQ[n] += Math.sin(sin_arg);
                }
            }
            
            const norm = 1 / Math.sqrt(N);
            const hIn = hI.map(val => val * norm);
            const hQn = hQ.map(val => val * norm);
            
            return { hI: hIn, hQ: hQn };
        }

        // Calculate autocorrelation from complex time series
        function calculateAutocorrelationFromComplexSeries(hI, hQ) {
            const N = hI.length;
            const autocorr = [];
            const maxLag = Math.floor(N / 4);
            
            for (let lag = 0; lag <= maxLag; lag++) {
                let sumReal = 0;
                let count = 0;
                
                for (let i = 0; i < N - lag; i++) {
                    sumReal += (hI[i] * hI[i + lag] + hQ[i] * hQ[i + lag]);
                    count++;
                }
                
                autocorr.push(sumReal / count);
            }
            
            const R0 = autocorr[0];
            return autocorr.map(val => val / R0);
        }

        // Calculate PSD from complex time series
        function calculatePSDFromComplexSeries(hI, hQ, N, Ts) {
            const fs = 1 / Ts;
            
            const psd = [];
            const freqs = [];
            const halfN = Math.floor(N / 2);
            
            for (let k = 0; k < N; k++) {
                let realSum = 0;
                let imagSum = 0;
                
                for (let n = 0; n < N; n++) {
                    const angle = -2 * Math.PI * k * n / N;
                    const cosAngle = Math.cos(angle);
                    const sinAngle = Math.sin(angle);
                    
                    const h_real = hI[n];
                    const h_imag = hQ[n];
                    
                    realSum += (h_real * cosAngle - h_imag * sinAngle);
                    imagSum += (h_real * sinAngle + h_imag * cosAngle);
                }
                
                const magnitude = (realSum * realSum + imagSum * imagSum);
                psd.push(magnitude);
                freqs.push((k * fs) / N);
            }
            
            const shiftedPSD = [...psd.slice(halfN), ...psd.slice(0, halfN)];
            const shiftedFreqs = [...freqs.slice(halfN).map(f => f - fs / 2), ...freqs.slice(0, halfN).map(f => f + fs / 2)];

            const maxPSD = Math.max(...shiftedPSD);
            const normalizedPSD = maxPSD > 0 ? shiftedPSD.map(p => p / maxPSD) : shiftedPSD;
            
            return {
                freqs: shiftedFreqs,
                psd: normalizedPSD
            };
        }

        // Simulate Clarke's ideal model
        function simulateIdeal() {
            updateIdealPlots();
            drawEnvironment();
        }

        // Update the simulateRealistic function to include signal plotting
        function simulateRealistic() {
            const velocity = parseFloat(velocityRealisticInput.value);
            const frequency = parseFloat(frequencyRealisticInput.value);
            const N = parseInt(multipathsInput.value);
            const numSamples = parseInt(samplesInput.value);

            const wavelength = SPEED_OF_LIGHT / (frequency * 1e6);
            const fD = velocity / wavelength;
            const Ts = 1 / (20 * Math.max(fD, 1));
            
            // Generate the channel response h(t) using corrected Jakes' model
            const channelResponse = generateJakesRayleighFading(velocity, frequency, N, numSamples, Ts);
            const hI = channelResponse.hI;
            const hQ = channelResponse.hQ;

            // Calculate the envelope |r(t)| = |h(t)| for plotting
            const envelope = hI.map((real, idx) => Math.sqrt(real * real + hQ[idx] * hQ[idx]));
            
            // Create time axis for signal plotting (show only first 200 samples for clarity)
            const plotSamples = Math.min(200, numSamples);
            const timeAxis = Array.from({length: plotSamples}, (_, i) => i * Ts * 1000); // Convert to ms
            const envelopeData = envelope.slice(0, plotSamples).map((val, idx) => ({
                x: timeAxis[idx],
                y: val
            }));

            // Plot the received signal envelope
            if (receivedSignalChart) {
                receivedSignalChart.destroy();
            }
            
            receivedSignalChart = new Chart(document.getElementById('receivedSignalChart'), {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Envelope |r(t)|',
                        data: envelopeData,
                        borderColor: '#48bb78',
                        backgroundColor: 'rgba(72, 187, 120, 0.1)',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.1,
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: true }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Time (ms)'
                            },
                            grid: { color: 'rgba(0,0,0,0.1)' }
                        },
                        y: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Amplitude'
                            },
                            min: 0,
                            grid: { color: 'rgba(0,0,0,0.1)' }
                        }
                    }
                }
            });

            // For the received signal, assuming transmitted signal is a simple carrier
            // r(t) = h(t) * s(t), where s(t) = exp(j*2*pi*fc*t)
            // Since we're working at baseband, r(t) ≈ h(t)
            const rI = hI;
            const rQ = hQ;

            // ... rest of the existing simulateRealistic function remains the same ...
            const maxLag = Math.min(Math.floor(numSamples / 4), 50);
            const simulatedAutocorr = calculateAutocorrelationFromComplexSeries(rI, rQ);
            
            const idealAutocorr = [];
            const timeAxisCorr = [];
            
            for (let i = 0; i <= maxLag; i++) {
                const tau = i * Ts;
                timeAxisCorr.push(tau * 1000); // Convert to milliseconds
                idealAutocorr.push(besselJ0(2 * Math.PI * fD * tau));
            }
            
            const realisticAutocorrData = simulatedAutocorr.slice(0, maxLag + 1).map((val, idx) => ({
                x: timeAxisCorr[idx],
                y: val
            }));
            
            const idealAutocorrData = idealAutocorr.map((val, idx) => ({
                x: timeAxisCorr[idx],
                y: val
            }));
            
            // Calculate PSD
            const realisticPSDResult = calculatePSDFromComplexSeries(rI, rQ, numSamples, Ts);
            const idealPSD = calculatePSD(velocity, frequency);
            
            const realisticPSDData = realisticPSDResult.psd.map((val, idx) => ({
                x: realisticPSDResult.freqs[idx],
                y: val
            }));

            // Update autocorrelation chart
            if (realisticAutocorrelationChart) {
                realisticAutocorrelationChart.destroy();
            }
            
            realisticAutocorrelationChart = new Chart(document.getElementById('realisticAutocorrelationChart'), {
                type: 'line',
                data: {
                    datasets: [
                        {
                            label: 'Jakes Model (Simulated)',
                            data: realisticAutocorrData,
                            borderColor: '#e53e3e',
                            backgroundColor: 'rgba(229, 62, 62, 0.1)',
                            borderWidth: 2,
                            fill: false,
                            tension: 0.1,
                            pointRadius: 0
                        },
                        {
                            label: 'Clarke Model (Theoretical)',
                            data: idealAutocorrData,
                            borderColor: '#667eea',
                            backgroundColor: 'rgba(102, 126, 234, 0.1)',
                            borderWidth: 2,
                            fill: false,
                            tension: 0.4,
                            pointRadius: 0,
                            borderDash: [5, 5]
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: true }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Time τ (ms)'
                            },
                            grid: { color: 'rgba(0,0,0,0.1)' }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'R(τ)'
                            },
                            min: -1,
                            max: 1,
                            grid: { color: 'rgba(0,0,0,0.1)' }
                        }
                    }
                }
            });
            
            // Update PSD chart
            const allFreqs = [...realisticPSDResult.freqs, ...idealPSD.map(point => point.x)];
            const minFreq = Math.min(...allFreqs);
            const maxFreq = Math.max(...allFreqs);
            const xAxisMin = Math.floor(minFreq / 50) * 50;
            const xAxisMax = Math.ceil(maxFreq / 50) * 50;

            if (realisticPsdChart) {
                realisticPsdChart.destroy();
            }

            realisticPsdChart = new Chart(document.getElementById('realisticPsdChart'), {
                type: 'line',
                data: {
                    datasets: [
                        {
                            label: 'Jakes Model (Simulated)',
                            data: realisticPSDData,
                            borderColor: '#e53e3e',
                            backgroundColor: 'rgba(229, 62, 62, 0.1)',
                            borderWidth: 2,
                            fill: false,
                            tension: 0.1,
                            pointRadius: 0
                        },
                        {
                            label: 'Clarke Model (Theoretical)',
                            data: idealPSD,
                            borderColor: '#667eea',
                            backgroundColor: 'rgba(102, 126, 234, 0.1)',
                            borderWidth: 2,
                            fill: false,
                            tension: 0.2,
                            pointRadius: 0,
                            borderDash: [5, 5]
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: true }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Frequency (Hz)'
                            },
                            min: xAxisMin,
                            max: xAxisMax,
                            grid: { color: 'rgba(0,0,0,0.1)' }
                        },
                        y: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Power Spectral Density S(f)'
                            },
                            min: 0,
                            grid: { color: 'rgba(0,0,0,0.1)' }
                        }
                    }
                }
            });
            
            // Show the panels
            document.getElementById('realisticAutocorrelationPanel').style.display = 'block';
            document.getElementById('realisticPsdPanel').style.display = 'block';
            drawRealisticEnvironment();
        }
        
        // Event listeners for Clarke's model
        velocity1Input.addEventListener('input', drawEnvironment);
        velocity2Input.addEventListener('input', drawEnvironment);
        velocity3Input.addEventListener('input', drawEnvironment);
        frequencyInput.addEventListener('input', drawEnvironment);
        scatterersInput.addEventListener('input', drawEnvironment);

        // Event listeners for realistic model 
        velocityRealisticInput.addEventListener('input', drawRealisticEnvironment);
        frequencyRealisticInput.addEventListener('input', drawRealisticEnvironment);
        multipathsInput.addEventListener('input', drawRealisticEnvironment);

        // Listeners for checkboxes to update ideal plots
        v1AutocorrCheck.addEventListener('change', updateIdealPlots);
        v2AutocorrCheck.addEventListener('change', updateIdealPlots);
        v3AutocorrCheck.addEventListener('change', updateIdealPlots);
        v1PsdCheck.addEventListener('change', updateIdealPlots);
        v2PsdCheck.addEventListener('change', updateIdealPlots);
        v3PsdCheck.addEventListener('change', updateIdealPlots);
        
        window.addEventListener('resize', () => {
            setTimeout(() => {
                if (currentTab === 'clarkes' && autocorrelationChart) {
                    updateIdealPlots();
                    drawEnvironment();
                } else if (currentTab === 'realistic' && realisticAutocorrelationChart) {
                    updateRealisticPlots();
                    drawRealisticEnvironment();
                }
            }, 100);
        });

        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('autocorrelationPanel').style.display = 'none';
            document.getElementById('psdPanel').style.display = 'none';
            document.getElementById('realisticAutocorrelationPanel').style.display = 'none';
            document.getElementById('realisticPsdPanel').style.display = 'none';
            drawEnvironment();
        });
    </script>
</body>
</html>