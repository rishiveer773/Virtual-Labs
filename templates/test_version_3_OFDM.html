<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OFDM Virtual Experiment</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 2.5rem 1rem;
            box-sizing: border-box;
        }
        .container {
            background-color: #ffffff;
            border-radius: 1.5rem;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.1);
            padding: 2.5rem;
            width: 100%;
            max-width: 1400px;
            display: grid;
            grid-template-columns: 300px 1fr 1fr;
            gap: 2rem;
            min-height: 600px;
        }

        .block-diagram-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 1.5rem;
            overflow-x: auto;
            padding: 10px;
        }

        @media (max-width: 1200px) {
            .container {
                grid-template-columns: 1fr;
            }
        }
        h2 {
            font-size: 1.5rem;
            font-weight: 700;
            color: #1e293b;
            text-align: center;
            margin-bottom: 1.5rem;
        }
        .input-section {
            border-right: 2px solid #e2e8f0;
            padding-right: 2rem;
        }
        @media (max-width: 1200px) {
            .input-section {
                border-right: none;
                border-bottom: 2px solid #e2e8f0;
                padding-right: 0;
                padding-bottom: 2rem;
            }
        }
        .input-group {
            display: flex;
            flex-direction: column;
            margin-bottom: 1rem;
        }
        .input-group label {
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: #475569;
        }
        .input-group input, .input-group select {
            padding: 0.75rem 1rem;
            border: 1px solid #cbd5e1;
            border-radius: 0.5rem;
            font-size: 1rem;
            color: #334155;
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        .input-group input:focus, .input-group select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }
        .button-primary {
            background-color: #3b82f6;
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            border: none;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            width: 100%;
        }
        .button-primary:hover {
            background-color: #2563eb;
            transform: translateY(-1px);
        }
        .button-primary:active {
            background-color: #1d4ed8;
            transform: translateY(0);
        }
        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3b82f6;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            display: none;
            margin: 1rem auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .error-message {
            color: #ef4444;
            background-color: #fee2e2;
            border: 1px solid #fca5a5;
            padding: 0.75rem;
            border-radius: 0.5rem;
            margin-top: 1rem;
            display: none;
        }
        .simulation-area {
            grid-column: 2 / span 2;
        }
        @media (max-width: 1200px) {
            .simulation-area {
                grid-column: 1;
            }
        }
        .block-diagram-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 1.5rem;
        }
        .ofdm-block {
            fill: #e0e7ff;
            stroke: #3b82f6;
            stroke-width: 2;
            transition: fill 0.3s ease, stroke 0.3s ease, transform 0.3s ease;
        }
        .ofdm-block-text {
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            font-weight: 600;
            fill: #1e293b;
            text-anchor: middle;
            dominant-baseline: central;
            pointer-events: none;
        }
        .ofdm-block.highlighted {
            fill: #93c5fd;
            stroke: #1d4ed8;
            stroke-width: 3;
            transform: scale(1.05);
        }
        .ofdm-block-text.highlighted {
             font-weight: 700;
        }
        .arrow {
            stroke: #64748b;
            stroke-width: 2;
            fill: none;
            marker-end: url(#arrowhead);
            transition: stroke 0.3s ease;
        }
        .arrowhead {
            fill: #64748b;
        }
        .arrow.highlighted {
            stroke: #1d4ed8;
        }
        .chart-container {
            margin-top: 2rem;
        }
        .chart-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: #374151;
            text-align: center;
            margin-bottom: 1rem;
        }
        .nav-buttons {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1.5rem;
        }
        .output-area {
            grid-column: 3;
        }
        @media (max-width: 1200px) {
            .output-area {
                grid-column: 1;
            }
        }
        .simulation-info {
            background-color: #f1f5f9;
            border-radius: 0.75rem;
            padding: 1.5rem;
            margin-top: 1.5rem;
            border: 1px solid #e2e8f0;
        }
        .simulation-info h3 {
            font-size: 1.125rem;
            font-weight: 600;
            color: #1e293b;
            margin-bottom: 0.75rem;
        }
        .simulation-info p {
            font-family: 'monospace', sans-serif;
            font-size: 0.875rem;
            color: #334155;
            line-height: 1.5;
            white-space: pre-wrap; /* Preserve formatting */
            word-wrap: break-word; /* Break long words */
            max-height: 200px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="input-section">
            <h2 class="text-2xl font-bold text-center text-gray-800 mb-4">Simulation Inputs</h2>
            <div class="input-grid">
                <div class="input-group">
                    <label for="nFFTSize">FFT Size (N):</label>
                    <input type="number" id="nFFTSize" value="64" min="16" step="16">
                </div>
                <div class="input-group">
                    <label for="numSubcarriers">Number of Data Subcarriers:</label>
                    <input type="number" id="numSubcarriers" value="52" min="12" step="4">
                </div>
                <div class="input-group">
                    <label for="modulationScheme">Modulation Scheme:</label>
                    <select id="modulationScheme">
                        <option value="BPSK">BPSK</option>
                        <option value="QPSK">QPSK</option>
                        <option value="16QAM">16-QAM</option>
                    </select>
                </div>
                <div class="input-group">
                    <label for="cpLength">Cyclic Prefix Length:</label>
                    <input type="number" id="cpLength" value="16" min="4" step="4">
                </div>
                <div class="input-group">
                    <label for="snrDb">SNR (dB) for Plots:</label>
                    <input type="number" id="snrDb" value="20" min="-10" max="50" step="1">
                </div>
                <div class="input-group">
                    <label for="numSymbolsBer">Symbols for BER:</label>
                    <input type="number" id="numSymbolsBer" value="1000" min="100" step="100">
                </div>
            </div>
            <button id="runStepByStepBtn" class="button-primary w-full mt-4 bg-blue-500 hover:bg-blue-600">Run Step-by-Step Simulation</button>
            <button id="runBerSimBtn" class="button-primary w-full mt-2 bg-emerald-500 hover:bg-emerald-600">Run BER Simulation</button>
            <button id="resetBtn" class="button-primary w-full mt-2 bg-slate-500 hover:bg-slate-600">Reset Simulation</button>
            <div id="loadingSpinner" class="loading-spinner"></div>
            <div id="errorMessage" class="error-message"></div>
        </div>

        <div class="simulation-area">
            <h2 class="text-2xl font-bold text-center text-gray-800 mb-4">OFDM Signal Flow</h2>
            <div class="block-diagram-container">
                <svg id="ofdmBlockDiagram" width="600" height="350" viewBox="0 0 600 350">
                    <defs>
                        <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
                            <polygon points="0 0, 10 3.5, 0 7" class="arrowhead" />
                        </marker>
                    </defs>

                    <rect id="block-tx" class="ofdm-block" x="10" y="20" width="120" height="60" rx="8" ry="8"></rect>
                    <text class="ofdm-block-text" x="70" y="40">S/P</text>
                    <text class="ofdm-block-text" x="70" y="60">+ Mapping</text>
                    <line id="tx-to-idft" x1="70" y1="80" x2="70" y2="100" class="arrow" />

                    <rect id="block-idft" class="ofdm-block" x="10" y="100" width="120" height="60" rx="8" ry="8"></rect>
                    <text class="ofdm-block-text" x="70" y="130">IDFT</text>
                    <line id="idft-to-addcp" x1="70" y1="160" x2="70" y2="180" class="arrow" />

                    <rect id="block-addcp" class="ofdm-block" x="10" y="180" width="120" height="60" rx="8" ry="8"></rect>
                    <text class="ofdm-block-text" x="70" y="210">Add CP</text>

                    <line id="tx-to-channel" x1="130" y1="210" x2="250" y2="210" class="arrow" />

                    <rect id="block-channel" class="ofdm-block" x="250" y="180" width="100" height="60" rx="8" ry="8"></rect>
                    <text class="ofdm-block-text" x="300" y="210">Channel</text>

                    <line id="channel-to-rx" x1="350" y1="210" x2="470" y2="210" class="arrow" />

                    <rect id="block-removecp" class="ofdm-block" x="470" y="180" width="120" height="60" rx="8" ry="8"></rect>
                    <text class="ofdm-block-text" x="530" y="210">Remove CP</text>
                    <line id="removecp-to-dft" x1="530" y1="180" x2="530" y2="160" class="arrow" />

                    <rect id="block-fft" class="ofdm-block" x="470" y="100" width="120" height="60" rx="8" ry="8"></rect>
                    <text class="ofdm-block-text" x="530" y="130">FFT</text>
                    <line id="dft-to-demapping" x1="530" y1="100" x2="530" y2="80" class="arrow" />

                    <rect id="block-rx" class="ofdm-block" x="470" y="20" width="120" height="60" rx="8" ry="8"></rect>
                    <text class="ofdm-block-text" x="530" y="40">Demapping</text>
                    <text class="ofdm-block-text" x="530" y="60">+ P/S</text>
                </svg>
            </div>

            <div class="nav-buttons">
                <button id="prevBlockBtn" class="button-primary w-40 disabled:opacity-50 disabled:cursor-not-allowed">Previous Step</button>
                <button id="nextBlockBtn" class="button-primary w-40 disabled:opacity-50 disabled:cursor-not-allowed">Next Step</button>
            </div>
            
            <div class="simulation-info">
                <h3 id="blockOutputTitle">Simulation Step Output</h3>
                <p id="blockOutputDisplay">Run a simulation to see the step-by-step output here.</p>
            </div>

            <div class="chart-container">
                <h3 class="chart-title" id="constellationChartTitle">Transmitted Constellation Diagram</h3>
                <canvas id="constellationChart" style="display: none;"></canvas>
            </div>
            <div class="chart-container">
                <h3 class="chart-title" id="preChannelSpectrumChartTitle">Pre-Channel Spectrum</h3>
                <canvas id="preChannelSpectrumChart" style="display: none;"></canvas>
            </div>
            <div class="chart-container">
                <h3 class="chart-title" id="postChannelSpectrumChartTitle">Post-Channel Spectrum</h3>
                <canvas id="postChannelSpectrumChart" style="display: none;"></canvas>
            </div>
        </div>

        <div class="output-area">
            <h2 class="text-2xl font-bold text-center text-gray-800 mb-4">Results</h2>
            <div class="chart-container">
                <h3 class="chart-title" id="receivedConstellationChartTitle">Received Constellation Diagram</h3>
                <canvas id="receivedConstellationChart" style="display: none;"></canvas>
            </div>
            <div class="chart-container">
                <h3 class="chart-title" id="berCurveChartTitle">BER Curve</h3>
                <canvas id="berCurveChart" style="display: none;"></canvas>
            </div>
        </div>
    </div>

    <script>
        // --- Complex Number Class and DSP Helper Functions (kept as-is) ---
        class Complex {
            constructor(re, im = 0) {
                this.re = re;
                this.im = im;
            }
            add(other) {
                return new Complex(this.re + other.re, this.im + other.im);
            }
            sub(other) {
                return new Complex(this.re - other.re, this.im - other.im);
            }
            mul(other) {
                return new Complex(
                    this.re * other.re - this.im * other.im,
                    this.re * other.im + this.im * other.re
                );
            }
            div(other) {
                if (other.re === 0 && other.im === 0) return new Complex(Infinity, Infinity);
                const den = other.re * other.re + other.im * other.im;
                return new Complex(
                    (this.re * other.re + this.im * other.im) / den,
                    (this.im * other.re - this.re * other.im) / den
                );
            }
            magSq() {
                return this.re * this.re + this.im * this.im;
            }
            mag() {
                return Math.sqrt(this.magSq());
            }
            conj() {
                return new Complex(this.re, -this.im);
            }
            toString() {
                if (this.im === 0) return this.re.toFixed(3);
                if (this.re === 0) return `${this.im.toFixed(3)}i`;
                const sign = this.im > 0 ? '+' : '';
                return `${this.re.toFixed(3)}${sign}${this.im.toFixed(3)}i`;
            }
        }
        function fft(x) {
            const N = x.length;
            if (N <= 1) return x;
            const even = [];
            const odd = [];
            for (let i = 0; i < N / 2; i++) {
                even[i] = x[i * 2];
                odd[i] = x[i * 2 + 1];
            }
            const Y_even = fft(even);
            const Y_odd = fft(odd);
            const Y = new Array(N);
            for (let k = 0; k < N / 2; k++) {
                const t = new Complex(Math.cos(-2 * Math.PI * k / N), Math.sin(-2 * Math.PI * k / N)).mul(Y_odd[k]);
                Y[k] = Y_even[k].add(t);
                Y[k + N / 2] = Y_even[k].sub(t);
            }
            return Y;
        }
        function ifft(X) {
            const N = X.length;
            if (N <= 1) return X;
            const X_conj = X.map(c => new Complex(c.re, -c.im));
            const y_conj = fft(X_conj);
            return y_conj.map(c => new Complex(c.re / N, -c.im / N));
        }
        function fftshift(arr) {
            const mid = Math.floor(arr.length / 2);
            return [...arr.slice(mid), ...arr.slice(0, mid)];
        }
        function dbToLinear(db) {
            return Math.pow(10, db / 10);
        }
        function linearToDb(linear) {
            if (linear <= 0 || !isFinite(linear)) return -100;
            const dbValue = 10 * Math.log10(linear);
            return isFinite(dbValue) ? dbValue : -100;
        }
        function randn() {
            let u = 0, v = 0;
            while (u === 0) u = Math.random();
            while (v === 0) v = Math.random();
            return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
        }
        function bpskModulate(bit) { return new Complex(2 * bit - 1); }
        function qpskModulate(bits) {
            const real = (2 * bits[0] - 1) / Math.sqrt(2);
            const imag = (2 * bits[1] - 1) / Math.sqrt(2);
            return new Complex(real, imag);
        }
        function qam16Modulate(bits) {
            const map = {
                "0000": new Complex(-3 / Math.sqrt(10), -3 / Math.sqrt(10)), "0001": new Complex(-3 / Math.sqrt(10), -1 / Math.sqrt(10)),
                "0010": new Complex(-3 / Math.sqrt(10), 3 / Math.sqrt(10)), "0011": new Complex(-3 / Math.sqrt(10), 1 / Math.sqrt(10)),
                "0100": new Complex(-1 / Math.sqrt(10), -3 / Math.sqrt(10)), "0101": new Complex(-1 / Math.sqrt(10), -1 / Math.sqrt(10)),
                "0110": new Complex(-1 / Math.sqrt(10), 3 / Math.sqrt(10)), "0111": new Complex(-1 / Math.sqrt(10), 1 / Math.sqrt(10)),
                "1000": new Complex(3 / Math.sqrt(10), -3 / Math.sqrt(10)), "1001": new Complex(3 / Math.sqrt(10), -1 / Math.sqrt(10)),
                "1010": new Complex(3 / Math.sqrt(10), 3 / Math.sqrt(10)), "1011": new Complex(3 / Math.sqrt(10), 1 / Math.sqrt(10)),
                "1100": new Complex(1 / Math.sqrt(10), -3 / Math.sqrt(10)), "1101": new Complex(1 / Math.sqrt(10), -1 / Math.sqrt(10)),
                "1110": new Complex(1 / Math.sqrt(10), 3 / Math.sqrt(10)), "1111": new Complex(1 / Math.sqrt(10), 1 / Math.sqrt(10)),
            };
            return map[bits.join('')];
        }
        function bpskDemodulate(symbol) { return symbol.re > 0 ? 1 : 0; }
        function qpskDemodulate(symbol) {
            return [symbol.re > 0 ? 1 : 0, symbol.im > 0 ? 1 : 0];
        }
        function qam16Demodulate(symbol) {
            const constellationPoints = {
                "0000": new Complex(-3 / Math.sqrt(10), -3 / Math.sqrt(10)), "0001": new Complex(-3 / Math.sqrt(10), -1 / Math.sqrt(10)),
                "0010": new Complex(-3 / Math.sqrt(10), 3 / Math.sqrt(10)), "0011": new Complex(-3 / Math.sqrt(10), 1 / Math.sqrt(10)),
                "0100": new Complex(-1 / Math.sqrt(10), -3 / Math.sqrt(10)), "0101": new Complex(-1 / Math.sqrt(10), -1 / Math.sqrt(10)),
                "0110": new Complex(-1 / Math.sqrt(10), 3 / Math.sqrt(10)), "0111": new Complex(-1 / Math.sqrt(10), 1 / Math.sqrt(10)),
                "1000": new Complex(3 / Math.sqrt(10), -3 / Math.sqrt(10)), "1001": new Complex(3 / Math.sqrt(10), -1 / Math.sqrt(10)),
                "1010": new Complex(3 / Math.sqrt(10), 3 / Math.sqrt(10)), "1011": new Complex(3 / Math.sqrt(10), 1 / Math.sqrt(10)),
                "1100": new Complex(1 / Math.sqrt(10), -3 / Math.sqrt(10)), "1101": new Complex(1 / Math.sqrt(10), -1 / Math.sqrt(10)),
                "1110": new Complex(1 / Math.sqrt(10), 3 / Math.sqrt(10)), "1111": new Complex(1 / Math.sqrt(10), 1 / Math.sqrt(10)),
            };
            let minDistanceSq = Infinity;
            let demodulatedBits = '';
            for (const bitString in constellationPoints) {
                const idealPoint = constellationPoints[bitString];
                const distanceSq = (symbol.re - idealPoint.re) ** 2 + (symbol.im - idealPoint.im) ** 2;
                if (distanceSq < minDistanceSq) {
                    minDistanceSq = distanceSq;
                    demodulatedBits = bitString;
                }
            }
            return demodulatedBits.split('').map(Number);
        }
        function generateBits(numBits) { return Array.from({ length: numBits }, () => Math.random() > 0.5 ? 1 : 0); }
        function modulate(bits, modulationScheme, bitsPerSymbol) {
            const modulatedSymbols = [];
            let modulateFunc;
            switch (modulationScheme) {
                case 'BPSK': modulateFunc = bpskModulate; break;
                case 'QPSK': modulateFunc = qpskModulate; break;
                case '16QAM': modulateFunc = qam16Modulate; break;
                default: throw new Error('Invalid modulation scheme.');
            }
            for (let i = 0; i < bits.length; i += bitsPerSymbol) {
                const currentBits = bits.slice(i, i + bitsPerSymbol);
                if (bitsPerSymbol === 1) {
                    modulatedSymbols.push(modulateFunc(currentBits[0]));
                } else {
                    modulatedSymbols.push(modulateFunc(currentBits));
                }
            }
            return modulatedSymbols;
        }
        function mapToSubcarriers(symbols, nFFTSize, numSubcarriers) {
            const inputiFFT = Array.from({ length: nFFTSize }, () => new Complex(0));
            let symbolIdx = 0;
            if (nFFTSize === 64 && numSubcarriers === 52) {
                const subcarrierIndices80211a = [-26, -25, -24, -23, -22, -21, -20, -19, -18, -17, -16, -15, -14, -13, -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1,
                                                 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26];
                for (const scIdx of subcarrierIndices80211a) {
                    let arrayIdx = scIdx > 0 ? scIdx : nFFTSize + scIdx;
                    if (symbolIdx < symbols.length) {
                        inputiFFT[arrayIdx] = symbols[symbolIdx++];
                    }
                }
            } else {
                const halfSubcarriers = Math.floor(numSubcarriers / 2);
                for (let i = 1; i <= halfSubcarriers && symbolIdx < symbols.length; i++) { inputiFFT[i] = symbols[symbolIdx++]; }
                for (let i = nFFTSize - halfSubcarriers; i < nFFTSize && symbolIdx < symbols.length; i++) { inputiFFT[i] = symbols[symbolIdx++]; }
            }
            return inputiFFT;
        }
        function addCyclicPrefix(signal, cpLength) {
            const cyclicPrefix = signal.slice(signal.length - cpLength);
            return [...cyclicPrefix, ...signal];
        }
        function applyRayleighFading(signal) {
            const fadedSignal = [];
            const channelGains = [];
            for (let i = 0; i < signal.length; i++) {
                const h_real = randn() / Math.sqrt(2);
                const h_imag = randn() / Math.sqrt(2);
                const h = new Complex(h_real, h_imag);
                channelGains.push(h);
                fadedSignal.push(signal[i].mul(h));
            }
            return { fadedSignal, channelGains };
        }
        function addAwgn(signal, snrDb) {
            const signalPower = signal.reduce((sum, val) => sum + val.magSq(), 0) / signal.length;
            const snrLinear = dbToLinear(snrDb);
            const noisePower = signalPower / snrLinear;
            const noiseStdDev = Math.sqrt(noisePower / 2);
            return signal.map(sample => {
                const noiseReal = randn() * noiseStdDev;
                const noiseImag = randn() * noiseStdDev;
                return sample.add(new Complex(noiseReal, noiseImag));
            });
        }
        function removeCyclicPrefix(signalWithCP, cpLength, nFFTSize) {
            return signalWithCP.slice(cpLength, cpLength + nFFTSize);
        }
        function equalize(receivedSymbolsFFT, channelGainsFFT) {
            return receivedSymbolsFFT.map((sym, i) => {
                const channelGain = channelGainsFFT[i];
                if (channelGain.magSq() < 1e-10) { 
                    return new Complex(0, 0); 
                }
                const result = sym.div(channelGain);
                // Bound the result to prevent infinite values
                if (!isFinite(result.re) || !isFinite(result.im) || 
                    Math.abs(result.re) > 100 || Math.abs(result.im) > 100) {
                    return new Complex(0, 0);
                }
                return result;
            });
        }
        function demodulate(symbols, modulationScheme) {
            const demodulatedBits = [];
            let demodulateFunc;
            switch (modulationScheme) {
                case 'BPSK': demodulateFunc = bpskDemodulate; break;
                case 'QPSK': demodulateFunc = qpskDemodulate; break;
                case '16QAM': demodulateFunc = qam16Demodulate; break;
                default: throw new Error('Invalid modulation scheme.');
            }
            for (const symbol of symbols) {
                const bits = demodulateFunc(symbol);
                if (Array.isArray(bits)) {
                    demodulatedBits.push(...bits);
                } else {
                    demodulatedBits.push(bits);
                }
            }
            return demodulatedBits;
        }
        function calculateBer(originalBits, receivedBits) {
            let errors = 0;
            const minLength = Math.min(originalBits.length, receivedBits.length);
            for (let i = 0; i < minLength; i++) {
                if (originalBits[i] !== receivedBits[i]) {
                    errors++;
                }
            }
            return errors / originalBits.length;
        }

        // --- Utility Functions ---
        function formatComplexArrayForDisplay(arr, count = 5) {
            if (!arr || arr.length === 0) return "N/A";
            const sample = arr.slice(0, count).map(c => c.toString()).join(', ');
            return `[${sample}${arr.length > count ? ', ...' : ''}]`;
        }
        function formatBitArrayForDisplay(arr, count = 20) {
            if (!arr || arr.length === 0) return "N/A";
            const sample = arr.slice(0, count).join('');
            return `${sample}${arr.length > count ? '...' : ''}`;
        }
        
        // --- Global Variables & Simulation Logic ---
        let globalTransmittedBits = [];
        let globalModulatedSymbols = [];
        let globalTxWaveformPreChannel = [];
        let globalRxWaveformPostChannel = [];
        let globalRxNoCP = [];
        let globalRxFFTOutput = [];
        let globalReceivedSymbols = [];
        let globalChannelGainsFFT = [];

        const fsMHz = 20;
        const fftLengthForSpectrum = 4096;
        const frequencies = Array.from({ length: fftLengthForSpectrum }, (_, i) =>
            (i - fftLengthForSpectrum / 2) * fsMHz / fftLengthForSpectrum
        );

        async function runStepByStepSimulation() {
            const nFFTSize = parseInt(document.getElementById('nFFTSize').value);
            const numSubcarriers = parseInt(document.getElementById('numSubcarriers').value);
            const modulationScheme = document.getElementById('modulationScheme').value;
            const cpLength = parseInt(document.getElementById('cpLength').value);
            const snrDb = parseFloat(document.getElementById('snrDb').value);

            document.getElementById('loadingSpinner').style.display = 'block';
            document.getElementById('errorMessage').style.display = 'none';
            document.getElementById('errorMessage').textContent = '';

            const bitsPerSymbol = (modulationScheme === 'BPSK') ? 1 : (modulationScheme === 'QPSK' ? 2 : 4);
            const numBitsPerOFDMSymbol = numSubcarriers * bitsPerSymbol;

            try {
                globalTransmittedBits = generateBits(numBitsPerOFDMSymbol);
                globalModulatedSymbols = modulate(globalTransmittedBits, modulationScheme, bitsPerSymbol);
                let ifftInput = mapToSubcarriers(globalModulatedSymbols, nFFTSize, numSubcarriers);
                let ifftOutput = ifft(ifftInput);
                globalTxWaveformPreChannel = addCyclicPrefix(ifftOutput, cpLength);

                const { fadedSignal, channelGains } = applyRayleighFading(globalTxWaveformPreChannel);
                globalRxWaveformPostChannel = addAwgn(fadedSignal, snrDb);

                globalRxNoCP = removeCyclicPrefix(globalRxWaveformPostChannel, cpLength, nFFTSize);
                globalRxFFTOutput = fft(globalRxNoCP);
                
                const channelGainsNoCP = channelGains.slice(cpLength, cpLength + nFFTSize);
                globalChannelGainsFFT = fft(channelGainsNoCP);
                globalReceivedSymbols = equalize(globalRxFFTOutput, globalChannelGainsFFT);

                // Update charts once at the beginning
                updateTransmittedConstellationChart(globalModulatedSymbols);
                updateReceivedConstellationChart(globalReceivedSymbols);

                const preChannelPadded = [...globalTxWaveformPreChannel];
                if (preChannelPadded.length < fftLengthForSpectrum) {
                    preChannelPadded.push(...Array(fftLengthForSpectrum - preChannelPadded.length).fill(new Complex(0)));
                } else if (preChannelPadded.length > fftLengthForSpectrum) {
                    preChannelPadded.length = fftLengthForSpectrum;
                }
                const preChannelSpectrumFFT = fft(preChannelPadded);
                const preChannelPsd = preChannelSpectrumFFT.map(c => Math.max(c.magSq(), 1e-12));
                const preChannelPsd_db = fftshift(preChannelPsd).map(val => {
                    const dbVal = linearToDb(val);
                    return isFinite(dbVal) ? Math.max(dbVal, -100) : -100;
                });

                const postChannelPadded = [...globalRxWaveformPostChannel];
                if (postChannelPadded.length < fftLengthForSpectrum) {
                    postChannelPadded.push(...Array(fftLengthForSpectrum - postChannelPadded.length).fill(new Complex(0)));
                } else if (postChannelPadded.length > fftLengthForSpectrum) {
                    postChannelPadded.length = fftLengthForSpectrum;
                }
                const postChannelSpectrumFFT = fft(postChannelPadded);
                const postChannelPsd = postChannelSpectrumFFT.map(c => Math.max(c.magSq(), 1e-12));
                const postChannelPsd_db = fftshift(postChannelPsd).map(val => {
                    const dbVal = linearToDb(val);
                    return isFinite(dbVal) ? Math.max(dbVal, -100) : -100;
                });

                currentBlockIndex = 0;
                highlightBlock(currentBlockIndex);
                document.getElementById('nextBlockBtn').disabled = false;
                document.getElementById('prevBlockBtn').disabled = true;

            } catch (error) {
                console.error("Step-by-step simulation error:", error);
                displayError(`Step-by-step simulation failed: ${error.message}. Please check inputs.`);
            } finally {
                document.getElementById('loadingSpinner').style.display = 'none';
            }
        }

        async function runBerSimulation() {
            document.getElementById('loadingSpinner').style.display = 'block';
            document.getElementById('errorMessage').style.display = 'none';

            const nFFTSize = parseInt(document.getElementById('nFFTSize').value);
            const numSubcarriers = parseInt(document.getElementById('numSubcarriers').value);
            const modulationScheme = document.getElementById('modulationScheme').value;
            const cpLength = parseInt(document.getElementById('cpLength').value);
            const numSymbolsBer = parseInt(document.getElementById('numSymbolsBer').value);

            let bitsPerSymbol;
            switch (modulationScheme) {
                case 'BPSK': bitsPerSymbol = 1; break;
                case 'QPSK': bitsPerSymbol = 2; break;
                case '16QAM': bitsPerSymbol = 4; break;
                default: displayError('Invalid modulation scheme selected.'); document.getElementById('loadingSpinner').style.display = 'none'; return;
            }
            const numBitsPerOFDMSymbol = numSubcarriers * bitsPerSymbol;
            const snrRangeDb = Array.from({ length: 26 }, (_, i) => i);
            const berResults = [];

            try {
                for (const snr of snrRangeDb) {
                    let totalErrorsForThisSNR = 0;
                    let totalBitsForThisSNR = 0;

                    for (let s = 0; s < numSymbolsBer; s++) {
                        const originalBits = generateBits(numBitsPerOFDMSymbol);
                        const modulatedSymbols = modulate(originalBits, modulationScheme, bitsPerSymbol);
                        const ifftInput = mapToSubcarriers(modulatedSymbols, nFFTSize, numSubcarriers);
                        const ifftOutput = ifft(ifftInput);
                        const txWaveform = addCyclicPrefix(ifftOutput, cpLength);
                        
                        const rxWaveform = addAwgn(txWaveform, snr);
                        
                        const rxNoCP = removeCyclicPrefix(rxWaveform, cpLength, nFFTSize);
                        const rxFFT = fft(rxNoCP);

                        const dataSubcarrierIndices = [];
                        if (nFFTSize === 64 && numSubcarriers === 52) {
                             const subcarrierIndices80211a = [-26, -25, -24, -23, -22, -21, -20, -19, -18, -17, -16, -15, -14, -13, -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1,
                                                              1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26];
                            for (const scIdx of subcarrierIndices80211a) {
                                let arrayIdx = scIdx > 0 ? scIdx : nFFTSize + scIdx;
                                dataSubcarrierIndices.push(arrayIdx);
                            }
                        } else {
                            const halfSubcarriers = Math.floor(numSubcarriers / 2);
                            for (let i = 1; i <= halfSubcarriers; i++) { dataSubcarrierIndices.push(i); }
                            for (let i = nFFTSize - halfSubcarriers; i < nFFTSize; i++) { dataSubcarrierIndices.push(i); }
                        }
                        
                        const receivedDataSymbols = dataSubcarrierIndices.map(idx => rxFFT[idx]);
                        const receivedBits = demodulate(receivedDataSymbols, modulationScheme);

                        let bitErrorsForSymbol = 0;
                        for (let i = 0; i < originalBits.length; i++) {
                            if (originalBits[i] !== receivedBits[i]) {
                                bitErrorsForSymbol++;
                            }
                        }
                        totalErrorsForThisSNR += bitErrorsForSymbol;
                        totalBitsForThisSNR += originalBits.length;
                    }
                    
                    const ber = totalBitsForThisSNR > 0 ? totalErrorsForThisSNR / totalBitsForThisSNR : 0;
                    berResults.push(Math.max(ber, 1e-6));
                }

                updateBerChart(snrRangeDb, berResults);
                hideStepByStepCharts();
                showOutputChart('berCurveChart');
                document.getElementById('blockOutputTitle').textContent = "BER Simulation Result";
                document.getElementById('blockOutputDisplay').innerHTML = `BER simulation completed. The BER curve shows the system's performance across different Signal-to-Noise Ratios (SNR). A lower BER indicates better performance.`;
                document.getElementById('nextBlockBtn').disabled = true;
                document.getElementById('prevBlockBtn').disabled = true;

            } catch (error) {
                console.error("BER simulation error:", error);
                displayError(`BER simulation failed: ${error.message}. Please check inputs.`);
            } finally {
                document.getElementById('loadingSpinner').style.display = 'none';
            }
        }
        
        // --- Block Diagram Navigation ---
        const allOfdmBlockIds = ['block-tx', 'block-idft', 'block-addcp', 'block-channel', 'block-removecp', 'block-fft', 'block-rx'];
        const blockOutputTitles = [
            'S/P & Mapping Output',
            'IDFT Output',
            'Add CP Output',
            'Channel Output',
            'Remove CP Output',
            'FFT Output',
            'Demapping & P/S Output'
        ];
        let currentBlockIndex = 0;

        function highlightBlock(index) {
            const nextBtn = document.getElementById('nextBlockBtn');
            const prevBtn = document.getElementById('prevBlockBtn');
            nextBtn.disabled = (index === allOfdmBlockIds.length - 1);
            prevBtn.disabled = (index === 0);

            allOfdmBlockIds.forEach(id => {
                const block = document.getElementById(id);
                if (block) block.classList.remove('highlighted');
                const text = block.querySelector('.ofdm-block-text');
                if (text) text.classList.remove('highlighted');
            });
            
            // Highlight arrows
            document.querySelectorAll('.arrow').forEach(arrow => arrow.classList.remove('highlighted'));

            if (index >= 0 && index < allOfdmBlockIds.length) {
                const currentBlockElement = document.getElementById(allOfdmBlockIds[index]);
                if (currentBlockElement) {
                    currentBlockElement.classList.add('highlighted');
                    currentBlockElement.querySelectorAll('.ofdm-block-text').forEach(t => t.classList.add('highlighted'));
                }
                if (index > 0) {
                    const prevArrowId = getArrowId(index - 1, index);
                    document.getElementById(prevArrowId)?.classList.add('highlighted');
                }
            }

            updateChartVisibility(index);
            updateBlockOutputDisplayContent(index);
        }
        
        function getArrowId(fromIndex, toIndex) {
            if (fromIndex === 0 && toIndex === 1) return 'tx-to-idft';
            if (fromIndex === 1 && toIndex === 2) return 'idft-to-addcp';
            if (fromIndex === 2 && toIndex === 3) return 'tx-to-channel';
            if (fromIndex === 3 && toIndex === 4) return 'channel-to-rx';
            if (fromIndex === 4 && toIndex === 5) return 'removecp-to-dft';
            if (fromIndex === 5 && toIndex === 6) return 'dft-to-demapping';
            return '';
        }

        function hideStepByStepCharts() {
            document.getElementById('constellationChart').style.display = 'none';
            document.getElementById('preChannelSpectrumChart').style.display = 'none';
            document.getElementById('postChannelSpectrumChart').style.display = 'none';
            document.getElementById('constellationChartTitle').style.display = 'none';
            document.getElementById('preChannelSpectrumChartTitle').style.display = 'none';
            document.getElementById('postChannelSpectrumChartTitle').style.display = 'none';
        }

        function showOutputChart(chartId) {
            hideOutputCharts();
            document.getElementById(chartId).style.display = 'block';
            document.getElementById(`${chartId}Title`).style.display = 'block';
        }

        function hideOutputCharts() {
            document.getElementById('receivedConstellationChart').style.display = 'none';
            document.getElementById('berCurveChart').style.display = 'none';
            document.getElementById('receivedConstellationChartTitle').style.display = 'none';
            document.getElementById('berCurveChartTitle').style.display = 'none';
        }

        function updateChartVisibility(blockIndex) {
            hideStepByStepCharts();
            hideOutputCharts();
            switch (allOfdmBlockIds[blockIndex]) {
                case 'block-tx':
                    showChart('constellationChart');
                    break;
                case 'block-addcp':
                    showChart('preChannelSpectrumChart');
                    break;
                case 'block-channel':
                    showChart('postChannelSpectrumChart');
                    break;
                case 'block-rx':
                    showChart('receivedConstellationChart');
                    break;
            }
        }
        function showChart(chartId) {
            document.getElementById(chartId).style.display = 'block';
            document.getElementById(`${chartId}Title`).style.display = 'block';
        }


        function updateBlockOutputDisplayContent(blockIndex) {
            const titleDiv = document.getElementById('blockOutputTitle');
            const displayDiv = document.getElementById('blockOutputDisplay');
            titleDiv.textContent = blockOutputTitles[blockIndex];

            const nFFTSize = parseInt(document.getElementById('nFFTSize').value);
            const cpLength = parseInt(document.getElementById('cpLength').value);
            let content = "Run a simulation to see the step-by-step output here.";

            switch (allOfdmBlockIds[blockIndex]) {
                case 'block-tx':
                    if (globalTransmittedBits.length) {
                        content = `**1. S/P + Mapping (Transmitter)**\n\n`
                                + `Generated Bits: ${formatBitArrayForDisplay(globalTransmittedBits)}\n`
                                + `Modulated Symbols (first 5): ${formatComplexArrayForDisplay(globalModulatedSymbols)}`;
                    }
                    break;
                case 'block-idft':
                    if (globalTxWaveformPreChannel.length) {
                        content = `**2. IDFT (Inverse Discrete Fourier Transform)**\n\n`
                                + `This block converts the frequency-domain symbols into a time-domain signal. The output is a series of samples that represent the superposition of all subcarriers.\n\n`
                                + `IDFT Output (first 5 samples): ${formatComplexArrayForDisplay(globalTxWaveformPreChannel.slice(cpLength))}`;
                    }
                    break;
                case 'block-addcp':
                    if (globalTxWaveformPreChannel.length) {
                        content = `**3. Add CP (Cyclic Prefix)**\n\n`
                                + `A cyclic prefix is a copy of the end of the IDFT output appended to the beginning of the signal. This helps mitigate Inter-Symbol Interference (ISI) caused by channel multipath. The total length is now ${nFFTSize} (IDFT) + ${cpLength} (CP) = ${nFFTSize + cpLength} samples.\n\n`
                                + `Signal with CP (first 5 samples): ${formatComplexArrayForDisplay(globalTxWaveformPreChannel)}`;
                    }
                    break;
                case 'block-channel':
                    if (globalRxWaveformPostChannel.length) {
                        content = `**4. Channel**\n\n`
                                + `The signal propagates through a simulated channel, where it is affected by Rayleigh fading (multipath effects) and Additive White Gaussian Noise (AWGN). This degrades the signal quality.\n\n`
                                + `Signal After Channel (first 5 noisy samples): ${formatComplexArrayForDisplay(globalRxWaveformPostChannel)}`;
                    }
                    break;
                case 'block-removecp':
                    if (globalRxNoCP.length) {
                        content = `**5. Remove CP (Cyclic Prefix)**\n\n`
                                + `The receiver removes the cyclic prefix, keeping only the main OFDM symbol part. This discards the noisy prefix and ensures the signal is of the correct length for the FFT.\n\n`
                                + `Signal After CP Removal (first 5 samples): ${formatComplexArrayForDisplay(globalRxNoCP)}`;
                    }
                    break;
                case 'block-fft':
                    if (globalRxFFTOutput.length) {
                        content = `**6. FFT (Fast Fourier Transform)**\n\n`
                                + `This block converts the time-domain signal back into the frequency domain, separating the individual subcarriers. The output contains the received symbols for each subcarrier.\n\n`
                                + `FFT Output (first 5 frequency-domain symbols): ${formatComplexArrayForDisplay(globalRxFFTOutput)}`;
                    }
                    break;
                case 'block-rx':
                    if (globalReceivedSymbols.length) {
                        const modulationScheme = document.getElementById('modulationScheme').value;
                        const demodulatedBits = demodulate(globalReceivedSymbols, modulationScheme);
                        const ber = calculateBer(globalTransmittedBits, demodulatedBits).toExponential(2);
                        content = `**7. Demapping + P/S (Demodulation & Parallel-to-Serial)**\n\n`
                                + `The received symbols are decoded back into a bitstream. The constellation points are mapped to the closest ideal points to recover the original bits. A Bit Error Rate (BER) is then calculated.\n\n`
                                + `Demodulated Bits (first 20): ${formatBitArrayForDisplay(demodulatedBits)}\n`
                                + `Calculated BER: ${ber}`;
                    }
                    break;
            }
            displayDiv.innerHTML = content;
        }

        function clearAllChartData() {
            const charts = [constellationChart, preChannelSpectrumChart, postChannelSpectrumChart, receivedConstellationChart, berCurveChart];
            charts.forEach(chart => {
                if (chart) {
                    chart.data.labels = [];
                    chart.data.datasets.forEach(dataset => { dataset.data = []; });
                    chart.update();
                }
            });
        }

        function resetSimulation() {
            clearAllChartData();
            hideStepByStepCharts();
            hideOutputCharts();

            currentBlockIndex = 0;
            highlightBlock(currentBlockIndex);
            
            document.getElementById('errorMessage').style.display = 'none';
            document.getElementById('loadingSpinner').style.display = 'none';
            document.getElementById('blockOutputTitle').textContent = "Simulation Step Output";
            document.getElementById('blockOutputDisplay').innerHTML = "Run a simulation to see the step-by-step output here.";

            document.getElementById('nFFTSize').value = 64;
            document.getElementById('numSubcarriers').value = 52;
            document.getElementById('modulationScheme').value = 'BPSK';
            document.getElementById('cpLength').value = 16;
            document.getElementById('snrDb').value = 20;
            document.getElementById('numSymbolsBer').value = 1000;
        }

        // --- Chart.js Setup and Update Functions (kept as-is) ---
        let constellationChart, preChannelSpectrumChart, postChannelSpectrumChart, receivedConstellationChart, berCurveChart;

        function initializeCharts() {
            const constellationConfig = {
                type: 'scatter', data: { datasets: [{ label: 'Transmitted Constellation', data: [], backgroundColor: 'rgb(236, 72, 153)', pointRadius: 5, pointHoverRadius: 7 }] },
                options: { responsive: true, maintainAspectRatio: false, plugins: { title: { display: false }, legend: { display: false }, tooltip: { callbacks: { label: c => `(${c.parsed.x.toFixed(2)}, ${c.parsed.y.toFixed(2)}i)` } } },
                scales: { x: { type: 'linear', position: 'bottom', title: { display: true, text: 'In-phase (Real)', font: { size: 14, weight: 'bold' }, color: '#4b5563' }, grid: { color: '#e5e7eb' }, ticks: { color: '#6b7280' }, min: -2, max: 2 },
                y: { type: 'linear', position: 'left', title: { display: true, text: 'Quadrature (Imaginary)', font: { size: 14, weight: 'bold' }, color: '#4b5563' }, grid: { color: '#e5e7eb' }, ticks: { color: '#6b7280' }, min: -2, max: 2 } } }
            };
            const spectrumConfig = {
                type: 'line', data: { datasets: [{ data: [], borderWidth: 2, pointRadius: 0, fill: false, tension: 0.1 }] },
                options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false } },
                scales: { x: { title: { display: true, text: 'Frequency (MHz)', font: { size: 14, weight: 'bold' }, color: '#4b5563' }, grid: { color: '#e2e8f0' } },
                y: { title: { display: true, text: 'Power Spectral Density (dB)', font: { size: 14, weight: 'bold' }, color: '#4b5563' }, grid: { color: '#e2e8f0' } } } }
            };
            const berConfig = {
                type: 'line', data: { labels: [], datasets: [{ label: 'BER', data: [], borderColor: 'rgb(34, 197, 94)', backgroundColor: 'rgba(34, 197, 94, 0.2)', borderWidth: 2, pointRadius: 3, pointBackgroundColor: 'rgb(34, 197, 94)', fill: false, tension: 0.1 }] },
                options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false } },
                scales: { x: { min: 0, max: 25, title: { display: true, text: 'SNR (dB)', font: { size: 14, weight: 'bold' }, color: '#4b5563' } },
                y: { type: 'logarithmic', title: { display: true, text: 'BER', font: { size: 14, weight: 'bold' }, color: '#4b5563' }, min: 1e-6, max: 1,
                ticks: { callback: v => (v === 1e-1 || v === 1e-2 || v === 1e-3 || v === 1e-4 || v === 1e-5 || v === 1e-6) ? v.toExponential() : null } } } }
            };
            
            constellationChart = new Chart(document.getElementById('constellationChart').getContext('2d'), constellationConfig);
            preChannelSpectrumChart = new Chart(document.getElementById('preChannelSpectrumChart').getContext('2d'), { ...spectrumConfig, data: { datasets: [{ ...spectrumConfig.data.datasets[0], borderColor: 'rgb(59, 130, 246)', backgroundColor: 'rgba(59, 130, 246, 0.2)' }] } });
            postChannelSpectrumChart = new Chart(document.getElementById('postChannelSpectrumChart').getContext('2d'), { ...spectrumConfig, data: { datasets: [{ ...spectrumConfig.data.datasets[0], borderColor: 'rgb(234, 88, 12)', backgroundColor: 'rgba(234, 88, 12, 0.2)' }] } });
            receivedConstellationChart = new Chart(document.getElementById('receivedConstellationChart').getContext('2d'), { ...constellationConfig, data: { datasets: [{ ...constellationConfig.data.datasets[0], label: 'Received Constellation', backgroundColor: 'rgb(34, 197, 94)' }] } });
            berCurveChart = new Chart(document.getElementById('berCurveChart').getContext('2d'), berConfig);
        }

        function updateSpectrumChart(chartInstance, labels, data) {
            if (chartInstance) {
                // Filter out invalid values and limit range
                const validIndices = [];
                const validLabels = [];
                const validData = [];
                
                for (let i = 0; i < data.length; i++) {
                    const value = data[i];
                    if (isFinite(value) && !isNaN(value) && value > -200 && value < 100) {
                        validIndices.push(i);
                        validLabels.push(parseFloat(labels[i]).toFixed(2));
                        validData.push(value);
                    }
                }
                
                chartInstance.data.labels = validLabels;
                chartInstance.data.datasets[0].data = validData;
                chartInstance.update();
            }
        }

        function updateTransmittedConstellationChart(symbols) {
            if (constellationChart) {
                const validData = symbols.filter(s => 
                    isFinite(s.re) && isFinite(s.im) && 
                    Math.abs(s.re) < 10 && Math.abs(s.im) < 10
                ).map(s => ({ x: s.re, y: s.im }));
                
                constellationChart.data.datasets[0].data = validData;
                constellationChart.update();
            }
        }

        function updateReceivedConstellationChart(symbols) {
            if (receivedConstellationChart) {
                const validData = symbols.filter(s => 
                    isFinite(s.re) && isFinite(s.im) && 
                    Math.abs(s.re) < 10 && Math.abs(s.im) < 10
                ).map(s => ({ x: s.re, y: s.im }));
                
                receivedConstellationChart.data.datasets[0].data = validData;
                receivedConstellationChart.update();
            }
        }
        function updateBerChart(snrLabels, berData) {
            if (berCurveChart) {
                berCurveChart.data.labels = snrLabels;
                berCurveChart.data.datasets[0].data = berData;
                berCurveChart.update();
            }
        }
        function displayError(message) {
            const errorMessageDiv = document.getElementById('errorMessage');
            errorMessageDiv.textContent = message;
            errorMessageDiv.style.display = 'block';
            document.getElementById('loadingSpinner').style.display = 'none';
        }

        // --- Event Listeners ---
        window.onload = function() {
            initializeCharts();
            document.getElementById('runStepByStepBtn').addEventListener('click', runStepByStepSimulation);
            document.getElementById('runBerSimBtn').addEventListener('click', runBerSimulation);
            document.getElementById('resetBtn').addEventListener('click', resetSimulation);
            document.getElementById('nextBlockBtn').addEventListener('click', () => {
                if (currentBlockIndex < allOfdmBlockIds.length - 1) {
                    currentBlockIndex++;
                    highlightBlock(currentBlockIndex);
                }
            });
            document.getElementById('prevBlockBtn').addEventListener('click', () => {
                if (currentBlockIndex > 0) {
                    currentBlockIndex--;
                    highlightBlock(currentBlockIndex);
                }
            });
            resetSimulation();
        };
    </script>
</body>
</html>