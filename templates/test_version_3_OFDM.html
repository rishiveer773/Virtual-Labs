<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced OFDM Virtual Experiment</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.0/chart.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        
        :root {
            --primary-blue: #2563eb;
            --primary-blue-dark: #1d4ed8;
            --primary-blue-light: #3b82f6;
            --secondary-gray: #64748b;
            --bg-gray: #f8fafc;
            --border-gray: #e2e8f0;
            --text-primary: #1e293b;
            --text-secondary: #475569;
            --success-green: #10b981;
            --error-red: #ef4444;
            --warning-orange: #f59e0b;
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            font-size: 14px;
            line-height: 1.6;
        }

        .main-container {
            max-width: 1800px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.15);
            overflow: hidden;
            display: grid;
            grid-template-columns: 320px 1fr 380px;
            min-height: 700px;
        }

        @media (max-width: 1400px) {
            .main-container {
                grid-template-columns: 300px 1fr 340px;
            }
        }

        @media (max-width: 1200px) {
            .main-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto auto;
            }
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            .main-container {
                border-radius: 15px;
            }
        }

        .section-header {
            background: linear-gradient(135deg, var(--primary-blue) 0%, var(--primary-blue-dark) 100%);
            color: white;
            padding: 24px;
            text-align: center;
            font-size: 18px;
            font-weight: 600;
            letter-spacing: 0.5px;
        }

        /* Input Section Styles */
        .input-section {
            border-right: 2px solid var(--border-gray);
            background: #fafbfc;
        }

        @media (max-width: 1200px) {
            .input-section {
                border-right: none;
                border-bottom: 2px solid var(--border-gray);
            }
        }

        .input-container {
            padding: 24px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .input-label {
            font-weight: 500;
            color: var(--text-primary);
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .input-field {
            padding: 12px 16px;
            border: 2px solid var(--border-gray);
            border-radius: 10px;
            font-size: 14px;
            font-weight: 500;
            color: var(--text-primary);
            background: white;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .input-field:focus {
            outline: none;
            border-color: var(--primary-blue);
            box-shadow: 0 0 0 4px rgba(37, 99, 235, 0.1);
            transform: translateY(-1px);
        }

        .btn {
            padding: 14px 20px;
            border: none;
            border-radius: 12px;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--primary-blue) 0%, var(--primary-blue-dark) 100%);
            color: white;
            box-shadow: 0 6px 20px rgba(37, 99, 235, 0.3);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(37, 99, 235, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(135deg, var(--secondary-gray) 0%, #475569 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(100, 116, 139, 0.3);
        }

        .btn-secondary:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 20px rgba(100, 116, 139, 0.4);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Loading Spinner */
        .loading-container {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f4f6;
            border-top: 4px solid var(--primary-blue);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Alert Messages */
        .alert {
            padding: 16px;
            border-radius: 10px;
            margin-top: 16px;
            font-weight: 500;
            display: none;
        }

        .alert-error {
            background: #fef2f2;
            border: 2px solid #fca5a5;
            color: #dc2626;
        }

        .alert-success {
            background: #f0fdf4;
            border: 2px solid #86efac;
            color: #16a34a;
        }

        /* Simulation Area */
        .simulation-section {
            display: flex;
            flex-direction: column;
        }

        .block-diagram-area {
            padding: 30px;
            background: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 24px;
        }

        .diagram-container {
            background: #f8fafc;
            border-radius: 15px;
            padding: 20px;
            border: 2px solid var(--border-gray);
            width: 100%;
            max-width: 600px;
            overflow-x: auto;
        }

        .ofdm-block {
            fill: #e0e7ff;
            stroke: var(--primary-blue);
            stroke-width: 2.5;
            filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.1));
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .ofdm-block.active {
            fill: #93c5fd;
            stroke: var(--primary-blue-dark);
            stroke-width: 3.5;
            transform: scale(1.05);
            filter: drop-shadow(4px 4px 8px rgba(0,0,0,0.2));
        }

        .block-text {
            font-family: 'Inter', sans-serif;
            font-size: 12px;
            font-weight: 600;
            fill: var(--text-primary);
            text-anchor: middle;
            dominant-baseline: central;
            pointer-events: none;
        }

        .block-text.active {
            font-weight: 700;
            font-size: 13px;
        }

        .connection-arrow {
            stroke: var(--secondary-gray);
            stroke-width: 2.5;
            fill: none;
            marker-end: url(#arrowhead);
            transition: all 0.3s ease;
        }

        .connection-arrow.active {
            stroke: var(--primary-blue-dark);
            stroke-width: 3;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .arrowhead {
            fill: var(--secondary-gray);
            transition: fill 0.3s ease;
        }

        .connection-arrow.active + .arrowhead,
        marker.active .arrowhead {
            fill: var(--primary-blue-dark);
        }

        /* Navigation Controls */
        .nav-controls {
            display: flex;
            gap: 12px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .nav-controls .btn {
            min-width: 140px;
        }

        /* Info Panel */
        .info-panel {
            background: #f8fafc;
            border-top: 2px solid var(--border-gray);
            padding: 24px;
            flex-grow: 1;
        }

        .step-info {
            background: white;
            border-radius: 12px;
            padding: 20px;
            border: 2px solid var(--border-gray);
            margin-bottom: 20px;
        }

        .step-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .step-content {
            color: var(--text-secondary);
            line-height: 1.6;
            white-space: pre-wrap;
            font-size: 13px;
        }

        /* Symbol Blocks */
        .symbol-display {
            display: flex;
            flex-wrap: wrap;
            gap: 3px;
            justify-content: center;
            margin-top: 12px;
            padding: 12px;
            background: #f8fafc;
            border-radius: 8px;
            border: 1px solid var(--border-gray);
            max-height: 120px;
            overflow-y: auto;
        }

        .symbol-item {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            font-weight: 600;
            border: 1.5px solid;
        }

        .symbol-item.data {
            background: #dbeafe;
            border-color: var(--primary-blue);
            color: var(--text-primary);
        }

        .symbol-item.cp {
            background: #fed7d7;
            border-color: var(--error-red);
            color: var(--error-red);
        }

        /* Charts Area */
        .charts-container {
            padding: 20px;
            background: white;
        }

        .chart-wrapper {
            background: #fafbfc;
            border-radius: 12px;
            padding: 16px;
            border: 2px solid var(--border-gray);
            margin-bottom: 16px;
            position: relative;
            width: 100%;
            height: 350px;
        }

        .chart-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            text-align: center;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .chart-canvas {
            max-width: 100% !important;
            height: 300px !important;
            border-radius: 8px;
        }

        /* Results Section */
        .results-section {
            border-left: 2px solid var(--border-gray);
            background: #fafbfc;
            display: flex;
            flex-direction: column;
        }

        @media (max-width: 1200px) {
            .results-section {
                border-left: none;
                border-top: 2px solid var(--border-gray);
            }
        }

        .results-container {
            padding: 24px;
            flex-grow: 1;
        }

        .metric-card {
            background: white;
            border-radius: 12px;
            padding: 16px;
            border: 2px solid var(--border-gray);
            margin-bottom: 16px;
            text-align: center;
        }

        .metric-label {
            font-size: 12px;
            font-weight: 500;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }

        .metric-value {
            font-size: 20px;
            font-weight: 700;
            color: var(--text-primary);
        }

        .channel-info {
            background: white;
            border-radius: 12px;
            padding: 16px;
            border: 2px solid var(--border-gray);
            margin-bottom: 16px;
        }

        .channel-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 8px;
            text-align: center;
        }

        .channel-data {
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 11px;
            color: var(--text-secondary);
            text-align: center;
            word-break: break-all;
            line-height: 1.4;
        }

        /* Add to existing styles */
        .symbol-display {
            display: flex;
            flex-wrap: wrap;
            gap: 2px;
            justify-content: center;
            align-items: center;
            margin-top: 12px;
            padding: 12px;
            background: #f8fafc;
            border-radius: 8px;
            border: 1px solid var(--border-gray);
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Monaco', 'Menlo', monospace;
        }

        .symbol-item {
            min-width: 45px;
            height: 28px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: 600;
            border: 1.5px solid;
            white-space: nowrap;
            text-overflow: ellipsis;
            overflow: hidden;
            position: relative;
        }

        .symbol-item.data {
            background: #dbeafe;
            border-color: var(--primary-blue);
            color: var(--text-primary);
        }

        .symbol-item.cp {
            background: #fed7d7;
            border-color: var(--error-red);
            color: var(--error-red);
            font-weight: 700;
        }

        .symbol-item.ellipsis {
            background: #f1f5f9;
            border-color: var(--secondary-gray);
            color: var(--text-secondary);
            border-style: dashed;
            min-width: 30px;
        }

        .symbol-separator {
            font-size: 14px;
            color: var(--text-secondary);
            margin: 0 4px;
            font-weight: bold;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .section-header {
                font-size: 16px;
                padding: 16px;
            }
            
            .input-container,
            .results-container {
                padding: 16px;
            }
            
            .block-diagram-area {
                padding: 16px;
            }
            
            .nav-controls .btn {
                min-width: 120px;
                font-size: 12px;
            }
        }

        /* Accessibility */
        .btn:focus,
        .input-field:focus {
            outline: 3px solid rgba(37, 99, 235, 0.5);
            outline-offset: 2px;
        }

        /* Performance Optimizations */
        .chart-canvas {
            image-rendering: -webkit-optimize-contrast;
            image-rendering: optimize-contrast;
        }

        /* Hide/Show utilities */
        .hidden {
            display: none !important;
        }

        .visible {
            display: block !important;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="input-section">
            <div class="section-header">
                Simulation Parameters
            </div>
            <div class="input-container">
                <div class="input-group">
                    <label class="input-label" for="fftSize">FFT Size (N)</label>
                    <input type="number" id="fftSize" class="input-field" value="64" min="16" max="2048" step="16">
                </div>
                
                <div class="input-group">
                    <label class="input-label" for="dataSubcarriers">Data Subcarriers</label>
                    <input type="number" id="dataSubcarriers" class="input-field" value="52" min="4" max="1024" step="4">
                </div>
                
                <div class="input-group">
                    <label class="input-label" for="modulation">Modulation</label>
                    <select id="modulation" class="input-field">
                        <option value="BPSK">BPSK</option>
                        <option value="QPSK">QPSK</option>
                        <option value="16QAM">16-QAM</option>
                        <option value="64QAM">64-QAM</option>
                    </select>
                </div>
                
                <div class="input-group">
                    <label class="input-label" for="cpLength">Cyclic Prefix</label>
                    <input type="number" id="cpLength" class="input-field" value="16" min="4" max="256" step="4">
                </div>
                
                <div class="input-group">
                    <label class="input-label" for="snrDb">SNR (dB)</label>
                    <input type="number" id="snrDb" class="input-field" value="20" min="-10" max="50" step="1">
                </div>
                
                <div class="input-group">
                    <label class="input-label" for="equalization">Equalization</label>
                    <select id="equalization" class="input-field">
                        <option value="ZF">Zero-Forcing</option>
                        <option value="MMSE">MMSE</option>
                        <option value="MRC">Maximum Ratio Combining</option>
                    </select>
                </div>
                
                <div class="input-group">
                    <label class="input-label" for="channelTaps">Channel Taps</label>
                    <input type="number" id="channelTaps" class="input-field" value="5" min="1" max="20" step="1">
                </div>
                
                <button id="runSimulation" class="btn btn-primary">
                    Run Simulation
                </button>
                
                <button id="resetSimulation" class="btn btn-secondary">
                    Reset All
                </button>
                
                <div id="loadingContainer" class="loading-container hidden">
                    <div class="loading-spinner"></div>
                </div>
                
                <div id="errorAlert" class="alert alert-error"></div>
                <div id="successAlert" class="alert alert-success"></div>
            </div>
        </div>

        <div class="simulation-section">
            <div class="section-header">
                OFDM System Block Diagram
            </div>
            
            <div class="block-diagram-area">
                <div class="diagram-container">
                    <svg id="blockDiagram" viewBox="0 0 580 320" style="width: 100%; height: auto;">
                        <defs>
                            <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" class="arrowhead" />
                            </marker>
                            <marker id="arrowhead-active" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto" class="active">
                                <polygon points="0 0, 10 3.5, 0 7" class="arrowhead" />
                            </marker>
                        </defs>

                        <rect id="block-mapping" class="ofdm-block" x="20" y="20" width="80" height="45" rx="8" ry="8"></rect>
                        <text class="block-text" x="60" y="35">S/P &</text>
                        <text class="block-text" x="60" y="50">Mapping</text>
                        
                        <line id="arrow-1" class="connection-arrow" x1="100" y1="42.5" x2="130" y2="42.5" />
                        
                        <rect id="block-ifft" class="ofdm-block" x="130" y="20" width="80" height="45" rx="8" ry="8"></rect>
                        <text class="block-text" x="170" y="42.5">IFFT</text>
                        
                        <line id="arrow-2" class="connection-arrow" x1="210" y1="42.5" x2="240" y2="42.5" />
                        
                        <rect id="block-addcp" class="ofdm-block" x="240" y="20" width="80" height="45" rx="8" ry="8"></rect>
                        <text class="block-text" x="280" y="42.5">Add CP</text>
                        
                        <line id="arrow-3" class="connection-arrow" x1="320" y1="42.5" x2="350" y2="42.5" />

                        <rect id="block-channel" class="ofdm-block" x="350" y="20" width="80" height="45" rx="8" ry="8"></rect>
                        <text class="block-text" x="390" y="42.5">Channel</text>
                        
                        <line id="arrow-4" class="connection-arrow" x1="430" y1="42.5" x2="460" y2="42.5" />
                        
                        <rect id="block-removecp" class="ofdm-block" x="460" y="20" width="80" height="45" rx="8" ry="8"></rect>
                        <text class="block-text" x="500" y="42.5">Remove CP</text>
                        
                        <line id="arrow-5" class="connection-arrow" x1="500" y1="65" x2="500" y2="95" />
                        
                        <rect id="block-fft" class="ofdm-block" x="460" y="95" width="80" height="45" rx="8" ry="8"></rect>
                        <text class="block-text" x="500" y="117.5">FFT</text>
                        
                        <line id="arrow-6" class="connection-arrow" x1="460" y1="117.5" x2="430" y2="117.5" />
                        
                        <rect id="block-equalizer" class="ofdm-block" x="350" y="95" width="80" height="45" rx="8" ry="8"></rect>
                        <text class="block-text" x="390" y="117.5">Equalizer</text>
                        
                        <line id="arrow-7" class="connection-arrow" x1="350" y1="117.5" x2="320" y2="117.5" />
                        
                        <rect id="block-demapping" class="ofdm-block" x="240" y="95" width="80" height="45" rx="8" ry="8"></rect>
                        <text class="block-text" x="280" y="110">Demap &</text>
                        <text class="block-text" x="280" y="125">P/S</text>
                    </svg>
                </div>
                
                <div class="nav-controls">
                    <button id="prevStep" class="btn btn-secondary" disabled>Previous Step</button>
                    <button id="nextStep" class="btn btn-primary" disabled>Next Step</button>
                    <button id="autoPlay" class="btn btn-primary" disabled>Auto Play</button>
                </div>
            </div>
            
            <div class="info-panel">
                <div class="step-info">
                    <div class="step-title" id="stepTitle">
                        Welcome to OFDM Simulator
                    </div>
                    <div class="step-content" id="stepContent">
                        Configure the simulation parameters and click "Run Simulation" to begin the step-by-step OFDM process demonstration.
                    </div>
                    <div id="symbolDisplay" class="symbol-display hidden"></div>
                </div>
                
                <div class="charts-container">
                    <div id="chartContainer" class="chart-wrapper hidden">
                        <div class="chart-title" id="chartTitle">Chart</div>
                        <canvas id="mainChart" class="chart-canvas"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <div class="results-section">
            <div class="section-header">
                Simulation Results
            </div>
            
            <div class="results-container">
                <div class="metric-card">
                    <div class="metric-label">Bit Error Rate</div>
                    <div class="metric-value" id="berValue">-</div>
                </div>
                
                <div class="metric-card">
                    <div class="metric-label">Symbol Error Rate</div>
                    <div class="metric-value" id="serValue">-</div>
                </div>
                
                <div class="metric-card">
                    <div class="metric-label">EVM (dB)</div>
                    <div class="metric-value" id="evmValue">-</div>
                </div>
                
                <div id="channelInfo" class="channel-info hidden">
                    <div class="channel-title">Channel Response</div>
                    <div class="channel-data" id="channelData">-</div>
                </div>
                
                <div class="chart-wrapper">
                    <div class="chart-title">Received Constellation</div>
                    <canvas id="constellationChart" class="chart-canvas"></canvas>
                </div>
                
                <div class="chart-wrapper">
                    <div class="chart-title">Channel Frequency Response</div>
                    <canvas id="channelChart" class="chart-canvas"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Enhanced OFDM Simulator with improved architecture
        class ComplexNumber {
            constructor(real, imag = 0) {
                this.real = real;
                this.imag = imag;
            }
            
            static fromPolar(magnitude, phase) {
                return new ComplexNumber(
                    magnitude * Math.cos(phase),
                    magnitude * Math.sin(phase)
                );
            }
            
            add(other) {
                return new ComplexNumber(this.real + other.real, this.imag + other.imag);
            }
            
            subtract(other) {
                return new ComplexNumber(this.real - other.real, this.imag - other.imag);
            }
            
            multiply(other) {
                if (typeof other === 'number') {
                    return new ComplexNumber(this.real * other, this.imag * other);
                }
                return new ComplexNumber(
                    this.real * other.real - this.imag * other.imag,
                    this.real * other.imag + this.imag * other.real
                );
            }
            
            divide(other) {
                if (typeof other === 'number') {
                    return new ComplexNumber(this.real / other, this.imag / other);
                }
                const denominator = other.real * other.real + other.imag * other.imag;
                if (denominator === 0) return new ComplexNumber(Infinity, Infinity);
                
                return new ComplexNumber(
                    (this.real * other.real + this.imag * other.imag) / denominator,
                    (this.imag * other.real - this.real * other.imag) / denominator
                );
            }
            
            conjugate() {
                return new ComplexNumber(this.real, -this.imag);
            }
            
            magnitude() {
                return Math.sqrt(this.real * this.real + this.imag * this.imag);
            }
            
            magnitudeSquared() {
                return this.real * this.real + this.imag * this.imag;
            }
            
            phase() {
                return Math.atan2(this.imag, this.real);
            }
            
            toString() {
                if (this.imag === 0) return this.real.toFixed(3);
                if (this.real === 0) return `${this.imag.toFixed(3)}i`;
                const sign = this.imag >= 0 ? '+' : '';
                return `${this.real.toFixed(3)}${sign}${this.imag.toFixed(3)}i`;
            }
        }

        class DSPUtils {
            static fft(signal) {
                const N = signal.length;
                if (N <= 1) return signal;
                
                if (N & (N - 1)) {
                    // Not a power of 2, use DFT as fallback
                    return this.dft(signal);
                }
                
                const even = [];
                const odd = [];
                for (let i = 0; i < N / 2; i++) {
                    even[i] = signal[i * 2];
                    odd[i] = signal[i * 2 + 1];
                }
                
                const evenFFT = this.fft(even);
                const oddFFT = this.fft(odd);
                const result = new Array(N);
                
                for (let k = 0; k < N / 2; k++) {
                    const twiddle = ComplexNumber.fromPolar(1, -2 * Math.PI * k / N);
                    const t = twiddle.multiply(oddFFT[k]);
                    result[k] = evenFFT[k].add(t);
                    result[k + N / 2] = evenFFT[k].subtract(t);
                }
                
                return result;
            }
            
            static ifft(spectrum) {
                const N = spectrum.length;
                const conjugated = spectrum.map(c => c.conjugate());
                const result = this.fft(conjugated);
                return result.map(c => c.conjugate().divide(N));
            }
            
            static dft(signal) {
                const N = signal.length;
                const result = new Array(N);
                
                for (let k = 0; k < N; k++) {
                    result[k] = new ComplexNumber(0, 0);
                    for (let n = 0; n < N; n++) {
                        const angle = -2 * Math.PI * k * n / N;
                        const twiddle = ComplexNumber.fromPolar(1, angle);
                        result[k] = result[k].add(signal[n].multiply(twiddle));
                    }
                }
                return result;
            }
            
            static fftShift(array) {
                const mid = Math.floor(array.length / 2);
                return [...array.slice(mid), ...array.slice(0, mid)];
            }
            
            static generateGaussianNoise() {
                let u = 0, v = 0;
                while (u === 0) u = Math.random();
                while (v === 0) v = Math.random();
                return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
            }
            
            static dbToLinear(db) {
                return Math.pow(10, db / 10);
            }
            
            static linearToDb(linear) {
                if (linear <= 0 || !isFinite(linear)) return -100;
                return 10 * Math.log10(linear);
            }
        }

        class ModulationSchemes {
            static getConstellationPoints(scheme) {
                switch (scheme) {
                    case 'BPSK':
                        return [new ComplexNumber(-1, 0), new ComplexNumber(1, 0)];
                    
                    case 'QPSK':
                        const scale = 1 / Math.sqrt(2);
                        return [
                            new ComplexNumber(-scale, -scale),
                            new ComplexNumber(-scale, scale),
                            new ComplexNumber(scale, -scale),
                            new ComplexNumber(scale, scale)
                        ];
                    
                    case '16QAM':
                        const scale16 = 1 / Math.sqrt(10);
                        const levels = [-3, -1, 1, 3];
                        const points = [];
                        for (const i of levels) {
                            for (const q of levels) {
                                points.push(new ComplexNumber(i * scale16, q * scale16));
                            }
                        }
                        return points;
                    
                    case '64QAM':
                        const scale64 = 1 / Math.sqrt(42);
                        const levels64 = [-7, -5, -3, -1, 1, 3, 5, 7];
                        const points64 = [];
                        for (const i of levels64) {
                            for (const q of levels64) {
                                points64.push(new ComplexNumber(i * scale64, q * scale64));
                            }
                        }
                        return points64;
                    
                    default:
                        return [];
                }
            }
            
            static getBitsPerSymbol(scheme) {
                switch (scheme) {
                    case 'BPSK': return 1;
                    case 'QPSK': return 2;
                    case '16QAM': return 4;
                    case '64QAM': return 6;
                    default: return 1;
                }
            }
            
            static modulate(bits, scheme) {
                const constellation = this.getConstellationPoints(scheme);
                const bitsPerSymbol = this.getBitsPerSymbol(scheme);
                const symbols = [];
                
                for (let i = 0; i < bits.length; i += bitsPerSymbol) {
                    let index = 0;
                    for (let j = 0; j < bitsPerSymbol && i + j < bits.length; j++) {
                        index = (index << 1) | bits[i + j];
                    }
                    if (index < constellation.length) {
                        symbols.push(constellation[index]);
                    }
                }
                return symbols;
            }
            
            static demodulate(symbols, scheme) {
                const constellation = this.getConstellationPoints(scheme);
                const bitsPerSymbol = this.getBitsPerSymbol(scheme);
                const bits = [];
                
                for (const symbol of symbols) {
                    let minDistance = Infinity;
                    let closestIndex = 0;
                    
                    for (let i = 0; i < constellation.length; i++) {
                        const distance = symbol.subtract(constellation[i]).magnitudeSquared();
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestIndex = i;
                        }
                    }
                    
                    // Convert index to bits
                    for (let j = bitsPerSymbol - 1; j >= 0; j--) {
                        bits.push((closestIndex >> j) & 1);
                    }
                }
                return bits;
            }
        }

        class ChannelModel {
            static generateRayleighChannel(numTaps) {
                const taps = [];
                for (let i = 0; i < numTaps; i++) {
                    const real = DSPUtils.generateGaussianNoise() / Math.sqrt(2);
                    const imag = DSPUtils.generateGaussianNoise() / Math.sqrt(2);
                    taps.push(new ComplexNumber(real, imag));
                }
                
                // Normalize channel power
                const totalPower = taps.reduce((sum, tap) => sum + tap.magnitudeSquared(), 0);
                const normFactor = Math.sqrt(1 / totalPower);
                return taps.map(tap => tap.multiply(normFactor));
            }
            
            static convolve(signal, channel) {
                const N = signal.length;
                const L = channel.length;
                const output = new Array(N + L - 1).fill(0).map(() => new ComplexNumber(0, 0));
                
                for (let i = 0; i < N; i++) {
                    for (let j = 0; j < L; j++) {
                        output[i + j] = output[i + j].add(signal[i].multiply(channel[j]));
                    }
                }
                return output.slice(0, N); // Return same length as input
            }
            
            static addAwgn(signal, snrDb) {
                const signalPower = signal.reduce((sum, s) => sum + s.magnitudeSquared(), 0) / signal.length;
                const snrLinear = DSPUtils.dbToLinear(snrDb);
                const noisePower = signalPower / snrLinear;
                const noiseStd = Math.sqrt(noisePower / 2);
                
                return signal.map(s => {
                    const noiseReal = DSPUtils.generateGaussianNoise() * noiseStd;
                    const noiseImag = DSPUtils.generateGaussianNoise() * noiseStd;
                    return s.add(new ComplexNumber(noiseReal, noiseImag));
                });
            }
        }

        class OFDMSystem {
            constructor(params) {
                this.fftSize = params.fftSize;
                this.dataSubcarriers = params.dataSubcarriers;
                this.modulation = params.modulation;
                this.cpLength = params.cpLength;
                this.snrDb = params.snrDb;
                this.equalization = params.equalization;
                this.channelTaps = params.channelTaps;
                
                this.reset();
            }
            
            reset() {
                this.transmittedBits = [];
                this.modulatedSymbols = [];
                this.ifftOutput = [];
                this.cpAddedSignal = [];
                this.channelOutput = [];
                this.receivedSignal = [];
                this.cpRemovedSignal = [];
                this.fftOutput = [];
                this.equalizedSymbols = [];
                this.demodulatedBits = [];
                this.channelTapsComplex = [];
                this.channelFreqResponse = [];
                this.currentStep = -1;
            }
            
            generateBits() {
                const bitsPerSymbol = ModulationSchemes.getBitsPerSymbol(this.modulation);
                const totalBits = this.dataSubcarriers * bitsPerSymbol;
                this.transmittedBits = Array.from({length: totalBits}, () => Math.round(Math.random()));
                return this.transmittedBits;
            }
            
            performModulation() {
                this.modulatedSymbols = ModulationSchemes.modulate(this.transmittedBits, this.modulation);
                return this.modulatedSymbols;
            }
            
            mapToSubcarriers() {
                const input = new Array(this.fftSize).fill(0).map(() => new ComplexNumber(0, 0));
                
                // Standard OFDM subcarrier mapping
                let symbolIndex = 0;
                const dcIndex = Math.floor(this.fftSize / 2);
                const usedSubcarriers = Math.min(this.dataSubcarriers, this.fftSize - 1);
                
                // Map to positive frequencies
                for (let i = 1; i <= Math.floor(usedSubcarriers / 2) && symbolIndex < this.modulatedSymbols.length; i++) {
                    if (i !== dcIndex) {
                        input[i] = this.modulatedSymbols[symbolIndex++];
                    }
                }
                
                // Map to negative frequencies
                for (let i = this.fftSize - Math.floor(usedSubcarriers / 2); i < this.fftSize && symbolIndex < this.modulatedSymbols.length; i++) {
                    if (i !== dcIndex) {
                        input[i] = this.modulatedSymbols[symbolIndex++];
                    }
                }
                
                return input;
            }
            
            performIFFT() {
                const mappedSymbols = this.mapToSubcarriers();
                this.ifftOutput = DSPUtils.ifft(mappedSymbols);
                return this.ifftOutput;
            }
            
            addCyclicPrefix() {
                const cp = this.ifftOutput.slice(-this.cpLength);
                this.cpAddedSignal = [...cp, ...this.ifftOutput];
                return this.cpAddedSignal;
            }
            
            passThroughChannel() {
                // Generate channel
                this.channelTapsComplex = ChannelModel.generateRayleighChannel(this.channelTaps);
                
                // Convolve with channel
                const convolvedSignal = ChannelModel.convolve(this.cpAddedSignal, this.channelTapsComplex);
                
                // Add AWGN
                this.channelOutput = ChannelModel.addAwgn(convolvedSignal, this.snrDb);
                
                // Calculate channel frequency response
                const channelPadded = [...this.channelTapsComplex];
                while (channelPadded.length < this.fftSize) {
                    channelPadded.push(new ComplexNumber(0, 0));
                }
                this.channelFreqResponse = DSPUtils.fft(channelPadded);
                
                return this.channelOutput;
            }
            
            removeCyclicPrefix() {
                this.cpRemovedSignal = this.channelOutput.slice(this.cpLength, this.cpLength + this.fftSize);
                return this.cpRemovedSignal;
            }
            
            performFFT() {
                this.fftOutput = DSPUtils.fft(this.cpRemovedSignal);
                return this.fftOutput;
            }
            
            performEqualization() {
                const dataIndices = this.getDataSubcarrierIndices();
                this.equalizedSymbols = [];
                
                for (const idx of dataIndices) {
                    const receivedSymbol = this.fftOutput[idx];
                    const channelGain = this.channelFreqResponse[idx];
                    let equalizedSymbol;
                    
                    switch (this.equalization) {
                        case 'ZF':
                            equalizedSymbol = receivedSymbol.divide(channelGain);
                            break;
                        case 'MMSE':
                            const snrLinear = DSPUtils.dbToLinear(this.snrDb);
                            const channelMagSq = channelGain.magnitudeSquared();
                            const mmseWeight = channelGain.conjugate().divide(channelMagSq + 1/snrLinear);
                            equalizedSymbol = receivedSymbol.multiply(mmseWeight);
                            break;
                        case 'MRC':
                            const mrcWeight = channelGain.conjugate();
                            equalizedSymbol = receivedSymbol.multiply(mrcWeight);
                            break;
                        default:
                            equalizedSymbol = receivedSymbol;
                    }
                    
                    this.equalizedSymbols.push(equalizedSymbol);
                }
                
                return this.equalizedSymbols;
            }
            
            performDemodulation() {
                this.demodulatedBits = ModulationSchemes.demodulate(this.equalizedSymbols, this.modulation);
                return this.demodulatedBits;
            }
            
            getDataSubcarrierIndices() {
                const indices = [];
                const dcIndex = Math.floor(this.fftSize / 2);
                const usedSubcarriers = Math.min(this.dataSubcarriers, this.fftSize - 1);
                
                // Positive frequencies
                for (let i = 1; i <= Math.floor(usedSubcarriers / 2); i++) {
                    if (i !== dcIndex) indices.push(i);
                }
                
                // Negative frequencies
                for (let i = this.fftSize - Math.floor(usedSubcarriers / 2); i < this.fftSize; i++) {
                    if (i !== dcIndex) indices.push(i);
                }
                
                return indices.slice(0, this.dataSubcarriers);
            }
            
            calculateMetrics() {
                const minLength = Math.min(this.transmittedBits.length, this.demodulatedBits.length);
                let bitErrors = 0;
                let symbolErrors = 0;
                
                // BER calculation
                for (let i = 0; i < minLength; i++) {
                    if (this.transmittedBits[i] !== this.demodulatedBits[i]) {
                        bitErrors++;
                    }
                }
                
                // SER calculation
                const bitsPerSymbol = ModulationSchemes.getBitsPerSymbol(this.modulation);
                const numSymbols = Math.floor(minLength / bitsPerSymbol);
                for (let i = 0; i < numSymbols; i++) {
                    let symbolError = false;
                    for (let j = 0; j < bitsPerSymbol; j++) {
                        const bitIndex = i * bitsPerSymbol + j;
                        if (bitIndex < minLength && this.transmittedBits[bitIndex] !== this.demodulatedBits[bitIndex]) {
                            symbolError = true;
                            break;
                        }
                    }
                    if (symbolError) symbolErrors++;
                }
                
                // EVM calculation
                let totalError = 0;
                let totalPower = 0;
                const originalSymbols = ModulationSchemes.modulate(this.transmittedBits, this.modulation);
                
                for (let i = 0; i < Math.min(originalSymbols.length, this.equalizedSymbols.length); i++) {
                    const error = this.equalizedSymbols[i].subtract(originalSymbols[i]);
                    totalError += error.magnitudeSquared();
                    totalPower += originalSymbols[i].magnitudeSquared();
                }
                
                const ber = minLength > 0 ? bitErrors / minLength : 0;
                const ser = numSymbols > 0 ? symbolErrors / numSymbols : 0;
                const evm = totalPower > 0 ? Math.sqrt(totalError / totalPower) : 0;
                const evmDb = evm > 0 ? DSPUtils.linearToDb(evm) : -100;
                
                // Store for BER curve if needed
                this.metrics = { ber, ser, evm: evmDb, bitErrors, totalBits: minLength };
                
                return { ber, ser, evm: evmDb };
            }

            // Add BER curve generation method to OFDMSystem class
            generateBERCurve(snrRange = [-5, 0, 5, 10, 15, 20, 25, 30], numTrials = 100) {
                const berResults = [];
                const originalSNR = this.snrDb;
                
                for (const snr of snrRange) {
                    this.snrDb = snr;
                    let totalBitErrors = 0;
                    let totalBits = 0;
                    
                    for (let trial = 0; trial < numTrials; trial++) {
                        this.reset();
                        this.generateBits();
                        this.performModulation();
                        this.performIFFT();
                        this.addCyclicPrefix();
                        this.passThroughChannel();
                        this.removeCyclicPrefix();
                        this.performFFT();
                        this.performEqualization();
                        this.performDemodulation();
                        
                        const metrics = this.calculateMetrics();
                        totalBitErrors += metrics.bitErrors || 0;
                        totalBits += metrics.totalBits || 0;
                    }
                    
                    const ber = totalBits > 0 ? totalBitErrors / totalBits : 0;
                    berResults.push({ snr, ber });
                    console.log(`SNR: ${snr} dB, BER: ${ber.toExponential(3)}`);
                }
                
                this.snrDb = originalSNR; // Restore original SNR
                return berResults;
            }


        class SimulationUI {
            constructor() {
                this.ofdmSystem = null;
                this.charts = {};
                this.currentStep = -1;
                this.isAutoPlaying = false;
                this.autoPlayInterval = null;
                
                this.steps = [
                    { id: 'block-mapping', title: 'Serial to Parallel & Symbol Mapping', description: 'Convert input bit stream to parallel data and map to constellation points' },
                    { id: 'block-ifft', title: 'Inverse Fast Fourier Transform', description: 'Transform frequency domain symbols to time domain signal' },
                    { id: 'block-addcp', title: 'Add Cyclic Prefix', description: 'Prepend cyclic prefix to prevent inter-symbol interference' },
                    { id: 'block-channel', title: 'Multipath Channel', description: 'Signal passes through fading channel with noise' },
                    { id: 'block-removecp', title: 'Remove Cyclic Prefix', description: 'Remove cyclic prefix from received signal' },
                    { id: 'block-fft', title: 'Fast Fourier Transform', description: 'Transform time domain signal back to frequency domain' },
                    { id: 'block-equalizer', title: 'Channel Equalization', description: 'Compensate for channel distortion using selected algorithm' },
                    { id: 'block-demapping', title: 'Symbol Demapping & Parallel to Serial', description: 'Recover original bit stream from equalized symbols' }
                ];
                
                this.initializeEventListeners();
                this.initializeCharts();
            }
            
            initializeEventListeners() {
                document.getElementById('runSimulation').addEventListener('click', () => this.runSimulation());
                document.getElementById('resetSimulation').addEventListener('click', () => this.resetSimulation());
                document.getElementById('prevStep').addEventListener('click', () => this.previousStep());
                document.getElementById('nextStep').addEventListener('click', () => this.nextStep());
                document.getElementById('autoPlay').addEventListener('click', () => this.toggleAutoPlay());
                
                // Parameter change listeners for real-time validation
                const inputs = ['fftSize', 'dataSubcarriers', 'modulation', 'cpLength', 'snrDb', 'equalization', 'channelTaps'];
                inputs.forEach(id => {
                    document.getElementById(id).addEventListener('change', () => this.validateParameters());
                });
            }
            
            initializeCharts() {
                // Ensure canvases exist and are properly sized
                const mainCanvas = document.getElementById('mainChart');
                const constCanvas = document.getElementById('constellationChart');
                const channelCanvas = document.getElementById('channelChart');
                
                if (!mainCanvas || !constCanvas || !channelCanvas) {
                    console.error('Chart canvases not found');
                    return;
                }
                
                const commonOptions = {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: {
                        duration: 300
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    }
                };
                
                // Main chart
                this.charts.main = new Chart(mainCanvas.getContext('2d'), {
                    type: 'scatter',
                    data: { 
                        datasets: [{
                            label: 'No Data',
                            data: [],
                            backgroundColor: '#3b82f6'
                        }]
                    },
                    options: {
                        ...commonOptions,
                        scales: {
                            x: {
                                type: 'linear',
                                title: { display: true, text: 'In-Phase' }
                            },
                            y: {
                                type: 'linear',
                                title: { display: true, text: 'Quadrature' }
                            }
                        }
                    }
                });
                
                // Constellation chart
                this.charts.constellation = new Chart(constCanvas.getContext('2d'), {
                    type: 'scatter',
                    data: { 
                        datasets: [{
                            label: 'No Data',
                            data: [],
                            backgroundColor: '#3b82f6'
                        }]
                    },
                    options: {
                        ...commonOptions,
                        scales: {
                            x: {
                                type: 'linear',
                                title: { display: true, text: 'In-Phase' }
                            },
                            y: {
                                type: 'linear',
                                title: { display: true, text: 'Quadrature' }
                            }
                        }
                    }
                });
                
                // Channel response chart
                this.charts.channel = new Chart(channelCanvas.getContext('2d'), {
                    type: 'line',
                    data: { 
                        datasets: [{
                            label: 'No Data',
                            data: [],
                            borderColor: '#f59e0b'
                        }]
                    },
                    options: {
                        ...commonOptions,
                        scales: {
                            x: {
                                type: 'linear',
                                title: { display: true, text: 'Subcarrier Index' }
                            },
                            y: {
                                type: 'linear',
                                title: { display: true, text: 'Magnitude (dB)' }
                            }
                        }
                    }
                });
                
                console.log('Charts initialized:', this.charts);
            }
            
            // 1. Fix the hideError method in validateParameters()
            validateParameters() {
                const fftSize = parseInt(document.getElementById('fftSize').value);
                const dataSubcarriers = parseInt(document.getElementById('dataSubcarriers').value);
                
                if (dataSubcarriers >= fftSize) {
                    this.showError('Number of data subcarriers must be less than FFT size');
                    return false;
                }
                
                if (fftSize < 16 || (fftSize & (fftSize - 1)) !== 0) {
                    this.showError('FFT size must be a power of 2 and at least 16');
                    return false;
                }
                
                // Fix: Change hideError to hideAlerts
                this.hideAlerts();
                return true;
            }
            
            // 3. Fix the runSimulation method to properly enable navigation
            async runSimulation() {
                console.log('Starting simulation...');
                
                if (!this.validateParameters()) return;
                
                this.showLoading();
                
                try {
                    const params = this.getSimulationParameters();
                    console.log('Simulation parameters:', params);
                    
                    this.ofdmSystem = new OFDMSystem(params);
                    
                    // Run simulation steps
                    console.log('Generating bits...');
                    this.ofdmSystem.generateBits();
                    console.log('Generated bits:', this.ofdmSystem.transmittedBits.length);
                    
                    console.log('Performing modulation...');
                    this.ofdmSystem.performModulation();
                    console.log('Modulated symbols:', this.ofdmSystem.modulatedSymbols.length);
                    
                    // Continue with other steps
                    this.ofdmSystem.performIFFT();
                    this.ofdmSystem.addCyclicPrefix();
                    this.ofdmSystem.passThroughChannel();
                    this.ofdmSystem.removeCyclicPrefix();
                    this.ofdmSystem.performFFT();
                    this.ofdmSystem.performEqualization();
                    this.ofdmSystem.performDemodulation();
                    
                    // Update results
                    const metrics = this.ofdmSystem.calculateMetrics();
                    this.updateResults(metrics);
                    this.updateResultsCharts();
                    
                    this.currentStep = -1;
                    this.updateNavigationButtons();
                    
                    this.showSuccess('Simulation completed successfully. Use Next Step to begin visualization.');
                    
                } catch (error) {
                    console.error('Simulation failed:', error);
                    this.showError(`Simulation failed: ${error.message}`);
                } finally {
                    this.hideLoading();
                }
            }
            
            async performCompleteSimulation() {
                // Simulate processing delay for better UX
                await new Promise(resolve => setTimeout(resolve, 100));
                
                this.ofdmSystem.generateBits();
                this.ofdmSystem.performModulation();
                this.ofdmSystem.performIFFT();
                this.ofdmSystem.addCyclicPrefix();
                this.ofdmSystem.passThroughChannel();
                this.ofdmSystem.removeCyclicPrefix();
                this.ofdmSystem.performFFT();
                this.ofdmSystem.performEqualization();
                this.ofdmSystem.performDemodulation();
                
                // Update results
                const metrics = this.ofdmSystem.calculateMetrics();
                this.updateResults(metrics);
                this.updateResultsCharts();
            }
            
            getSimulationParameters() {
                return {
                    fftSize: parseInt(document.getElementById('fftSize').value),
                    dataSubcarriers: parseInt(document.getElementById('dataSubcarriers').value),
                    modulation: document.getElementById('modulation').value,
                    cpLength: parseInt(document.getElementById('cpLength').value),
                    snrDb: parseFloat(document.getElementById('snrDb').value),
                    equalization: document.getElementById('equalization').value,
                    channelTaps: parseInt(document.getElementById('channelTaps').value)
                };
            }
            
            // 4. Fix the nextStep method to handle initial state
            nextStep() {
                if (this.currentStep < this.steps.length - 1) {
                    this.currentStep++;
                    this.updateVisualization();
                    this.updateNavigationButtons();
                }
            }
            
            previousStep() {
                if (this.currentStep > 0) {
                    this.currentStep--;
                    this.updateVisualization();
                    this.updateNavigationButtons();
                }
            }
            
            updateVisualization() {
                if (!this.ofdmSystem) return;
                
                // Clear all highlights
                this.steps.forEach(step => {
                    const element = document.getElementById(step.id);
                    if (element) element.classList.remove('active');
                    
                    const text = element?.querySelectorAll('.block-text');
                    if (text) text.forEach(t => t.classList.remove('active'));
                });
                
                // Clear all arrows
                document.querySelectorAll('.connection-arrow').forEach(arrow => {
                    arrow.classList.remove('active');
                });
                
                // Highlight current step
                if (this.currentStep >= 0) {
                    const currentStepInfo = this.steps[this.currentStep];
                    const element = document.getElementById(currentStepInfo.id);
                    if (element) {
                        element.classList.add('active');
                        const text = element.querySelectorAll('.block-text');
                        text.forEach(t => t.classList.add('active'));
                    }
                    
                    // Highlight connecting arrow
                    if (this.currentStep > 0) {
                        const arrow = document.getElementById(`arrow-${this.currentStep}`);
                        if (arrow) arrow.classList.add('active');
                    }
                    
                    // Update step information
                    this.updateStepInfo(this.currentStep);
                    this.updateMainChart(this.currentStep);
                }
            }
            
            // Fix the updateStepInfo method to properly handle receiver side steps
            updateStepInfo(stepIndex) {
                const step = this.steps[stepIndex];
                document.getElementById('stepTitle').textContent = `Step ${stepIndex + 1}: ${step.title}`;
                
                let content = step.description + '\n\n';
                let showSymbols = false;
                let symbolData = [];
                
                switch (stepIndex) {
                    case 0: // Mapping
                        content += `Generated ${this.ofdmSystem.transmittedBits.length} random bits\n`;
                        content += `Modulated to ${this.ofdmSystem.modulatedSymbols.length} ${this.ofdmSystem.modulation} symbols`;
                        showSymbols = true;
                        symbolData = this.formatSymbolDisplay(
                            this.ofdmSystem.modulatedSymbols.map((s, i) => ({ 
                                value: s, 
                                label: `X[${i}]`, 
                                type: 'data' 
                            }))
                        );
                        break;
                        
                    case 1: // IFFT
                        content += `Transformed ${this.ofdmSystem.fftSize} frequency domain samples\n`;
                        content += `to ${this.ofdmSystem.ifftOutput.length} time domain samples`;
                        showSymbols = true;
                        symbolData = this.formatSymbolDisplay(
                            this.ofdmSystem.ifftOutput.map((s, i) => ({ 
                                value: s, 
                                label: `x[${i}]`, 
                                type: 'data' 
                            }))
                        );
                        break;
                        
                    case 2: // Add CP
                        content += `Added cyclic prefix of length ${this.ofdmSystem.cpLength}\n`;
                        content += `Total signal length: ${this.ofdmSystem.cpAddedSignal.length}`;
                        showSymbols = true;
                        const M = this.ofdmSystem.ifftOutput.length;
                        const L = this.ofdmSystem.cpLength;
                        // Format: | x[M-L] | ... | x[M-1] | x[0] | x[1] | ... | x[M-1] |
                        symbolData = this.formatCPSymbolDisplay(this.ofdmSystem.cpAddedSignal, M, L);
                        break;
                        
                    case 3: // Channel
                        content += `Channel taps: ${this.ofdmSystem.channelTaps}\n`;
                        content += `SNR: ${this.ofdmSystem.snrDb} dB\n`;
                        content += `Signal affected by multipath fading and AWGN\n`;
                        content += `Output signal length: ${this.ofdmSystem.channelOutput.length}`;
                        showSymbols = true;
                        symbolData = this.formatSymbolDisplay(
                            this.ofdmSystem.channelOutput.slice(0, Math.min(50, this.ofdmSystem.channelOutput.length))
                                .map((s, i) => ({ 
                                    value: s, 
                                    label: `y[${i}]`, 
                                    type: 'data' 
                                }))
                        );
                        break;
                        
                    case 4: // Remove CP
                        content += `Removed ${this.ofdmSystem.cpLength} cyclic prefix samples\n`;
                        content += `Remaining signal length: ${this.ofdmSystem.cpRemovedSignal.length}\n`;
                        content += `Ready for FFT processing`;
                        showSymbols = true;
                        symbolData = this.formatSymbolDisplay(
                            this.ofdmSystem.cpRemovedSignal.map((s, i) => ({ 
                                value: s, 
                                label: `r[${i}]`, 
                                type: 'data' 
                            }))
                        );
                        break;
                        
                    case 5: // FFT
                        content += `Transformed ${this.ofdmSystem.cpRemovedSignal.length} time domain samples\n`;
                        content += `back to ${this.ofdmSystem.fftOutput.length} frequency domain samples\n`;
                        content += `Extracted data from subcarriers`;
                        showSymbols = true;
                        const dataIndices = this.ofdmSystem.getDataSubcarrierIndices();
                        symbolData = this.formatSymbolDisplay(
                            dataIndices.map(idx => ({ 
                                value: this.ofdmSystem.fftOutput[idx], 
                                label: `R[${idx}]`, 
                                type: 'data' 
                            }))
                        );
                        break;
                        
                    case 6: // Equalization
                        content += `Applied ${this.ofdmSystem.equalization} equalization\n`;
                        content += `Recovered ${this.ofdmSystem.equalizedSymbols.length} data symbols\n`;
                        // Calculate preliminary metrics
                        const tempDemodBits = ModulationSchemes.demodulate(this.ofdmSystem.equalizedSymbols, this.ofdmSystem.modulation);
                        const tempErrors = tempDemodBits.slice(0, this.ofdmSystem.transmittedBits.length)
                            .filter((bit, i) => bit !== this.ofdmSystem.transmittedBits[i]).length;
                        content += `Preliminary bit errors: ${tempErrors}`;
                        showSymbols = true;
                        symbolData = this.formatSymbolDisplay(
                            this.ofdmSystem.equalizedSymbols.map((s, i) => ({ 
                                value: s, 
                                label: `X[${i}]`, 
                                type: 'data' 
                            }))
                        );
                        break;
                        
                    case 7: // Demapping
                        const metrics = this.ofdmSystem.calculateMetrics();
                        content += `Demodulated ${this.ofdmSystem.demodulatedBits.length} bits\n`;
                        content += `Original bits: ${this.ofdmSystem.transmittedBits.length}\n`;
                        content += `Bit Error Rate: ${metrics.ber.toExponential(2)}\n`;
                        content += `Symbol Error Rate: ${metrics.ser.toExponential(2)}\n`;
                        content += `EVM: ${metrics.evm.toFixed(2)} dB`;
                        showSymbols = true;
                        // Show first few bits comparison
                        const maxBits = 20;
                        const bitComparison = [];
                        for (let i = 0; i < Math.min(maxBits, this.ofdmSystem.transmittedBits.length); i++) {
                            const txBit = this.ofdmSystem.transmittedBits[i];
                            const rxBit = this.ofdmSystem.demodulatedBits[i];
                            const isCorrect = txBit === rxBit;
                            bitComparison.push({
                                value: rxBit,
                                label: `${txBit}${rxBit}`,
                                type: isCorrect ? 'data' : 'cp'
                            });
                        }
                        symbolData = bitComparison;
                        break;
                }
                
                document.getElementById('stepContent').textContent = content;
                
                // Update symbol display
                this.updateSymbolDisplay(showSymbols, symbolData);
            }

            // Add new helper methods to SimulationUI class
            formatSymbolDisplay(symbols) {
                if (symbols.length <= 10) {
                    return symbols;
                }
                
                // Show first 3, ellipsis, and last 1
                return [
                    ...symbols.slice(0, 3),
                    { label: '...', type: 'ellipsis' },
                    symbols[symbols.length - 1]
                ];
            }

            formatCPSymbolDisplay(cpAddedSignal, M, L) {
                const result = [];
                
                // Add CP part: x[M-L] ... x[M-1]
                if (L > 3) {
                    result.push({ label: `x[${M-L}]`, type: 'cp', value: cpAddedSignal[0] });
                    result.push({ label: '...', type: 'ellipsis' });
                    result.push({ label: `x[${M-1}]`, type: 'cp', value: cpAddedSignal[L-1] });
                } else {
                    for (let i = 0; i < L; i++) {
                        result.push({ label: `x[${M-L+i}]`, type: 'cp', value: cpAddedSignal[i] });
                    }
                }
                
                // Add separator
                result.push({ label: '|', type: 'separator' });
                
                // Add data part: x[0] ... x[M-1]
                if (M > 6) {
                    result.push({ label: 'x[0]', type: 'data', value: cpAddedSignal[L] });
                    result.push({ label: 'x[1]', type: 'data', value: cpAddedSignal[L+1] });
                    result.push({ label: '...', type: 'ellipsis' });
                    result.push({ label: `x[${M-1}]`, type: 'data', value: cpAddedSignal[cpAddedSignal.length-1] });
                } else {
                    for (let i = 0; i < M; i++) {
                        result.push({ label: `x[${i}]`, type: 'data', value: cpAddedSignal[L+i] });
                    }
                }
                
                return result;
            }

            updateSymbolDisplay(showSymbols, symbolData) {
                const symbolDisplay = document.getElementById('symbolDisplay');
                
                if (showSymbols && symbolData.length > 0) {
                    symbolDisplay.innerHTML = '';
                    symbolDisplay.classList.remove('hidden');
                    
                    symbolData.forEach((symbol, i) => {
                        if (symbol.type === 'separator') {
                            const separator = document.createElement('div');
                            separator.className = 'symbol-separator';
                            separator.textContent = symbol.label;
                            symbolDisplay.appendChild(separator);
                        } else {
                            const item = document.createElement('div');
                            item.className = `symbol-item ${symbol.type}`;
                            item.textContent = symbol.label;
                            
                            // Add tooltip with value if available
                            if (symbol.value) {
                                if (typeof symbol.value === 'object' && symbol.value.toString) {
                                    item.title = `${symbol.label}: ${symbol.value.toString()}`;
                                } else {
                                    item.title = `${symbol.label}: ${symbol.value}`;
                                }
                            }
                            
                            symbolDisplay.appendChild(item);
                        }
                    });
                } else {
                    symbolDisplay.classList.add('hidden');
                }
            }
            
            // Enhanced updateMainChart method with receiver side visualizations
            updateMainChart(stepIndex) {
                console.log('updateMainChart called with step:', stepIndex);
                
                const chartContainer = document.getElementById('chartContainer');
                const chartTitle = document.getElementById('chartTitle');
                const data = this.ofdmSystem;
                
                if (!data) {
                    console.log('No OFDM system data');
                    return;
                }
                
                console.log('OFDM data available:', Object.keys(data));
                
                let datasets = [];
                
                try {
                    switch (stepIndex) {
                        case 0: // Mapping
                            console.log('Processing mapping step');
                            if (data.modulatedSymbols && data.modulatedSymbols.length > 0) {
                                console.log('Modulated symbols count:', data.modulatedSymbols.length);
                                console.log('First few symbols:', data.modulatedSymbols.slice(0, 3));
                                
                                const symbolData = data.modulatedSymbols.map((c, index) => {
                                    console.log(`Symbol ${index}:`, c.real, c.imag);
                                    return { x: c.real, y: c.imag };
                                });
                                
                                datasets = [{
                                    label: 'Transmitted Symbols',
                                    data: symbolData,
                                    backgroundColor: '#3b82f6',
                                    borderColor: '#3b82f6',
                                    pointRadius: 8,
                                    pointHoverRadius: 10,
                                    showLine: false
                                }];
                                
                                chartTitle.textContent = 'Transmitted Constellation Diagram';
                                chartContainer.classList.remove('hidden');
                                console.log('Dataset created:', datasets);
                            } else {
                                console.log('No modulated symbols available');
                            }
                            break;
                    }
                    
                    if (datasets.length > 0 && this.charts.main) {
                        console.log('Updating chart with datasets:', datasets);
                        this.charts.main.data.datasets = datasets;
                        this.charts.main.update('active');
                        console.log('Chart updated successfully');
                    } else {
                        console.log('No datasets to update or chart not available');
                    }
                    
                } catch (error) {
                    console.error('Chart update error:', error);
                    console.error('Error stack:', error.stack);
                }
            }
            
            updateResults(metrics) {
                document.getElementById('berValue').textContent = metrics.ber.toExponential(2);
                document.getElementById('serValue').textContent = metrics.ser.toExponential(2);
                document.getElementById('evmValue').textContent = metrics.evm.toFixed(2);
            }
            
            // 6. Fix CSS variable references in updateResultsCharts
            // Fix the updateResultsCharts method with proper Chart.js format
updateResultsCharts() {
    if (!this.ofdmSystem) return;
    
    try {
        const data = this.ofdmSystem;
        
        // Update constellation chart
        if (data.equalizedSymbols && data.equalizedSymbols.length > 0) {
            const idealPoints = ModulationSchemes.getConstellationPoints(data.modulation);
            
            const datasets = [
                {
                    label: 'Ideal',
                    data: idealPoints.map(c => ({ x: c.real, y: c.imag })),
                    backgroundColor: '#000000',
                    pointStyle: 'rectRot',
                    pointRadius: 6,
                    showLine: false
                },
                {
                    label: 'Received',
                    data: data.equalizedSymbols.map(c => ({ x: c.real, y: c.imag })),
                    backgroundColor: 'rgba(16, 185, 129, 0.7)',
                    pointRadius: 4,
                    showLine: false
                }
            ];
            
            this.charts.constellation.data.datasets = datasets;
            this.charts.constellation.update('active');
        }
        
        // Update channel response chart
        if (data.channelFreqResponse && data.channelFreqResponse.length > 0) {
            const freqResponseDb = data.channelFreqResponse.map(c => {
                const mag = c.magnitude();
                return mag > 0 ? 20 * Math.log10(mag) : -100;
            });
            
            const shiftedResponse = DSPUtils.fftShift(freqResponseDb);
            const chartData = shiftedResponse.map((val, idx) => ({
                x: idx - Math.floor(data.fftSize / 2),
                y: val
            }));
            
            this.charts.channel.data.datasets = [{
                label: 'Channel Response',
                data: chartData,
                borderColor: '#f59e0b',
                backgroundColor: 'rgba(245, 158, 11, 0.1)',
                borderWidth: 2,
                fill: true,
                tension: 0.2
            }];
            
            this.charts.channel.update('active');
        }
        
    } catch (error) {
        console.error('Results chart update error:', error);
    }
}
            
            // 2. Fix the updateNavigationButtons method - enable nextStep after simulation
            updateNavigationButtons() {
                const prevBtn = document.getElementById('prevStep');
                const nextBtn = document.getElementById('nextStep');
                const autoPlayBtn = document.getElementById('autoPlay');
                
                if (this.ofdmSystem) {
                    prevBtn.disabled = this.currentStep <= 0;
                    // Fix: Enable next button when simulation is ready and not at last step
                    nextBtn.disabled = this.currentStep >= this.steps.length - 1;
                    autoPlayBtn.disabled = false;
                } else {
                    prevBtn.disabled = true;
                    nextBtn.disabled = true;
                    autoPlayBtn.disabled = true;
                }
            }
            
            toggleAutoPlay() {
                const autoPlayBtn = document.getElementById('autoPlay');
                if (this.isAutoPlaying) {
                    clearInterval(this.autoPlayInterval);
                    this.isAutoPlaying = false;
                    autoPlayBtn.textContent = 'Auto Play';
                } else {
                    this.isAutoPlaying = true;
                    autoPlayBtn.textContent = 'Pause';
                    this.autoPlayInterval = setInterval(() => {
                        if (this.currentStep < this.steps.length - 1) {
                            this.nextStep();
                        } else {
                            this.toggleAutoPlay();
                        }
                    }, 2000); // 2-second delay
                }
            }
            
            resetSimulation() {
                if (this.isAutoPlaying) this.toggleAutoPlay();
                this.ofdmSystem = null;
                this.currentStep = -1;
                this.updateNavigationButtons();
                this.hideAlerts();
                this.hideLoading();
                
                // Reset UI elements
                this.steps.forEach(step => {
                    const element = document.getElementById(step.id);
                    if (element) element.classList.remove('active');
                    const text = element?.querySelectorAll('.block-text');
                    if (text) text.forEach(t => t.classList.remove('active'));
                });
                document.querySelectorAll('.connection-arrow').forEach(arrow => arrow.classList.remove('active'));
                
                document.getElementById('stepTitle').textContent = 'Welcome to OFDM Simulator';
                document.getElementById('stepContent').textContent = 'Configure the simulation parameters and click "Run Simulation" to begin the step-by-step OFDM process demonstration.';
                document.getElementById('symbolDisplay').classList.add('hidden');
                document.getElementById('chartContainer').classList.add('hidden');
                document.getElementById('channelInfo').classList.add('hidden');
                
                document.getElementById('berValue').textContent = '-';
                document.getElementById('serValue').textContent = '-';
                document.getElementById('evmValue').textContent = '-';
                
                // Clear all chart data
                for (const chartKey in this.charts) {
                    if (this.charts[chartKey]) {
                        this.charts[chartKey].data.datasets = [];
                        this.charts[chartKey].update();
                    }
                }
            }
            
            showLoading() {
                document.getElementById('loadingContainer').classList.remove('hidden');
                document.getElementById('runSimulation').disabled = true;
                this.hideAlerts();
            }
            
            hideLoading() {
                document.getElementById('loadingContainer').classList.add('hidden');
                document.getElementById('runSimulation').disabled = false;
            }
            
            showError(message) {
                this.hideAlerts();
                const alert = document.getElementById('errorAlert');
                alert.textContent = message;
                alert.classList.remove('hidden');
            }
            
            showSuccess(message) {
                this.hideAlerts();
                const alert = document.getElementById('successAlert');
                alert.textContent = message;
                alert.classList.remove('hidden');
            }
            
            hideAlerts() {
                document.getElementById('errorAlert').classList.add('hidden');
                document.getElementById('successAlert').classList.add('hidden');
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            new SimulationUI();
        });
    </script>
</body>
</html>