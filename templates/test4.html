<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clarke's Flat Fading Model - Virtual Experiment</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }
        
        h1 {
            text-align: center;
            color: #4a5568;
            margin-bottom: 10px;
            font-size: 2.5em;
            font-weight: 300;
        }
        
        .subtitle {
            text-align: center;
            color: #718096;
            margin-bottom: 30px;
            font-size: 1.1em;
        }
        
        .controls-section {
            background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 30px;
            border: 1px solid #e2e8f0;
        }
        
        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .control-group {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }
        
        .control-group h3 {
            margin: 0 0 15px 0;
            color: #2d3748;
            font-size: 1.1em;
        }
        
        .input-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #4a5568;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #e2e8f0;
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }
        
        .value-display {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.9em;
            margin-left: 10px;
        }
        
        .update-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: 500;
            transition: all 0.3s ease;
            display: block;
            margin: 20px auto 0;
        }
        
        .update-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }
        
        .charts-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-top: 30px;
        }
        
        .chart-section {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.08);
        }
        
        .chart-title {
            font-size: 1.4em;
            color: #2d3748;
            margin-bottom: 20px;
            text-align: center;
            font-weight: 500;
        }
        
        .chart-container {
            position: relative;
            height: 400px;
        }
        
        .model-info {
            background: linear-gradient(135deg, #e6fffa 0%, #f0fff4 100%);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            border-left: 4px solid #48bb78;
        }
        
        .formula {
            background: #f7fafc;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            border: 1px solid #e2e8f0;
        }
        
        @media (max-width: 768px) {
            .charts-container {
                grid-template-columns: 1fr;
            }
            .controls-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Clarke's Flat Fading Model</h1>
        <p class="subtitle">Interactive Virtual Experiment for Mobile Channel Modeling</p>
        
        <div class="model-info">
            <h3>Model Description</h3>
            <p>Clarke's model simulates flat fading in mobile communications where a receiver moves through a field of scatterers. The model assumes K scattering paths with uniform angular distribution.</p>
            <div class="formula">
                <strong>Key Equations:</strong><br>
                Autocorrelation: R₀[n] = 2a²πJ₀(nπDᵥ/W)<br>
                Doppler Spectrum: S(f) = 4a²W / (π√(1-(2fW/Dᵥ)²)) for |f| ≤ Dᵥ/(2W)
            </div>
        </div>
        
        <div class="controls-section">
            <div class="controls-grid">
                <div class="control-group">
                    <h3>Signal Parameters</h3>
                    <div class="input-group">
                        <label for="amplitude">Amplitude (a): <span class="value-display" id="amplitudeValue">1.0</span></label>
                        <input type="range" id="amplitude" min="0.1" max="2.0" step="0.1" value="1.0">
                    </div>
                    <div class="input-group">
                        <label for="bandwidth">Bandwidth (W) [Hz]: <span class="value-display" id="bandwidthValue">10</span></label>
                        <input type="range" id="bandwidth" min="1" max="50" step="1" value="10">
                    </div>
                </div>
                
                <div class="control-group">
                    <h3>Doppler Parameters</h3>
                    <div class="input-group">
                        <label for="dopplerSpread">Doppler Spread (Dᵥ) [Hz]: <span class="value-display" id="dopplerSpreadValue">20</span></label>
                        <input type="range" id="dopplerSpread" min="5" max="100" step="5" value="20">
                    </div>
                    <div class="input-group">
                        <label for="coherenceTime">Coherence Time Factor: <span class="value-display" id="coherenceTimeValue">0.05</span></label>
                        <input type="range" id="coherenceTime" min="0.01" max="0.2" step="0.01" value="0.05">
                    </div>
                </div>
                
                <div class="control-group">
                    <h3>Simulation Parameters</h3>
                    <div class="input-group">
                        <label for="numSamples">Number of Samples: <span class="value-display" id="numSamplesValue">200</span></label>
                        <input type="range" id="numSamples" min="50" max="500" step="50" value="200">
                    </div>
                    <div class="input-group">
                        <label for="numPaths">Number of Paths (K): <span class="value-display" id="numPathsValue">8</span></label>
                        <input type="range" id="numPaths" min="4" max="20" step="2" value="8">
                    </div>
                </div>
            </div>
            
            <button class="update-btn" onclick="updatePlots()">Update Simulation</button>
        </div>
        
        <!-- One-Ring Model Diagram Section -->
        <div class="chart-section" style="margin-bottom: 30px;">
            <h3 class="chart-title">One-Ring Model Diagram</h3>
            <div style="background: white; padding: 20px; border-radius: 10px; margin-bottom: 20px;">
                <div class="controls-grid" style="margin-bottom: 15px;">
                    <div class="control-group">
                        <h4 style="margin: 0 0 10px 0;">Animation Controls</h4>
                        <div class="input-group">
                            <label for="velocity">Mobile Velocity (m/s): <span class="value-display" id="velocityValue">10</span></label>
                            <input type="range" id="velocity" min="1" max="50" step="1" value="10">
                        </div>
                        <button id="toggleAnimation" style="background: #48bb78; color: white; border: none; padding: 8px 16px; border-radius: 15px; cursor: pointer;">Start Animation</button>
                    </div>
                    <div class="control-group">
                        <h4 style="margin: 0 0 10px 0;">Model Info</h4>
                        <p style="margin: 5px 0; font-size: 0.9em; color: #4a5568;">
                            <strong>Scatterers:</strong> <span id="scattererCount">8</span><br>
                            <strong>Current Velocity:</strong> <span id="currentVelocity">10</span> m/s
                        </p>
                    </div>
                </div>
                <div style="text-align: center;">
                    <canvas id="oneRingCanvas" width="500" height="500" style="border: 2px solid #e2e8f0; border-radius: 10px; max-width: 100%;"></canvas>
                </div>
                <div style="margin-top: 15px; text-align: center; color: #718096;">
                    <p><strong>Interactive One-Ring Model:</strong> Mobile receiver (blue circle) moves around the ring of scatterers. 
                    Each scatterer reflects signals with different delays and angles, creating the multipath fading environment.</p>
                </div>
            </div>
        </div>

        <div class="charts-container">
            <div class="chart-section">
                <h3 class="chart-title">Autocorrelation Function R₀[n]</h3>
                <div class="chart-container">
                    <canvas id="autocorrelationChart"></canvas>
                </div>
            </div>
            
            <div class="chart-section">
                <h3 class="chart-title">Doppler Power Spectrum S(f)</h3>
                <div class="chart-container">
                    <canvas id="spectrumChart"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables for charts and animation
        let autocorrelationChart = null;
        let spectrumChart = null;
        let animationRunning = false;
        let animationId = null;
        let currentAngle = 0;
        let lastTime = 0;
        
        // Bessel function J0 approximation (good for small to medium arguments)
        function besselJ0(x) {
            if (Math.abs(x) < 8) {
                const y = x * x;
                const ans1 = 57568490574.0 + y * (-13362590354.0 + y * (651619640.7 + 
                    y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456)))));
                const ans2 = 57568490411.0 + y * (1029532985.0 + y * (9494680.718 + 
                    y * (59272.64853 + y * (267.8532712 + y * 1.0))));
                return ans1 / ans2;
            } else {
                const z = 8.0 / x;
                const y = z * z;
                const xx = x - 0.785398164;
                const ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + 
                    y * (-0.2073370639e-5 + y * 0.2093887211e-6)));
                const ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + 
                    y * (-0.6911147651e-5 + y * (0.7621095161e-6 - y * 0.934945152e-7)));
                return Math.sqrt(0.636619772 / x) * (Math.cos(xx) * ans1 - z * Math.sin(xx) * ans2);
            }
        }
        
        // Initialize sliders and their displays
        function initializeControls() {
            const sliders = ['amplitude', 'bandwidth', 'dopplerSpread', 'coherenceTime', 'numSamples', 'numPaths', 'velocity'];
            
            sliders.forEach(id => {
                const slider = document.getElementById(id);
                const display = document.getElementById(id + 'Value');
                
                if (slider && display) {
                    slider.oninput = function() {
                        display.textContent = this.value;
                        if (id === 'numPaths') {
                            document.getElementById('scattererCount').textContent = this.value;
                            drawOneRingModel();
                        } else if (id === 'velocity') {
                            document.getElementById('currentVelocity').textContent = this.value;
                        }
                    };
                }
            });
            
            // Initialize display values
            document.getElementById('scattererCount').textContent = document.getElementById('numPaths').value;
            document.getElementById('currentVelocity').textContent = document.getElementById('velocity').value;
            
            // Animation toggle button
            const toggleBtn = document.getElementById('toggleAnimation');
            toggleBtn.onclick = function() {
                if (animationRunning) {
                    stopAnimation();
                    this.textContent = 'Start Animation';
                    this.style.background = '#48bb78';
                } else {
                    startAnimation();
                    this.textContent = 'Stop Animation';
                    this.style.background = '#e53e3e';
                }
            };
        }
        
        // One-Ring Model Drawing Functions
        function drawOneRingModel() {
            const canvas = document.getElementById('oneRingCanvas');
            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = 120; // Fixed radius
            const K = parseInt(document.getElementById('numPaths').value);
            const velocity = parseFloat(document.getElementById('velocity').value);
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw background
            ctx.fillStyle = '#f8fafc';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw outer ring (scatterer boundary)
            ctx.strokeStyle = '#cbd5e0';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw scatterers around the ring (K scatterers)
            for (let i = 0; i < K; i++) {
                const angle = (2 * Math.PI * i) / K;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                
                // Draw scatterer
                ctx.fillStyle = '#e53e3e';
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, 2 * Math.PI);
                ctx.fill();
                
                // Draw scatterer label
                ctx.fillStyle = '#2d3748';
                ctx.font = '11px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`S${i+1}`, x, y - 12);
            }
            
            // Draw transmitter at center
            ctx.fillStyle = '#f56565';
            ctx.beginPath();
            ctx.arc(centerX, centerY, 10, 0, 2 * Math.PI);
            ctx.fill();
            ctx.fillStyle = 'white';
            ctx.font = 'bold 11px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Tx', centerX, centerY + 4);
            
            // Calculate mobile receiver position
            const mobileAngle = (currentAngle * Math.PI) / 180;
            const mobileRadius = radius * 0.35; // Mobile moves in inner circle
            const mobileX = centerX + mobileRadius * Math.cos(mobileAngle);
            const mobileY = centerY + mobileRadius * Math.sin(mobileAngle);
            
            // Draw mobile receiver
            ctx.fillStyle = '#3182ce';
            ctx.beginPath();
            ctx.arc(mobileX, mobileY, 10, 0, 2 * Math.PI);
            ctx.fill();
            ctx.fillStyle = 'white';
            ctx.font = 'bold 11px Arial';
            ctx.fillText('Rx', mobileX, mobileY + 4);
            
            // Draw mobile movement path
            ctx.strokeStyle = '#90cdf4';
            ctx.lineWidth = 1;
            ctx.setLineDash([2, 2]);
            ctx.beginPath();
            ctx.arc(centerX, centerY, mobileRadius, 0, 2 * Math.PI);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw multipath rays with arrows (from transmitter through scatterers to mobile)
            ctx.lineWidth = 2;
            ctx.globalAlpha = 0.7;
            
            for (let i = 0; i < K; i++) {
                const scatterAngle = (2 * Math.PI * i) / K;
                const scatterX = centerX + radius * Math.cos(scatterAngle);
                const scatterY = centerY + radius * Math.sin(scatterAngle);
                
                // Ray from transmitter to scatterer (outgoing signal)
                ctx.strokeStyle = '#48bb78';
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(scatterX, scatterY);
                ctx.stroke();
                
                // Arrow from transmitter to scatterer
                drawSignalArrow(ctx, centerX, centerY, scatterX, scatterY, '#48bb78', 0.7);
                
                // Ray from scatterer to mobile (reflected signal)
                ctx.strokeStyle = '#2b6cb0';
                ctx.beginPath();
                ctx.moveTo(scatterX, scatterY);
                ctx.lineTo(mobileX, mobileY);
                ctx.stroke();
                
                // Arrow from scatterer to mobile
                drawSignalArrow(ctx, scatterX, scatterY, mobileX, mobileY, '#2b6cb0', 0.7);
            }
            
            ctx.globalAlpha = 1.0;
            
            // Draw velocity vector (scaled by velocity value)
            const velLength = Math.min(50, velocity * 2); // Scale velocity vector
            const velAngle = mobileAngle + Math.PI/2; // Perpendicular to radius (tangential)
            const velEndX = mobileX + velLength * Math.cos(velAngle);
            const velEndY = mobileY + velLength * Math.sin(velAngle);
            
            ctx.strokeStyle = '#ed8936';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(mobileX, mobileY);
            ctx.lineTo(velEndX, velEndY);
            ctx.stroke();
            
            // Velocity arrow
            drawSignalArrow(ctx, mobileX, mobileY, velEndX, velEndY, '#ed8936', 1.0);
            
            // Add velocity label
            ctx.fillStyle = '#ed8936';
            ctx.font = 'bold 14px Arial';
            ctx.fillText(`v=${velocity}m/s`, velEndX + 15, velEndY);
            
            // Draw legend
            drawLegend(ctx, canvas.width - 140, 20);
        }
        
        function drawSignalArrow(ctx, fromX, fromY, toX, toY, color, alpha = 1.0) {
            const angle = Math.atan2(toY - fromY, toX - fromX);
            const arrowLength = 12;
            const arrowAngle = Math.PI / 5;
            
            // Calculate arrow position (75% along the line)
            const arrowPos = 0.75;
            const arrowX = fromX + (toX - fromX) * arrowPos;
            const arrowY = fromY + (toY - fromY) * arrowPos;
            
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = 2;
            
            // Draw arrow head
            ctx.beginPath();
            ctx.moveTo(arrowX, arrowY);
            ctx.lineTo(arrowX - arrowLength * Math.cos(angle - arrowAngle), 
                      arrowY - arrowLength * Math.sin(angle - arrowAngle));
            ctx.lineTo(arrowX - arrowLength * Math.cos(angle + arrowAngle), 
                      arrowY - arrowLength * Math.sin(angle + arrowAngle));
            ctx.closePath();
            ctx.fill();
            
            ctx.restore();
        }
        
        function drawLegend(ctx, x, y) {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
            ctx.fillRect(x - 10, y - 5, 140, 140);
            ctx.strokeStyle = '#e2e8f0';
            ctx.lineWidth = 1;
            ctx.strokeRect(x - 10, y - 5, 140, 140);
            
            ctx.font = '11px Arial';
            ctx.textAlign = 'left';
            
            // Transmitter
            ctx.fillStyle = '#f56565';
            ctx.beginPath();
            ctx.arc(x, y + 12, 5, 0, 2 * Math.PI);
            ctx.fill();
            ctx.fillStyle = '#2d3748';
            ctx.fillText('Transmitter', x + 12, y + 16);
            
            // Receiver
            ctx.fillStyle = '#3182ce';
            ctx.beginPath();
            ctx.arc(x, y + 32, 5, 0, 2 * Math.PI);
            ctx.fill();
            ctx.fillStyle = '#2d3748';
            ctx.fillText('Mobile Rx', x + 12, y + 36);
            
            // Scatterer
            ctx.fillStyle = '#e53e3e';
            ctx.beginPath();
            ctx.arc(x, y + 52, 4, 0, 2 * Math.PI);
            ctx.fill();
            ctx.fillStyle = '#2d3748';
            ctx.fillText('Scatterers', x + 12, y + 56);
            
            // Outgoing signal
            ctx.strokeStyle = '#48bb78';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x, y + 74);
            ctx.lineTo(x + 20, y + 74);
            ctx.stroke();
            // Arrow for outgoing
            ctx.fillStyle = '#48bb78';
            ctx.beginPath();
            ctx.moveTo(x + 15, y + 74);
            ctx.lineTo(x + 12, y + 71);
            ctx.lineTo(x + 12, y + 77);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = '#2d3748';
            ctx.fillText('Tx → Scatterer', x + 25, y + 78);
            
            // Reflected signal
            ctx.strokeStyle = '#2b6cb0';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x, y + 94);
            ctx.lineTo(x + 20, y + 94);
            ctx.stroke();
            // Arrow for reflected
            ctx.fillStyle = '#2b6cb0';
            ctx.beginPath();
            ctx.moveTo(x + 15, y + 94);
            ctx.lineTo(x + 12, y + 91);
            ctx.lineTo(x + 12, y + 97);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = '#2d3748';
            ctx.fillText('Scatterer → Rx', x + 25, y + 98);
            
            // Velocity
            ctx.strokeStyle = '#ed8936';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(x, y + 114);
            ctx.lineTo(x + 20, y + 114);
            ctx.stroke();
            // Arrow for velocity
            ctx.fillStyle = '#ed8936';
            ctx.beginPath();
            ctx.moveTo(x + 15, y + 114);
            ctx.lineTo(x + 12, y + 111);
            ctx.lineTo(x + 12, y + 117);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = '#2d3748';
            ctx.fillText('Velocity', x + 25, y + 118);
        }
        
        // Animation functions
        function startAnimation() {
            animationRunning = true;
            lastTime = performance.now();
            animate();
        }
        
        function stopAnimation() {
            animationRunning = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
        }
        
        function animate(currentTime) {
            if (!animationRunning) return;
            
            if (!lastTime) lastTime = currentTime;
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            const velocity = parseFloat(document.getElementById('velocity').value);
            // Convert velocity to angular velocity (assuming 1 m/s = ~3 degrees/frame at 60fps)
            const angularVelocity = velocity * 0.18 * (deltaTime / 16.67); // Normalize to 60fps
            
            currentAngle = (currentAngle + angularVelocity) % 360;
            drawOneRingModel();
            
            animationId = requestAnimationFrame(animate);
        }animationRunning = true;
            animate();
        
        
        function stopAnimation() {
            animationRunning = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
        }
        
        function animate() {
            if (!animationRunning) return;
            
            const speed = parseFloat(document.getElementById('animationSpeed').value);
            if (speed > 0) {
                currentAngle = (currentAngle + speed) % 360;
                document.getElementById('mobileAngle').value = currentAngle;
                document.getElementById('mobileAngleValue').textContent = Math.round(currentAngle);
                drawOneRingModel();
            }
            
            animationId = requestAnimationFrame(animate);
        }
        function calculateAutocorrelation(a, W, Dv, numSamples) {
            const autocorr = [];
            const nValues = [];
            
            for (let n = 0; n < numSamples; n++) {
                nValues.push(n);
                const arg = n * Math.PI * Dv / W;
                const R0n = 2 * a * a * Math.PI * besselJ0(arg);
                autocorr.push(R0n);
            }
            
            return { nValues, autocorr };
        }
        
        // Calculate Doppler spectrum
        function calculateDopplerSpectrum(a, W, Dv, numSamples) {
            const spectrum = [];
            const frequencies = [];
            const maxFreq = Dv / (2 * W);
            
            for (let i = 0; i < numSamples; i++) {
                const f = (i - numSamples/2) * (2 * maxFreq) / numSamples;
                frequencies.push(f);
                
                const absF = Math.abs(f);
                if (absF <= maxFreq) {
                    const ratio = 2 * f * W / Dv;
                    const denominator = Math.sqrt(1 - ratio * ratio);
                    const Sf = (4 * a * a * W) / (Math.PI * denominator);
                    spectrum.push(Sf);
                } else {
                    spectrum.push(0);
                }
            }
            
            return { frequencies, spectrum };
        }
        
        // Create or update autocorrelation chart
        function updateAutocorrelationChart(nValues, autocorr) {
            const ctx = document.getElementById('autocorrelationChart').getContext('2d');
            
            if (autocorrelationChart) {
                autocorrelationChart.destroy();
            }
            
            autocorrelationChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: nValues,
                    datasets: [{
                        label: 'R₀[n]',
                        data: autocorr,
                        borderColor: '#667eea',
                        backgroundColor: 'rgba(102, 126, 234, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4,
                        pointRadius: 1,
                        pointHoverRadius: 4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Sample Index (n)',
                                font: {
                                    size: 12,
                                    weight: 'bold'
                                }
                            },
                            grid: {
                                color: '#e2e8f0'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'R₀[n]',
                                font: {
                                    size: 12,
                                    weight: 'bold'
                                }
                            },
                            grid: {
                                color: '#e2e8f0'
                            }
                        }
                    },
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    }
                }
            });
        }
        
        // Create or update spectrum chart
        function updateSpectrumChart(frequencies, spectrum) {
            const ctx = document.getElementById('spectrumChart').getContext('2d');
            
            if (spectrumChart) {
                spectrumChart.destroy();
            }
            
            spectrumChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: frequencies.map(f => f.toFixed(2)),
                    datasets: [{
                        label: 'S(f)',
                        data: spectrum,
                        borderColor: '#48bb78',
                        backgroundColor: 'rgba(72, 187, 120, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.1,
                        pointRadius: 0,
                        pointHoverRadius: 4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Frequency (Hz)',
                                font: {
                                    size: 12,
                                    weight: 'bold'
                                }
                            },
                            grid: {
                                color: '#e2e8f0'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Power Spectral Density S(f)',
                                font: {
                                    size: 12,
                                    weight: 'bold'
                                }
                            },
                            grid: {
                                color: '#e2e8f0'
                            }
                        }
                    },
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    }
                }
            });
        }
        
        // Main update function
        function updatePlots() {
            // Get parameter values
            const a = parseFloat(document.getElementById('amplitude').value);
            const W = parseFloat(document.getElementById('bandwidth').value);
            const Dv = parseFloat(document.getElementById('dopplerSpread').value);
            const numSamples = parseInt(document.getElementById('numSamples').value);
            
            // Calculate autocorrelation
            const { nValues, autocorr } = calculateAutocorrelation(a, W, Dv, numSamples);
            updateAutocorrelationChart(nValues, autocorr);
            
            // Calculate Doppler spectrum
            const { frequencies, spectrum } = calculateDopplerSpectrum(a, W, Dv, numSamples);
            updateSpectrumChart(frequencies, spectrum);
        }
        
        // Initialize the application
        window.onload = function() {
            initializeControls();
            drawOneRingModel();
            updatePlots();
        };
    </script>
</body>
</html>