<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clarke's Model Virtual Lab</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                background: #f0f2f5;
                min-height: 100vh;
                color: #333;
            }

            .container {
                max-width: 1400px;
                margin: 0 auto;
                padding: 20px;
            }

            .header {
                text-align: center;
                margin-bottom: 30px;
                color: #333;
            }

            .header h1 {
                font-size: 3rem;
                margin-bottom: 10px;
            }

            .header p {
                font-size: 1.2rem;
                opacity: 0.9;
            }

            .tabs {
                display: flex;
                justify-content: center;
                margin-bottom: 30px;
                background: white;
                border-radius: 10px;
                overflow: hidden;
                box-shadow: 0 4px 16px rgba(0,0,0,0.1);
            }

            .tab-button {
                padding: 15px 40px;
                background: #f8f9fa;
                border: none;
                cursor: pointer;
                font-size: 16px;
                font-weight: 600;
                transition: all 0.3s ease;
                color: #6c757d;
            }

            .tab-button.active {
                background: #667eea;
                color: white;
            }

            .tab-button:hover:not(.active) {
                background: #e9ecef;
            }

            .tab-content {
                display: none;
            }

            .tab-content.active {
                display: block;
            }

            .lab-grid {
                display: grid;
                grid-template-columns: 1fr;
                gap: 20px;
                margin-bottom: 20px;
            }

            .controls-panel, .environment-panel, .chart-panel {
                background: #fff;
                border-radius: 15px;
                padding: 25px;
                box-shadow: 0 8px 32px rgba(0,0,0,0.1);
                height: fit-content;
            }

            .input-group-container {
                display: flex;
                gap: 20px;
                margin-bottom: 20px;
                flex-wrap: wrap;
            }

            .input-group-container .control-group {
                flex: 1;
                min-width: 200px;
                margin-bottom: 0;
            }

            .control-group {
                margin-bottom: 20px;
            }

            .control-group label {
                display: block;
                font-weight: 600;
                margin-bottom: 8px;
                color: #4a5568;
            }

            .control-group input {
                width: 100%;
                padding: 12px;
                border: 2px solid #e2e8f0;
                border-radius: 8px;
                font-size: 16px;
                transition: all 0.3s ease;
            }
            
            .control-group input::-webkit-outer-spin-button,
            .control-group input::-webkit-inner-spin-button {
                -webkit-appearance: none;
                margin: 0;
            }
            
            .control-group input:focus {
                outline: none;
                border-color: #667eea;
                box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
            }

            .help-text {
                font-size: 12px;
                color: #718096;
                margin-top: 5px;
            }

            .environment-canvas {
                width: 100%;
                height: 400px;
                border-radius: 10px;
                background: #f8fafc;
            }

            .chart-container {
                position: relative;
                height: 300px;
                width: 100%;
            }

            h2 {
                font-size: 1.5rem;
                margin-bottom: 20px;
                color: #2d3748;
            }

            h3 {
                font-size: 1.2rem;
                margin-bottom: 15px;
                color: #4a5568;
            }

            .charts-grid {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 20px;
            }
            
            .chart-panel-wrapper {
                display: none;
            }
            
            .info-box {
                background: #f0f4ff;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-top: 20px;
                border-radius: 5px;
            }

            .info-box h4 {
                color: #667eea;
                margin-bottom: 10px;
            }

            .simulate-button {
                width: 100%;
                padding: 15px;
                border: none;
                border-radius: 8px;
                background-color: #667eea;
                color: white;
                font-size: 18px;
                font-weight: bold;
                cursor: pointer;
                transition: background-color 0.3s ease;
            }

            .simulate-button:hover {
                background-color: #5a6ac2;
            }

            .checkbox-group {
                display: flex;
                justify-content: center;
                gap: 20px;
                margin-bottom: 20px;
                flex-wrap: wrap;
            }
            .checkbox-group label {
                font-weight: 600;
                color: #4a5568;
            }
            .checkbox-group input[type="checkbox"] {
                margin-right: 5px;
            }

            @media (max-width: 1000px) {
                .lab-grid {
                    grid-template-columns: 1fr;
                }
                .charts-grid {
                    grid-template-columns: 1fr;
                }
                .input-group-container {
                    flex-direction: column;
                }
                .tabs {
                    flex-direction: column;
                }
            }
        </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Clarke's Model Virtual Lab</h1>
            <p>Interactive simulation of mobile radio channel fading characteristics</p>
        </div>

        <div class="tabs">
            <button class="tab-button active" onclick="switchTab('ideal')">Ideal Model</button>
            <button class="tab-button" onclick="switchTab('realistic')">Realistic Model (Sum of Sinusoids)</button>
        </div>

                <div id="ideal" class="tab-content active">
            <div class="lab-grid">
                <div class="controls-panel">
                    <h2>Parameters - Ideal Model</h2>
                    
                    <div class="input-group-container">
                        <div class="control-group">
                            <label for="velocity1">Vehicle 1 Velocity (m/s)</label>
                            <input type="number" id="velocity1" value="30" min="0" max="100" step="1">
                            <div class="help-text">Controls Doppler spread and fading rate.</div>
                        </div>

                        <div class="control-group">
                            <label for="velocity2">Vehicle 2 Velocity (m/s)</label>
                            <input type="number" id="velocity2" value="60" min="0" max="100" step="1">
                            <div class="help-text">Controls Doppler spread and fading rate.</div>
                        </div>
                        
                        <div class="control-group">
                            <label for="velocity3">Vehicle 3 Velocity (m/s)</label>
                            <input type="number" id="velocity3" value="90" min="0" max="100" step="1">
                            <div class="help-text">Controls Doppler spread and fading rate.</div>
                        </div>
                    </div>
                    <div class="input-group-container">
                        <div class="control-group">
                            <label for="frequency">Carrier Frequency (MHz)</label>
                            <input type="number" id="frequency" value="900" min="100" max="6000" step="100">
                            <div class="help-text">Affects wavelength and Doppler frequency.</div>
                        </div>

                        <div class="control-group">
                            <label for="scatterers">Number of Scatterers</label>
                            <input type="number" id="scatterers" value="20" min="6" max="50" step="2">
                            <div class="help-text">More scatterers provide a better approximation of the model.</div>
                        </div>
                    </div>
                    
                    <button class="simulate-button" onclick="simulateIdeal()">Simulate Ideal Model</button>

                    <div class="info-box">
                        <h4>Clarke's Ideal Model</h4>
                        <p>Models multipath fading in mobile communications assuming:</p>
                        <ul style="margin: 10px 0 0 20px; line-height: 1.6;">
                            <li>Scatterers uniformly distributed</li>
                            <li>Equal signal strength from all paths</li>
                            <li>Mobile receiver in motion</li>
                            <li>Theoretical Bessel function autocorrelation</li>
                        </ul>
                    </div>
                </div>

                <div class="environment-panel">
                    <h2>Scattering Environment</h2>
                    <canvas id="environmentCanvas" class="environment-canvas"></canvas>
                </div>
            </div>

            <div class="charts-grid">
                <div class="chart-panel-wrapper" id="autocorrelationPanel">
                    <div class="chart-panel">
                        <h3>Autocorrelation Function R(τ)</h3>
                        <div class="checkbox-group">
                            <label><input type="checkbox" id="v1-autocorr-check" checked> Vehicle 1</label>
                            <label><input type="checkbox" id="v2-autocorr-check" checked> Vehicle 2</label>
                            <label><input type="checkbox" id="v3-autocorr-check" checked> Vehicle 3</label>
                        </div>
                        <div class="chart-container">
                            <canvas id="autocorrelationChart"></canvas>
                        </div>
                    </div>
                </div>

                <div class="chart-panel-wrapper" id="psdPanel">
                    <div class="chart-panel">
                        <h3>Power Spectral Density S(f)</h3>
                        <div class="checkbox-group">
                            <label><input type="checkbox" id="v1-psd-check" checked> Vehicle 1</label>
                            <label><input type="checkbox" id="v2-psd-check" checked> Vehicle 2</label>
                            <label><input type="checkbox" id="v3-psd-check" checked> Vehicle 3</label>
                        </div>
                    </div>
                    <div class="chart-container">
                        <canvas id="psdChart"></canvas>
                    </div>
                </div>
            </div>
        </div>

                <div id="realistic" class="tab-content">
            <div class="lab-grid">
                <div class="controls-panel">
                    <h2>Parameters - Realistic Model</h2>
                    
                    <div class="input-group-container">
                        <div class="control-group">
                            <label for="velocity-realistic">Vehicle Velocity (m/s)</label>
                            <input type="number" id="velocity-realistic" value="30" min="0" max="100" step="1">
                            <div class="help-text">Controls Doppler spread and fading rate.</div>
                        </div>

                        <div class="control-group">
                            <label for="frequency-realistic">Carrier Frequency (MHz)</label>
                            <input type="number" id="frequency-realistic" value="900" min="100" max="6000" step="100">
                            <div class="help-text">Affects wavelength and Doppler frequency.</div>
                        </div>
                    </div>
                    
                    <div class="input-group-container">
                        <div class="control-group">
                            <label for="multipaths">Number of Multipaths (M)</label>
                            <input type="number" id="multipaths" value="20" min="6" max="50" step="2">
                            <div class="help-text">Number of multipath components in sum of sinusoids.</div>
                        </div>

                        <div class="control-group">
                            <label for="samples">Number of Samples (N)</label>
                            <input type="number" id="samples" value="1000" min="100" max="5000" step="100">
                            <div class="help-text">Number of time samples for simulation.</div>
                        </div>
                    </div>
                    
                    <button class="simulate-button" onclick="simulateRealistic()">Simulate Realistic Model</button>

                    <div class="info-box">
                        <h4>Clarke's Realistic Model (Sum of Sinusoids)</h4>
                        <p>Implements the practical sum of sinusoids method:</p>
                        <ul style="margin: 10px 0 0 20px; line-height: 1.6;">
                            <li>Finite number of multipath components</li>
                            <li>Discrete angle of arrival simulation</li>
                            <li>Statistical properties approximating ideal model</li>
                            <li>Computational efficient implementation</li>
                        </ul>
                    </div>
                </div>

                <div class="environment-panel">
                    <h2>Multipath Environment</h2>
                    <canvas id="realisticEnvironmentCanvas" class="environment-canvas"></canvas>
                </div>
            </div>

            <div class="charts-grid">
                <div class="chart-panel-wrapper" id="realisticAutocorrelationPanel">
                    <div class="chart-panel">
                        <h3>Autocorrelation Function R(τ) - Realistic vs Ideal</h3>
                        <div class="chart-container">
                            <canvas id="realisticAutocorrelationChart"></canvas>
                        </div>
                    </div>
                </div>

                <div class="chart-panel-wrapper" id="realisticPsdPanel">
                    <div class="chart-panel">
                        <h3>Power Spectral Density S(f) - Realistic vs Ideal</h3>
                        <div class="chart-container">
                            <canvas id="realisticPsdChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Physical constants
        const SPEED_OF_LIGHT = 3e8;

        // Current active tab
        let currentTab = 'ideal';

        // DOM elements - Ideal
        const velocity1Input = document.getElementById('velocity1');
        const velocity2Input = document.getElementById('velocity2');
        const velocity3Input = document.getElementById('velocity3');
        const frequencyInput = document.getElementById('frequency');
        const scatterersInput = document.getElementById('scatterers');
        const envCanvas = document.getElementById('environmentCanvas');
        const envCtx = envCanvas.getContext('2d');

        // DOM elements - Realistic
        const velocityRealisticInput = document.getElementById('velocity-realistic');
        const frequencyRealisticInput = document.getElementById('frequency-realistic');
        const multipathsInput = document.getElementById('multipaths');
        const samplesInput = document.getElementById('samples');
        const realisticEnvCanvas = document.getElementById('realisticEnvironmentCanvas');
        const realisticEnvCtx = realisticEnvCanvas.getContext('2d');

        // Checkboxes for plots
        const v1AutocorrCheck = document.getElementById('v1-autocorr-check');
        const v2AutocorrCheck = document.getElementById('v2-autocorr-check');
        const v3AutocorrCheck = document.getElementById('v3-autocorr-check');
        const v1PsdCheck = document.getElementById('v1-psd-check');
        const v2PsdCheck = document.getElementById('v2-psd-check');
        const v3PsdCheck = document.getElementById('v3-psd-check');

        // Charts
        let autocorrelationChart = null;
        let psdChart = null;
        let realisticAutocorrelationChart = null;
        let realisticPsdChart = null;

        // Data storage for ideal model
        let idealData = {
            velocities: [30, 60, 90],
            frequency: 900,
            autocorr: [],
            psd: []
        };

        // Data storage for realistic model
        let realisticData = {
            velocity: 30,
            frequency: 900,
            multipaths: 20,
            samples: 1000,
            idealAutocorr: [],
            realisticAutocorr: [],
            idealPsd: [],
            realisticPsd: []
        };

        // Helper function to generate a range of numbers
        function range(start, end, step) {
            const result = [];
            for (let i = start; i <= end; i += step) {
                result.push(i);
            }
            return result;
        }

        // Switch between tabs
        function switchTab(tabName) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // Remove active class from all tab buttons
            document.querySelectorAll('.tab-button').forEach(button => {
                button.classList.remove('active');
            });
            
            // Show selected tab content
            document.getElementById(tabName).classList.add('active');
            
            // Add active class to clicked button
            event.target.classList.add('active');
            
            currentTab = tabName;
            
            // Draw environment for current tab and clear previous charts
            if (tabName === 'ideal') {
                drawEnvironment();
                destroyCharts([realisticAutocorrelationChart, realisticPsdChart]);
                document.getElementById('autocorrelationPanel').style.display = 'none';
                document.getElementById('psdPanel').style.display = 'none';
            } else {
                drawRealisticEnvironment();
                destroyCharts([autocorrelationChart, psdChart]);
                document.getElementById('realisticAutocorrelationPanel').style.display = 'none';
                document.getElementById('realisticPsdPanel').style.display = 'none';
            }
        }
        
        // Destroy chart instances to avoid memory leaks
        function destroyCharts(charts) {
            charts.forEach(chart => {
                if (chart) {
                    chart.destroy();
                    chart = null;
                }
            });
        }

        // Bessel function J0 approximation
        function besselJ0(x) {
            if (Math.abs(x) < 8.0) {
                const y = x * x;
                const ans1 = 57568490574.0 + y * (-13362590354.0 + y * (651619640.7 + 
                    y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456)))));
                const ans2 = 57568490411.0 + y * (1029532985.0 + y * (9494680.718 + 
                    y * (59272.64853 + y * (267.8532712 + y * 1.0))));
                return ans1 / ans2;
            } else {
                const z = 8.0 / x;
                const y = z * z;
                const xx = x - 0.785398164;
                const ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + 
                    y * (-0.2073370639e-5 + y * 0.2093887211e-6)));
                const ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + 
                    y * (-0.6911147651e-5 + y * (0.7621095161e-6 - y * 0.934935152e-7)));
                return Math.sqrt(0.636619772 / x) * (Math.cos(xx) * ans1 - z * Math.sin(xx) * ans2);
            }
        }

        // Generate Rayleigh fading using sum of sinusoids (realistic model)
        function generateRayleighFading(velocity, frequency, M, N, Ts) {
            const wavelength = SPEED_OF_LIGHT / (frequency * 1e6); // Convert MHz to Hz
            const fD = velocity / wavelength; // Maximum Doppler frequency
            
            const hI = new Array(N).fill(0);
            const hQ = new Array(N).fill(0);
            
            // Generate random phases
            const alpha = new Array(M).fill(0).map(() => Math.random() * 2 * Math.PI);
            const beta = new Array(M).fill(0).map(() => Math.random() * 2 * Math.PI);
            
            for (let n = 0; n < N; n++) {
                const t = n * Ts;
                
                for (let m = 1; m <= M; m++) { // Start m from 1 for formula
                    const angle = (2 * Math.PI * (m - 1)) / M; 
                    const cosArg = 2 * Math.PI * fD * Math.cos(angle) * t + alpha[m-1];
                    const sinArg = 2 * Math.PI * fD * Math.cos(angle) * t + beta[m-1];
                    
                    hI[n] += Math.cos(cosArg);
                    hQ[n] += Math.sin(sinArg);
                }
                
                hI[n] *= (1 / Math.sqrt(M));
                hQ[n] *= (1 / Math.sqrt(M));
            }
            
            // Calculate envelope
            const envelope = new Array(N);
            for (let n = 0; n < N; n++) {
                envelope[n] = Math.sqrt(hI[n] * hI[n] + hQ[n] * hQ[n]);
            }
            
            return { hI, hQ, envelope };
        }

        // Calculate autocorrelation from time series
        function calculateAutocorrelationFromSeries(series, maxLag) {
            const N = series.length;
            const autocorr = [];
            
            for (let lag = 0; lag <= maxLag; lag++) {
                let sum = 0;
                let count = 0;
                
                for (let i = 0; i < N - lag; i++) {
                    sum += series[i] * series[i + lag];
                    count++;
                }
                
                autocorr.push(sum / count);
            }
            
            // Normalize
            const R0 = autocorr[0];
            return autocorr.map(val => val / R0);
        }

        // Calculate PSD using FFT approximation (simplified)
        function calculatePSDFromSeries(series, Ts) {
            const N = series.length;
            const fs = 1 / Ts;
            
            // Simple periodogram approach
            const fft_approx = [];
            const freqs = [];
            
            // We'll compute a simplified PSD by windowing and averaging
            const windowSize = Math.min(256, Math.floor(N / 4));
            const numWindows = Math.floor(N / windowSize);
            
            for (let k = 0; k < windowSize / 2; k++) {
                freqs.push((k * fs) / windowSize - fs / 2);
                let psd = 0;
                
                for (let w = 0; w < numWindows; w++) {
                    let real = 0, imag = 0;
                    for (let n = 0; n < windowSize; n++) {
                        const idx = w * windowSize + n;
                        if (idx < N) {
                            const angle = -2 * Math.PI * k * n / windowSize;
                            real += series[idx] * Math.cos(angle);
                            imag += series[idx] * Math.sin(angle);
                        }
                    }
                    psd += (real * real + imag * imag);
                }
                
                fft_approx.push(psd / numWindows);
            }
            
            return { freqs, psd: fft_approx };
        }

        // Draw ideal environment
        function drawEnvironment() {
            const width = envCanvas.width = envCanvas.offsetWidth;
            const height = envCanvas.height = envCanvas.offsetHeight;
            
            envCtx.clearRect(0, 0, width, height);
            
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) * 0.35;
            const numScatterers = parseInt(scatterersInput.value);

            // Draw circle
            envCtx.strokeStyle = '#667eea';
            envCtx.lineWidth = 3;
            envCtx.beginPath();
            envCtx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            envCtx.stroke();

            // Draw scatterers
            envCtx.fillStyle = '#48bb78';
            for (let i = 0; i < numScatterers; i++) {
                const angle = (2 * Math.PI * i) / numScatterers;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                
                envCtx.beginPath();
                envCtx.arc(x, y, 6, 0, 2 * Math.PI);
                envCtx.fill();
                
                // Draw path lines
                envCtx.strokeStyle = 'rgba(102, 126, 234, 0.3)';
                envCtx.lineWidth = 1;
                envCtx.beginPath();
                envCtx.moveTo(centerX, centerY);
                envCtx.lineTo(x, y);
                envCtx.stroke();
            }

            // Draw mobile receiver
            envCtx.fillStyle = '#e53e3e';
            envCtx.beginPath();
            envCtx.arc(centerX, centerY, 10, 0, 2 * Math.PI);
            envCtx.fill();
            
            // Add label
            envCtx.fillStyle = '#2d3748';
            envCtx.font = 'bold 14px Arial';
            envCtx.textAlign = 'center';
            envCtx.fillText('Rx', centerX, centerY + 5);

            // Add velocity arrow
            const velocity = parseFloat(velocity1Input.value);
            if (velocity > 0) {
                envCtx.strokeStyle = '#e53e3e';
                envCtx.lineWidth = 3;
                envCtx.beginPath();
                envCtx.moveTo(centerX, centerY - 20);
                envCtx.lineTo(centerX + 30, centerY - 20);
                envCtx.stroke();
                
                // Arrow head
                envCtx.beginPath();
                envCtx.moveTo(centerX + 30, centerY - 20);
                envCtx.lineTo(centerX + 25, centerY - 25);
                envCtx.moveTo(centerX + 30, centerY - 20);
                envCtx.lineTo(centerX + 25, centerY - 15);
                envCtx.stroke();
                
                envCtx.fillStyle = '#2d3748';
                envCtx.font = '12px Arial';
                envCtx.fillText(`v = ${velocity} m/s`, centerX + 15, centerY - 30);
            }
        }

        // Draw realistic environment
        function drawRealisticEnvironment() {
            const width = realisticEnvCanvas.width = realisticEnvCanvas.offsetWidth;
            const height = realisticEnvCanvas.height = realisticEnvCanvas.offsetHeight;
            
            realisticEnvCtx.clearRect(0, 0, width, height);
            
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) * 0.35;
            const numMultipaths = parseInt(multipathsInput.value);

            // Draw multiple concentric circles to show multipath
            for (let r = 1; r <= 3; r++) {
                realisticEnvCtx.strokeStyle = `rgba(102, 126, 234, ${0.3 - r * 0.08})`;
                realisticEnvCtx.lineWidth = 2;
                realisticEnvCtx.beginPath();
                realisticEnvCtx.arc(centerX, centerY, radius * r / 3, 0, 2 * Math.PI);
                realisticEnvCtx.stroke();
            }

            // Draw multipath components
            realisticEnvCtx.fillStyle = '#48bb78';
            for (let i = 0; i < numMultipaths; i++) {
                const angle = (2 * Math.PI * i) / numMultipaths;
                const r = radius * (0.6 + 0.4 * Math.random()); // Random radius for realism
                const x = centerX + r * Math.cos(angle);
                const y = centerY + r * Math.sin(angle);
                
                realisticEnvCtx.beginPath();
                realisticEnvCtx.arc(x, y, 4, 0, 2 * Math.PI);
                realisticEnvCtx.fill();
                
                // Draw path lines
                realisticEnvCtx.strokeStyle = 'rgba(102, 126, 234, 0.4)';
                realisticEnvCtx.lineWidth = 1;
                realisticEnvCtx.beginPath();
                realisticEnvCtx.moveTo(centerX, centerY);
                realisticEnvCtx.lineTo(x, y);
                realisticEnvCtx.stroke();
            }

            // Draw mobile receiver
            realisticEnvCtx.fillStyle = '#e53e3e';
            realisticEnvCtx.beginPath();
            realisticEnvCtx.arc(centerX, centerY, 10, 0, 2 * Math.PI);
            realisticEnvCtx.fill();
            
            // Add label
            realisticEnvCtx.fillStyle = '#2d3748';
            realisticEnvCtx.font = 'bold 14px Arial';
            realisticEnvCtx.textAlign = 'center';
            realisticEnvCtx.fillText('Rx', centerX, centerY + 5);

            // Add velocity arrow
            const velocity = parseFloat(velocityRealisticInput.value);
            if (velocity > 0) {
                realisticEnvCtx.strokeStyle = '#e53e3e';
                realisticEnvCtx.lineWidth = 3;
                realisticEnvCtx.beginPath();
                realisticEnvCtx.moveTo(centerX, centerY - 20);
                realisticEnvCtx.lineTo(centerX + 30, centerY - 20);
                realisticEnvCtx.stroke();
                
                // Arrow head
                realisticEnvCtx.beginPath();
                realisticEnvCtx.moveTo(centerX + 30, centerY - 20);
                realisticEnvCtx.lineTo(centerX + 25, centerY - 25);
                realisticEnvCtx.moveTo(centerX + 30, centerY - 20);
                realisticEnvCtx.lineTo(centerX + 25, centerY - 15);
                realisticEnvCtx.stroke();
                
                realisticEnvCtx.fillStyle = '#2d3748';
                realisticEnvCtx.font = '12px Arial';
                realisticEnvCtx.fillText(`v = ${velocity} m/s`, centerX + 15, centerY - 30);
            }
        }
        
        // Initialize charts
        function initializeIdealCharts() {
            const autocorrCtx = document.getElementById('autocorrelationChart').getContext('2d');
            if (autocorrelationChart) autocorrelationChart.destroy();
            
            autocorrelationChart = new Chart(autocorrCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: []
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'top',
                        },
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Time Lag τ (s)'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'R(τ)'
                            }
                        }
                    }
                }
            });

            const psdCtx = document.getElementById('psdChart').getContext('2d');
            if (psdChart) psdChart.destroy();

            psdChart = new Chart(psdCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: []
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'top',
                        },
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Frequency (Hz)'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Power Spectral Density S(f)'
                            }
                        }
                    }
            });
        }

        function initializeRealisticCharts() {
            const realisticAutocorrCtx = document.getElementById('realisticAutocorrelationChart').getContext('2d');
            if (realisticAutocorrelationChart) realisticAutocorrelationChart.destroy();

            realisticAutocorrelationChart = new Chart(realisticAutocorrCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: []
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'top',
                        },
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Time Lag τ (s)'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'R(τ)'
                            }
                        }
                    }
                }
            });
            
            const realisticPsdCtx = document.getElementById('realisticPsdChart').getContext('2d');
            if (realisticPsdChart) realisticPsdChart.destroy();
            
            realisticPsdChart = new Chart(realisticPsdCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: []
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'top',
                        },
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Frequency (Hz)'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Power Spectral Density S(f)'
                            }
                        }
                    }
            });
        }
        
        // Update ideal charts based on checkbox selections
        function updateIdealCharts() {
            if (autocorrelationChart) {
                autocorrelationChart.data.datasets = [];
                if (v1AutocorrCheck.checked && idealData.autocorr[0]) {
                    autocorrelationChart.data.datasets.push({
                        label: 'Vehicle 1',
                        data: idealData.autocorr[0],
                        borderColor: 'rgba(102, 126, 234, 1)',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.4
                    });
                }
                if (v2AutocorrCheck.checked && idealData.autocorr[1]) {
                    autocorrelationChart.data.datasets.push({
                        label: 'Vehicle 2',
                        data: idealData.autocorr[1],
                        borderColor: 'rgba(76, 209, 55, 1)',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.4
                    });
                }
                if (v3AutocorrCheck.checked && idealData.autocorr[2]) {
                    autocorrelationChart.data.datasets.push({
                        label: 'Vehicle 3',
                        data: idealData.autocorr[2],
                        borderColor: 'rgba(235, 77, 75, 1)',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.4
                    });
                }
                autocorrelationChart.update();
            }

            if (psdChart) {
                psdChart.data.datasets = [];
                if (v1PsdCheck.checked && idealData.psd[0]) {
                    psdChart.data.datasets.push({
                        label: 'Vehicle 1',
                        data: idealData.psd[0],
                        borderColor: 'rgba(102, 126, 234, 1)',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.4
                    });
                }
                if (v2PsdCheck.checked && idealData.psd[1]) {
                    psdChart.data.datasets.push({
                        label: 'Vehicle 2',
                        data: idealData.psd[1],
                        borderColor: 'rgba(76, 209, 55, 1)',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.4
                    });
                }
                if (v3PsdCheck.checked && idealData.psd[2]) {
                    psdChart.data.datasets.push({
                        label: 'Vehicle 3',
                        data: idealData.psd[2],
                        borderColor: 'rgba(235, 77, 75, 1)',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.4
                    });
                }
                psdChart.update();
            }
        }

        // Simulation function for the Ideal Model tab
        function simulateIdeal() {
            const v1 = parseFloat(velocity1Input.value);
            const v2 = parseFloat(velocity2Input.value);
            const v3 = parseFloat(velocity3Input.value);
            const frequencyMHz = parseFloat(frequencyInput.value);
            const frequency = frequencyMHz * 1e6; // Hz
            
            const velocities = [v1, v2, v3];
            
            // Calculate theoretical Autocorrelation and PSD
            idealData.autocorr = [];
            idealData.psd = [];
            
            const timeLags = range(0, 0.1, 0.001);
            const freqs = range(-500, 500, 1);
            
            velocities.forEach(v => {
                if (v === 0) return;
                const fD = v / (SPEED_OF_LIGHT / frequency); // Max Doppler Frequency
                
                // Autocorrelation: R(τ) = J0(2π*fD*τ)
                const autocorrData = timeLags.map(tau => besselJ0(2 * Math.PI * fD * tau));
                idealData.autocorr.push(autocorrData);
                
                // Power Spectral Density: S(f) = (1 / (π*fD*sqrt(1 - (f/fD)^2)))
                const psdData = freqs.map(f => {
                    if (Math.abs(f) > fD) return 0;
                    return 1 / (Math.PI * fD * Math.sqrt(1 - (f / fD)**2));
                });
                
                // Normalize PSD for plotting
                const maxPsd = Math.max(...psdData);
                const normalizedPsdData = psdData.map(val => val / maxPsd);
                idealData.psd.push(normalizedPsdData);
            });
            
            idealData.velocities = velocities;
            idealData.frequency = frequencyMHz;
            
            // Update charts with new data
            if (autocorrelationChart) {
                autocorrelationChart.data.labels = timeLags.map(t => t.toFixed(3));
            }
            if (psdChart) {
                psdChart.data.labels = freqs.map(f => f.toFixed(0));
            }
            
            // Show chart panels and update
            document.getElementById('autocorrelationPanel').style.display = 'block';
            document.getElementById('psdPanel').style.display = 'block';
            updateIdealCharts();
            drawEnvironment();
        }
        
        // Simulation function for the Realistic Model tab
        function simulateRealistic() {
            const velocity = parseFloat(velocityRealisticInput.value);
            const frequencyMHz = parseFloat(frequencyRealisticInput.value);
            const numMultipaths = parseInt(multipathsInput.value);
            const numSamples = parseInt(samplesInput.value);
            
            // Store parameters
            realisticData.velocity = velocity;
            realisticData.frequency = frequencyMHz;
            realisticData.multipaths = numMultipaths;
            realisticData.samples = numSamples;
            
            // Simulation parameters
            const fs = 2 * (velocity / (SPEED_OF_LIGHT / (frequencyMHz * 1e6))) * 10; // Sample at 10x max Doppler
            const Ts = 1 / fs;
            
            // Generate time series
            const fadingData = generateRayleighFading(velocity, frequencyMHz, numMultipaths, numSamples, Ts);
            
            // Calculate empirical autocorrelation and PSD
            const maxLag = Math.floor(numSamples * 0.1);
            const realisticAutocorr = calculateAutocorrelationFromSeries(fadingData.hI, maxLag);
            const realisticPsd = calculatePSDFromSeries(fadingData.hI, Ts);
            
            // Calculate theoretical plots for comparison
            const fD = velocity / (SPEED_OF_LIGHT / (frequencyMHz * 1e6));
            
            const autocorrTimeLags = range(0, maxLag * Ts, Ts);
            const idealAutocorr = autocorrTimeLags.map(tau => besselJ0(2 * Math.PI * fD * tau));
            
            const idealPsd = realisticPsd.freqs.map(f => {
                if (Math.abs(f) > fD) return 0;
                return 1 / (Math.PI * fD * Math.sqrt(1 - (f / fD)**2));
            });
            
            // Normalize PSDs
            const maxIdealPsd = Math.max(...idealPsd);
            const maxRealisticPsd = Math.max(...realisticPsd.psd);
            const maxPsd = Math.max(maxIdealPsd, maxRealisticPsd);
            
            realisticData.idealAutocorr = idealAutocorr;
            realisticData.realisticAutocorr = realisticAutocorr;
            realisticData.idealPsd = idealPsd.map(val => val / maxPsd);
            realisticData.realisticPsd = realisticPsd.psd.map(val => val / maxPsd);
            
            // Update charts with new data
            if (realisticAutocorrelationChart) {
                realisticAutocorrelationChart.data.labels = autocorrTimeLags.map(t => t.toFixed(3));
                updateRealisticAutocorrChart();
            }
            
            if (realisticPsdChart) {
                realisticPsdChart.data.labels = realisticPsd.freqs.map(f => f.toFixed(0));
                updateRealisticPsdChart();
            }
            
            // Show chart panels
            document.getElementById('realisticAutocorrelationPanel').style.display = 'block';
            document.getElementById('realisticPsdPanel').style.display = 'block';
            drawRealisticEnvironment();
        }

        // Update realistic charts (for future extensions, currently static)
        function updateRealisticAutocorrChart() {
            if (realisticAutocorrelationChart) {
                realisticAutocorrelationChart.data.datasets = [
                    {
                        label: 'Theoretical (Ideal)',
                        data: realisticData.idealAutocorr,
                        borderColor: 'rgba(102, 126, 234, 1)',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.4,
                        pointRadius: 0
                    },
                    {
                        label: 'Simulated (Realistic)',
                        data: realisticData.realisticAutocorr,
                        borderColor: 'rgba(235, 77, 75, 1)',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.4,
                        pointRadius: 0
                    }
                ];
                realisticAutocorrelationChart.update();
            }
        }

        function updateRealisticPsdChart() {
            if (realisticPsdChart) {
                realisticPsdChart.data.datasets = [
                    {
                        label: 'Theoretical (Ideal)',
                        data: realisticData.idealPsd,
                        borderColor: 'rgba(102, 126, 234, 1)',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.4,
                        pointRadius: 0
                    },
                    {
                        label: 'Simulated (Realistic)',
                        data: realisticData.realisticPsd,
                        borderColor: 'rgba(235, 77, 75, 1)',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.4,
                        pointRadius: 0
                    }
                ];
                realisticPsdChart.update();
            }
        }
        
        // Event listeners
        window.onload = () => {
            drawEnvironment();
            initializeIdealCharts();
            initializeRealisticCharts();
            
            // Ideal tab listeners
            scatterersInput.addEventListener('input', drawEnvironment);
            velocity1Input.addEventListener('input', drawEnvironment);
            
            v1AutocorrCheck.addEventListener('change', updateIdealCharts);
            v2AutocorrCheck.addEventListener('change', updateIdealCharts);
            v3AutocorrCheck.addEventListener('change', updateIdealCharts);
            v1PsdCheck.addEventListener('change', updateIdealCharts);
            v2PsdCheck.addEventListener('change', updateIdealCharts);
            v3PsdCheck.addEventListener('change', updateIdealCharts);
            
            // Realistic tab listeners
            multipathsInput.addEventListener('input', drawRealisticEnvironment);
            velocityRealisticInput.addEventListener('input', drawRealisticEnvironment);
        };
    </script>
</body>
</html>