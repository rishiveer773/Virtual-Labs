<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Advanced Shadowing and Outage Probability Lab</title>
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      display: flex;
      flex-direction: column;
      height: 100vh;
      background-color: #f0f2f5; 
      overflow: hidden; 
    }

    /* New Header Styles */
    .top-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 25px;
        background-color: white;
        border-bottom: 1px solid #ddd;
        flex-shrink: 0;
    }
    .header-left, .header-right {
        display: flex;
        align-items: center;
        gap: 15px;
    }
    .header-logo {
        height: 48px;
        display: flex;
        align-items: center;
        gap: 10px;
    }
    .header-logo img {
      height: 40px;
    }
    .header-logo-text {
        font-size: 1.1em;
        font-weight: 600;
        color: #333;
    }
    .page-title {
        font-size: 1.5em;
        color: #007bff;
    }
    .report-bug-btn {
        padding: 10px 20px;
        background-color: #0d6efd;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-weight: 500;
        transition: background-color 0.2s;
    }
    .report-bug-btn:hover {
      background-color: #0b5ed7;
    }

    /* New Main Task Tabs Styles */
    .main-tasks-container {
        padding: 0 25px;
        background-color: #f8f9fa;
        border-bottom: 3px solid #f08c00; /* Orange line */
        flex-shrink: 0;
        display: flex;
        gap: 10px;
        align-items: flex-end;
    }
    .main-task-btn {
        padding: 10px 20px;
        border: 1px solid #ccc;
        background-color: #f1f1f1;
        cursor: pointer;
        border-bottom: none;
        border-radius: 6px 6px 0 0;
        font-size: 1em;
        position: relative;
        bottom: -1px;
        color: #555;
    }
    .main-task-btn.active {
        background-color: white;
        border: 2px solid #9acd32; /* Light green border like image */
        border-bottom: 2px solid white;
        font-weight: 600;
        color: #333;
    }

    /* Page container to hold switchable content */
    .page-container {
      flex-grow: 1;
      position: relative;
      overflow: hidden;
    }
    .page-content {
        display: none;
        width: 100%;
        height: 100%;
    }
    .page-content.active {
        display: grid; /* Default for active pages */
    }

    /* Styles for the main simulation page */
    #simulation-page.active {
      grid-template-columns: 320px 1fr 350px;
    }
    
    #inputs, #simulation, #outputs {
      border: none;
      margin: 10px;
      border-radius: 15px;
      background: rgba(255, 255, 255, 0.98);
      backdrop-filter: blur(10px);
      box-shadow: 0 8px 32px rgba(31, 38, 135, 0.1);
      overflow: auto; 
    }
    #inputs, #outputs { padding: 20px; }
    
    #simulation {
      display: flex; 
      flex-direction: column; 
      justify-content: center;
      align-items: center;
      position: relative; 
      padding: 15px; 
    }

    /* Styles for the analysis page */
    #analysis-page {
      padding: 20px;
      overflow-y: auto;
    }
    #analysis-page.active {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
    }
    #analysis-page h3 {
      text-align: center;
      font-size: 1.8em;
      color: #333;
    }
    #analysis-page .chart-controls {
      display: flex;
      gap: 30px;
      margin-bottom: 15px;
      flex-wrap: wrap;
      justify-content: center;
      background: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }
     #analysis-page .chart-container {
      width: 80%;
      max-width: 1200px;
      height: 500px;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      padding: 15px;
      margin-bottom: 20px;
    }
    #analysis-page .output-section {
      width: 80%;
      max-width: 1200px;
    }

    h3 {
      color: #333;
      margin: 0 0 20px 0;
      text-align: center;
      font-size: 1.3em;
      font-weight: 600;
      text-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .input-group {
      margin-bottom: 20px;
      padding: 15px;
      background: rgba(245, 245, 245, 0.9);
      border-radius: 10px;
      border: 1px solid rgba(102, 126, 234, 0.2);
      transition: all 0.3s ease;
    }

    .input-group:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }

    label {
      display: block;
      margin-bottom: 8px;
      font-weight: 600;
      color: #444;
      font-size: 0.9em;
    }

    input, select {
      width: 100%;
      padding: 10px 12px;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      font-size: 14px;
      transition: all 0.3s ease;
      background: white;
    }

    input:focus, select:focus {
      border-color: #667eea;
      outline: none;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }

    .grid-container {
      border: 3px solid #333;
      border-radius: 12px;
      overflow: hidden; 
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      background: #333; 
      flex-shrink: 0; 
      /* MODIFICATION: Changed cursor to the requested SVG */
      cursor: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0iIzY2N2VlYSI+PHBhdGggZD0iTTE2IDFIOEM2LjM0IDEgNSAyLjM0IDUgNHYxNmMwIDEuNjYgMS4zNCAzIDMgM2g4YzEuNjYgMCAzLTEuMzQgMy0zVjRjMC0xLjY2LTEuMzQtMy0zLTN6TTE0IDIxaC00di0xaDR2MXptMS4yNS0zSDguNzVWNGg2LjV2MTR6Ii8+PC9zdmc+') 12 12, auto;
    }

    .cell {
      width: 18px; 
      height: 18px; 
      border: none; 
      cursor: pointer;
      transition: background-color 0.1s ease, transform 0.2s ease; 
      position: relative;
    }
    .cell:hover {
      transform: scale(1.15); 
      z-index: 10;
      box-shadow: 0 0 10px rgba(0,0,0,0.6); 
    }
    
    .transmitter {
      border-radius: 50%;
      border: 3px solid #000 !important;
      background: radial-gradient(circle, #ffeb3b, #ff9800) !important;
      box-shadow: 0 0 12px rgba(255, 193, 7, 0.8);
      animation: pulse 2s infinite;
      position: relative;
    }
    .transmitter::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 12px;
      height: 12px;
      transform: translate(-50%, -50%);
      background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="%23000" stroke-width="3"><path d="M12 2v20"/><path d="M2 12h20"/><circle cx="12" cy="12" r="3"/></svg>');
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
      z-index: 2;
    }
    @keyframes pulse {
      0%, 100% { box-shadow: 0 0 12px rgba(255, 193, 7, 0.8); transform: scale(1); }
      50% { box-shadow: 0 0 20px rgba(255, 193, 7, 1); transform: scale(1.05); }
    }

    .obstacle-normal { background: linear-gradient(45deg, #555, #777) !important; border: 1px solid #222 !important; }
    .obstacle-heavy { background: linear-gradient(45deg, #7A0000, #C01030) !important; border: 1px solid #500 !important; box-shadow: inset 0 1px 3px rgba(0,0,0,0.4); }
    .outage-cell { box-shadow: inset 0 0 0 1px #dd0033, 0 0 4px rgba(255, 23, 68, 0.5); animation: blink-outage 1.5s infinite alternate; }
    .obstacle-normal.outage-cell, .obstacle-heavy.outage-cell { box-shadow: inset 0 0 0 1px #dd0033, 0 0 4px rgba(255, 23, 68, 0.5); }
    
    @keyframes blink-outage { 
      from { box-shadow: inset 0 0 0 1px #dd0033, 0 0 4px rgba(255, 23, 68, 0.5); }
      to   { box-shadow: inset 0 0 0 1px #ff4466, 0 0 7px rgba(255, 87, 34, 0.7); }
    }
    .cell.shadowed-cell::after {
        content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0;
        background-color: rgba(0, 0, 0, var(--shadow-alpha, 0.02)); 
        pointer-events: none; z-index: 1; transition: background-color 0.1s ease-in-out;
    }
    .transmitter.shadowed-cell::after, .obstacle-normal.shadowed-cell::after, .obstacle-heavy.shadowed-cell::after { display: none; }

    .tooltip {
      position: absolute; background: linear-gradient(135deg, #2c3e50, #34495e); 
      color: white; padding: 10px 15px; border-radius: 8px; font-size: 12px; pointer-events: none;
      white-space: nowrap; transform: translate(-50%, -120%); z-index: 1000;
      box-shadow: 0 5px 25px rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.15);
    }
    .output-section {
      margin-bottom: 20px; padding: 15px; background: rgba(245, 245, 245, 0.95); 
      border-radius: 10px; border-left: 4px solid #667eea;
    }
    .output-section h4 { margin: 0 0 12px 0; color: #2c3e50; font-size: 1.1em; font-weight: 600; }
    .metric { display: flex; justify-content: space-between; align-items: center; margin: 8px 0; padding: 6px 0; border-bottom: 1px solid rgba(0,0,0,0.08); }
    .metric:last-child { border-bottom: none; }
    .metric-label { font-weight: 500; color: #34495e; font-size: 0.9em; }
    .metric-value { font-family: 'Courier New', monospace; font-weight: bold; color: #2c3e50; font-size: 0.95em; }

    .status-indicator { padding: 12px; border-radius: 8px; text-align: center; font-weight: 600; margin-top: 10px; transition: all 0.3s ease; text-shadow: 0 1px 1px rgba(0,0,0,0.2); }
    .status-excellent { background: linear-gradient(135deg, #2ecc71, #27ae60); color: white; }
    .status-good { background: linear-gradient(135deg, #f1c40f, #f39c12); color: white; }
    .status-fair { background: linear-gradient(135deg, #e67e22, #d35400); color: white; }
    .status-poor { background: linear-gradient(135deg, #e74c3c, #c0392b); color: white; }

    .legend {
      margin-top: 20px; padding: 15px; background: rgba(255, 255, 255, 0.9);
      border-radius: 10px; border: 1px solid rgba(102, 126, 234, 0.15);
      width: 558px; display: flex; flex-wrap: wrap; justify-content: center; 
      gap: 15px; align-items: center; 
    }
    .legend h4 {
      margin: 0 0 12px 0; color: #2c3e50; font-size: 1em;
      font-weight: 600; flex-basis: 100%; text-align: center;
    }
    .legend-item { display: flex; align-items: center; margin: 0; font-size: 0.85em; color: #34495e; }
    .legend-color {
      width: 20px; height: 20px; border-radius: 4px;
      margin-right: 10px; border: 1px solid #bdc3c7; flex-shrink: 0;
    }

    .instructions { font-size: 0.85em; color: #34495e; margin-top: 15px; padding: 12px; background: linear-gradient(135deg, #ecf0f1, #e0e6e8); border-radius: 8px; border-left: 4px solid #f39c12; line-height: 1.4; }
    button { padding: 12px; background: linear-gradient(135deg, #667eea, #764ba2); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 0.95em; margin-top: 15px; transition: all 0.3s ease; text-shadow: 0 1px 1px rgba(0,0,0,0.2); }
    button:hover { transform: translateY(-2px); box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4); filter: brightness(1.1); }
    .mode-buttons { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; margin-top: 10px; }
    .mode-btn { padding: 8px 4px; margin: 0; font-size: 0.8em; border-radius: 6px; }
    .mode-btn.active { background: linear-gradient(135deg, #2ecc71, #27ae60); transform: scale(0.97); box-shadow: inset 0 1px 3px rgba(0,0,0,0.2); }
    .progress-bar { width: 100%; height: 8px; background: rgba(0,0,0,0.08); border-radius: 4px; overflow: hidden; margin: 5px 0; }
    .progress-fill { height: 100%; transition: width 0.3s ease; }
    #outageProgress.progress-fill { background: linear-gradient(90deg, #e74c3c, #c0392b); }
    
    .chart-control-group { display: flex; flex-direction: column; gap: 5px; }
    .chart-control-group label { font-size: 0.85em; font-weight: 600; color: #444; }
    .chart-control-group select { padding: 8px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.85em; }

  </style>
</head>
<body>

  <div class="top-header">
      <div class="header-left">
          <div class="header-logo">
            <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABACAYAAACwI12/AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAd8SURBVHhe7Z1/aFzVFMf/4i4FhaWgsHWWbL/YKd2Y6tTWdKpd2rppY0zXNl1p59p1t/NH1Jj+oU2t/dP+0c5Ms00z3dSuM5F1g60sFGxBW7aCsoKWFhQUXNwfv/e+3Lu7d+/d3Xv33t37fpDPvefeez7fO+fcc899jgiDITgRgpNAOAnESSA8P/JmZmYyJpPJG8eOHXv+i1/8YseZM2cK/jX/gQMHhuvr62P+02Qyeaqvr9/b19e34+LFi1/+j48fPz598ODBWa8mP5XwM+k+ffr03p4+fXq7J5LJ5D8HBwe/sMlk8kIikei0vLw8v9fW1re++OKL1x49evT+QCCwUuA4w4MDBw48Nzc3/wM8tLa2/mF3d/f+vr6+/f2Y3W6/y+VyeXl5eQYAw8PDA4VCIQcHB/d+9dVXP/3zn/88MDBg+fDhwz//+OOPB/7D4cOHDw8NDc08Pz//5s2b1z+RSCxub29f+uKLL/79pz/96S+//vrr9+/fvz/nB/x4h/l4R4S+0sWLFy8fPXr0n5uamsLhcDiZTG7c3t5+48aNG//8xS9+seT5z3/+85MnTz7/0EMP/emHP/zh8vPzf8JjsdjBwYF/Ghoa8p937979/Z/+9KevXrt27V88Hg8AlpWVjS8uLr4A+C7gYv9x4MCB4UAgkEwmk4eGht748ssv/+ztt99+78Ybb1y8ffv2rdu3b79z8ODBt9avX7/97LPP/qG3t/f2wYMHv77zzjt/+MEHHxw9derUtz755JP/+MUvfuHvjz/++Gcvvvjit7Zt23bqwQcefP7SSy999umnn370+eef/31HR8d/e/r06d5AIPAe5N/+9rc/W15e3ru8vPx7e3v7/gB+Bnj4f/7nf75+/fr1P1auXLnxq6++unX27NkvX3vttVdeffXVq++8885b58+f/ePFF1888uSTT55+4oknHnvIIYdefOqpp5554YUXnnjoIYdefPLJJ5988smnfvvb3776wAMP/OHuu+/e/vTTT//4oYce+vzNN9+8evjw4S///ve//y8iIvnW1ta2vr6+vrNnz94E8O3du3dnZ2dnJ8B/vXr16l/v2bPn7o8++uize/fuff/yyy//++abb3737t27X92+ffv6jz/++L07d+78y5/+9Kcvfvazn5370IMOPviAAw447Mgjjzz2+OOPP/7UU0+9+uSTTz7+5JNP/v0vf/nL6z/+8Y+///jjj/9+/fXXP926dev6jz/++N6VK1euXLhw4W/k4fLly9++/vrrv718+fK/Jycnh8Lh8Ddv3rz561//enZ6enr3pUuXPnzppZduv+KKK9+7fPnyt5977rlv7969++7cuXP1+vXrb7z00kvfe/XVV1/cvHnz0o8//vhvjz/++I9OP/30ox955JEjRxxxxJEnnHDCiZdeemn1qSee+P1zn/vcK3/xi198/Z//+Z8nn3jiiSeeeeYZP/7xj7/64osvDvxvHl68ePGPvvDCC59ZvHjxL37ve9879u///u/PfuITnzh92mmnPXLdddfde8kll9z/kksu6f/www+fePXVV9+9c+fO9z766KPffPLJJ69+/fXXv9u3b9968803/75169a/Xb9+/e+3bt1688MPP7w+ePDgl379619/8+ijjz7+pS996R+uv/76ox9zzDEHHHLEEW8/+eSTpz///Oc/e9ddd10L+K8A6J/61Kf+8+c//3nx3nvv/eK111776l/+8pffPv/5z5/88ksvPXLxxRf/rD59+vTPn//856effvrpu/fu3bu/t7e3LzKZzI1nzpy57uTkZN8J75xOJhcKhYLvI38u4WfSNZlMfnz8+PFTX/nKV544derUd+7evfuHnp6eP375y1++8qKLLrrolVde+ZcnTpy46ZFHHvnp3/7t3z/3i1/8YvL+++9/5mmnnXYkLd0/4+iB84d+8Id/WPrgBz/49Hvvvbcyk/7vI+x0Ytq0adN+9913v2/Tpk0P/+hHPzp0xhlnnLbUUkvV2Nzc/AxgHj9+7AG2trZ+vLCwcI5PJtN1H6EAfvjw4c0DAwPfh/6/j7BTT0+PxR65fF6k+b9yWVkD4TCAk+o86s7/H08I4UYE5xPCCSF8G4IzzqA6lUwmjS1atOi/gYGBf2fWrFm/+p//+Z8nP/jBDz56+umnB35F+A2H4ERQeAZp3H///ccfccQRxx5wwAGHHHLIIWcefuuudx3z9NNPT1p33XXffOqpp556xBFHHH7AAQeeeOihhx5w/PHHn/nJT35S/l/+8pd7L7roolf+9re//e1//OMfpw95yEMO/eY3v3nnSy+99LvvvvvusQMPPPDwwx/+8BXP3/nOdz534xvfuFzPzz//PPDznve8p5144okP3XTTTT/90pe+tOzggw8+4oQTTjjywAMPTk7+AOH+IAnr+w844IDXTTvttCNf/OIXTx333HPfOOCAAz/7hS984fnPfvazX3zxi1985uSTT/74qquu+sqZZ55513vf+96xzzrrrOPPP//8s0ceeWSW7T/zzDO/+u53v/v15z//+VlPfvKTn93yyiuvPOyCCy648K1vfes9b3rTmx78r//6r8eOP/74w4cffvghP/rRj14wffr06Wn+6Jtvvvnqgw8++H+eeuqp+dMvvvjijy+88MKuE044oeyBBx748I9//OP8qUceeWQ/9thjz7r88sunPvaxj33L2muvvfrYY489dvTRRx9z5ZVX/v3NN998+/zzzz/bL3/5y8mTn/zkvQ/+8If3HnDAAYdfcslla/9f/OIXv7j33nuvvfbaa99zxz/+8Y+f/853vvP0K1/5ypNf/OIXnz/84Q+nzz///BOf/exnf/zFL34xeeY3v/mtW88888z/m//P52f/4p3vfOePfvjDHx550EEHHXjooYcOPfjgg/fuvffea6fMvY/wzIULF86dPn366Tdv3nxlWVlZ5eLi4j/JZNIfhUIhZ2dn/wf8u4V/1/9Xv//970894IAD/v3vf//603/91389+/e//33+3jBv/c53vvPxv//7vw9++9vfnv2Nb3zjwne/+91773vf+4668sorp3z2s5/9xle/+tVT//qv/+q5Wd59990nn3nmmWefeOKJJx7+6le/uv3hD3/4wXPPPfc1S9b//Oc/Zz/22GN/OPWlL33pqU9+8pN/+8UvfvH85S9/+ZXPf/7zv/nNfN88+qtf/epTf/jDH245/vjjZz3//POvPP7440+f//znv/WlL33peT+7N4SfsA5gMpm8tLCwsD9r1qy55pRTTjl16dKl46uuuur68ccfv33+/PkzJ5100kunnXbaKWeeeeZJJ5xwwvGHH37k+OOPv+KWW265+tprr/3lueeeu+Oee+5Z8fTTT8+Y/5/+9KcnHXnkkQcdccQRx1166aXTzznnnH/90Y9+9PTPfOYzxx5xxBFHH3DAAUe+9KUvvfLyyy/vPWfOnL8A8D8Lh+BEUJqQz/3ud79zzTXXXDPrrLPODj/88D/87Gc/m1vG8/Lll18eOvXUU6cdfuqppx5++OEHP/nJT35yyCGH3HLCCSceduyxx+Yt4PzP//zPr+6///5zRxxxxLGHHXbYI8ccc8x/Pvf888+fnP8nBOfE+hYOh4N8o4T/Vf24pP2X/+S/wI+RkZFLv/jFL/6dE088cXpLS0u//vzzz2+//PJLT87Pz//5i1/8YvLhD3/4lP/5n/957vjjj8/fcsstS86YMeV/7fX+hA+n4ERQehOSeX/++c9/nve///3/uvTSSydfd91185+9l/y//OUv3znqqKPO/q//+q+TH/zgBz9y1VXXbF8B5/k34X8Lh+BEUJqQjL///e/nnnXWWQdffvnlm7/y5JNPnrvrrrte/bKXvWz13//930+effbZ/6k+ffoU/+M/+a/Yv0/42e88EobgRFCa/f+s9h8X3v2Qo4b7H/dF/QyX50vY/0+i/B7wW//2b39X/l/+8pd7L7744hPuvvvus2+++eaU008//bW333575l/+5V8OvvTSS8+86KKLjjr77LN/9Sc/+cmsc845Z/5//+//vuyf/+mfnnzIIYccdcQRR3z2//7v/x508skn/+bYY48N+C/+4i/+wn/+85/THnzwwQk///nP/y7r93B/jMvzm/v8c9b2d35Q/6tXfF+X1+0t5W9oV4P7h4+r//0X8l0Xf/m/77r1v/D+D+f+yS/d+v4B/m+7811+u+sPq+4f6h8oT/+L839s/s+9O/l/x++5t+b+c9r/13y7+9fB/y/l39v6+y/s/9v+34/8/yv7/+j+n9a/+39r6P/3/m+d/oPr71D+3/n7h/n7l//f1P9e/39x/x91/x+N/4v7v7b/n/oH/l+h//+P/N+P/R/p+4/d/+9v/w8EITgRhJNAOAHEb7Y3h/8A4Fk/r6Q0t4wAAAAASUVORK5CYII=" alt="Virtual Labs Logo">
            <span class="header-logo-text">Virtual Labs</span>
          </div>
      </div>
      <div class="header-right">
          <span class="page-title">Pathloss and Shadowing</span>
          <button class="report-bug-btn">Report a Bug</button>
      </div>
  </div>

  <div class="main-tasks-container">
      <button id="simulation-task-btn" class="main-task-btn active" onclick="switchMainTask('simulation')">Pathloss Simulation</button>
      <button id="analysis-task-btn" class="main-task-btn" onclick="switchMainTask('analysis')">Analysis Plots</button>
  </div>

  <div class="page-container">
    <div id="simulation-page" class="page-content active">
      <div id="inputs">
        <h3>System Parameters</h3>
        <div class="input-group"> <label for="setting">Environment Type:</label> <select id="setting"> <option value="urban">Urban (High Interference)</option> <option value="suburban">Suburban (Medium)</option> <option value="rural">Rural (Low Interference)</option> </select> </div>
        <div class="input-group"> <label for="Pt">Transmitter Power (dBm):</label> <input type="number" id="Pt" value="30" min="0" max="50" step="1"> </div>
        <div class="input-group"> <label for="Pmin">Min Required Power (dBm):</label> <input type="number" id="Pmin" value="-85" min="-120" max="-50" step="1"> </div>
        <div class="input-group"> <label for="frequency">Frequency (MHz):</label> <input type="number" id="frequency" value="900" min="400" max="6000" step="50"> </div>
        <div class="input-group"> <label for="obstacleDensity">Obstacle Density (per 100 cells):</label> <input type="number" id="obstacleDensity" value="2" min="0" max="20" step="0.1"> </div>
        <div class="input-group"> <label>Click Mode:</label> <div class="mode-buttons"> <button class="mode-btn active" onclick="setMode('normal')">Normal</button> <button class="mode-btn" onclick="setMode('heavy')">Heavy</button> <button class="mode-btn" onclick="setMode('erase')">Erase</button> </div> </div>
        <button onclick="clearAll()">Clear All Obstacles</button> 
        <button onclick="randomObstacles()">Generate Layout from Density</button>
        <div class="instructions"> <strong>Instructions:</strong><br> • Yellow circle = Transmitter<br> • Click cells to place obstacles<br> • Red outlined cells = Outage<br> • Tinged cells = Shadowed by obstacle<br> • Hover for detailed cell info<br> • Adjust parameters to see effects </div>
      </div>

      <div id="simulation"> 
          <div class="grid-container" id="grid-container"></div> 
          <div class="legend"> 
            <h4>Legend</h4>
            <div class="legend-item"> <div class="legend-color" style="background: radial-gradient(circle, #ffeb3b, #ff9800); border-radius: 50%;"></div> <span>Transmitter</span> </div>
            <div class="legend-item"> <div class="legend-color" style="background: linear-gradient(45deg, #555, #777);"></div> <span>Normal Obstacle</span> </div> 
            <div class="legend-item"> <div class="legend-color" style="background: linear-gradient(45deg, #7A0000, #C01030);"></div> <span>Heavy Obstacle</span> </div>
            <div class="legend-item"> <div class="legend-color" style="background: #00ff00;"></div> <span>Strong Signal</span> </div> 
            <div class="legend-item"> <div class="legend-color" style="background: #ffff00;"></div> <span>Medium Signal</span> </div> 
            <div class="legend-item"> <div class="legend-color" style="background: #ff0000;"></div> <span>Weak Signal</span> </div> 
            <div class="legend-item"> <div class="legend-color" style="box-shadow: inset 0 0 0 1px #dd0033;"></div> <span>Outage</span> </div> 
            <div class="legend-item"> <div class="legend-color" style="background-color: rgba(0,0,0,0.15); border: 1px dashed #555;"></div> <span>Shadow Tinge</span> </div> 
          </div>
      </div>

      <div id="outputs">
        <h3>Results & Analysis</h3>
        <div class="output-section">
          <h4>Coverage Metrics</h4>
          <div class="metric"> <span class="metric-label">Outage Probability:</span> <span class="metric-value" id="outageProb">0.00%</span> </div>
          <div class="progress-bar"> <div class="progress-fill" id="outageProgress" style="width: 0%;"></div> </div>
          <div class="metric"> <span class="metric-label">Coverage Area:</span> <span class="metric-value" id="coverageArea">100.00%</span> </div>
          <div class="metric"> <span class="metric-label">Cells in Outage:</span> <span class="metric-value" id="outageCells">0 / 929</span> </div>
        </div>
        <div class="output-section">
          <h4>Signal Analysis</h4>
          <div class="metric"> <span class="metric-label">Avg Rx Power (Covered):</span> <span class="metric-value" id="avgReceivedPower">0.00 dBm</span> </div>
          <div class="metric"> <span class="metric-label">Min Rx Power (Covered):</span> <span class="metric-value" id="minReceivedPower">0.00 dBm</span> </div>
          <div class="metric"> <span class="metric-label">Max Rx Power (Covered):</span> <span class="metric-value" id="maxReceivedPower">0.00 dBm</span> </div>
          <div class="metric"> <span class="metric-label">Signal Dynamic Range:</span> <span class="metric-value" id="signalRange">0.00 dB</span> </div>
        </div>
        <div class="output-section">
          <h4>Path Loss Analysis</h4>
          <div class="metric"> <span class="metric-label">Avg Total Path Loss:</span> <span class="metric-value" id="avgPathloss">0.00 dB</span> </div>
          <div class="metric"> <span class="metric-label">Avg Obstacle Shadow (dB):</span> <span class="metric-value" id="avgShadowLoss">0.00 dB</span> </div>
          <div class="metric"> <span class="metric-label">Max Coverage Distance:</span> <span class="metric-value" id="maxDistance">0.00 km</span> </div>
        </div>
        <div class="output-section">
          <h4>Environment Impact</h4>
          <div class="metric"> <span class="metric-label">Environment Factor:</span> <span class="metric-value" id="envFactor">Urban</span> </div>
          <div class="metric"> <span class="metric-label">Obstacle Count:</span> <span class="metric-value" id="obstacleCount">0</span> </div>
          <div class="metric"> <span class="metric-label">Shadowing Model:</span> <span class="metric-value" id="shadowingFactor">Obstacle-based</span> </div>
        </div>
        <div class="status-indicator" id="systemStatus"> System Status: Excellent Coverage </div>
      </div>
    </div>
    
    <div id="analysis-page" class="page-content">
      <h3>Signal Analysis Plots</h3>
      <div class="chart-controls">
        <div class="chart-control-group">
          <label for="chartType">Chart Type:</label>
          <select id="chartType" onchange="updateChart()">
            <option value="snr-distance">SNR vs Distance</option>
            <option value="power-distance">Received Power vs Distance</option>
            <option value="pathloss-distance">Path Loss vs Distance</option>
            <option value="outage-distance">Outage Probability vs Distance</option>
          </select>
        </div>
        <div class="chart-control-group">
          <label for="chartData">Data Filter:</label>
          <select id="chartData" onchange="updateChart()">
            <option value="all">All Cells</option>
            <option value="covered">Covered Only</option>
            <option value="outage">Outage Only</option>
          </select>
        </div>
      </div>
      <div class="chart-container"> <canvas id="analysisChart"></canvas> </div>
      <div class="output-section">
        <h4>Chart Statistics</h4>
        <div class="metric"> <span class="metric-label">Data Points:</span> <span class="metric-value" id="chartDataPoints">0</span> </div>
        <div class="metric"> <span class="metric-label">Correlation (R²):</span> <span class="metric-value" id="chartCorrelation">N/A</span> </div>
        <div class="metric"> <span class="metric-label">Trend:</span> <span class="metric-value" id="chartTrend">N/A</span> </div>
      </div>
    </div>
  </div>

<script>
// --- [The entire JavaScript code remains the same, but with the following modifications] ---
// --- [I will list only the changed/added parts of the script for brevity] ---

/* --- ADD THIS NEW FUNCTION AT THE TOP OF THE SCRIPT --- */
function switchMainTask(taskName) {
  // Hide all main pages
  document.querySelectorAll('.page-content').forEach(page => page.classList.remove('active'));
  // Deactivate all task buttons
  document.querySelectorAll('.main-task-btn').forEach(btn => btn.classList.remove('active'));

  // Activate the selected page and button
  document.getElementById(taskName + '-page').classList.add('active');
  document.getElementById(taskName + '-task-btn').classList.add('active');

  // If switching to analysis, ensure chart is up to date
  if (taskName === 'analysis') {
    setTimeout(updateChart, 100); // Small delay to ensure tab is visible and rendered
  }
}

/* --- REMOVE THE OLD switchTab FUNCTION --- */
// function switchTab(tabName) { ... } // This entire function is deleted.


/* --- MODIFY THE initialize FUNCTION --- */
function initialize() {
  createGrid(); 
  setupInputListeners();
  setMode('normal'); 
  // Set the initial view to the simulation page
  switchMainTask('simulation'); 
  updatePathlossAndMetrics();
  loadChartJS();
}


/* --- MODIFY THE updatePathlossAndMetrics FUNCTION --- */
// Replace the old function with this new version to always update the chart data
const originalUpdatePathlossAndMetrics = updatePathlossAndMetrics;
updatePathlossAndMetrics = function() {
  originalUpdatePathlossAndMetrics();
  // Always update chart data in the background when parameters change.
  // The chart will only render when its page is visible.
  if (analysisChart) {
    updateChart();
  }
};

/* --- The rest of your JavaScript from the prompt goes here, unchanged, --- */
/* --- except for the parts mentioned above.                            --- */

// --- START OF ORIGINAL JAVASCRIPT TO BE PLACED HERE --- //
// Configuration
const gridSize = 18; 
const rows = 31;
const cols = 31;
const transmitter = { x: Math.floor(cols / 2), y: Math.floor(rows / 2) }; 
const CELL_SIZE_METERS = 100; 

let currentMode = 'normal'; 
let cells = [];

// Shadow Fading Effect Constants
const MAX_SHADOW_FADE_DISTANCE_GRID_UNITS = 12; 
const MAX_VISUAL_ALPHA = 0.03; 
const MIN_VISUAL_ALPHA = 0.002; 


const environmentFactors = {
  urban: { pathLossOffset: 5, name: "Urban" },     
  suburban: { pathLossOffset: 2, name: "Suburban" }, 
  rural: { pathLossOffset: 0, name: "Rural" }      
};

const gridContainer = document.getElementById("grid-container");
gridContainer.style.display = 'grid';
gridContainer.style.gridTemplateRows = `repeat(${rows}, ${gridSize}px)`;
gridContainer.style.gridTemplateColumns = `repeat(${cols}, ${gridSize}px)`;
gridContainer.style.width = `${cols * gridSize}px`; 
gridContainer.style.height = `${rows * gridSize}px`; 

const tooltip = document.createElement("div");
tooltip.className = "tooltip";
tooltip.style.display = "none";
document.body.appendChild(tooltip);

function createGrid() {
  gridContainer.innerHTML = ''; 
  cells = [];
  
  for (let row = 0; row < rows; row++) {
    cells[row] = [];
    for (let col = 0; col < cols; col++) {
      const cellElement = document.createElement("div");
      cellElement.classList.add("cell");
      cellElement.dataset.row = row;
      cellElement.dataset.col = col;

      if (row === transmitter.y && col === transmitter.x) {
        cellElement.classList.add("transmitter");
      }

      gridContainer.appendChild(cellElement); 
      cells[row][col] = {
        element: cellElement, basePathloss: 0, currentPathloss: 0, receivedPower: 0,
        lossComponents: { base: 0, obstacleShadow: 0 }, 
        obstacleType: null, isOutage: false, distance: 0,
        isVisuallyShadowed: false, 
        distanceForTinge: MAX_SHADOW_FADE_DISTANCE_GRID_UNITS + 1,
        lateralScaleForTinge: 0 
      };

      cellElement.addEventListener('click', () => handleCellClick(row, col));
      cellElement.addEventListener('mouseover', (e) => showTooltip(e, row, col));
      cellElement.addEventListener('mouseout', () => hideTooltip());
    }
  }
}

function calculateFreeSpacePathLoss(distanceM, frequencyMHz) {
  if (distanceM <= 0) return 0; 
  return 20 * Math.log10(distanceM) + 20 * Math.log10(frequencyMHz) - 27.55;
}

function calculatePathLoss(distanceM, frequencyMHz, environment) {
  if (distanceM <= 0) return 0;
  const freeSpacePL = calculateFreeSpacePathLoss(Math.max(1, distanceM), frequencyMHz); 
  const envData = environmentFactors[environment];
  return freeSpacePL + envData.pathLossOffset; 
}

function isPointShadowed(targetCol, targetRow, obstacleCol, obstacleRow, obstacleType) {
    const tx = transmitter.x;
    const ty = transmitter.y;

    const vec_tx_obs_x = obstacleCol - tx;
    const vec_tx_obs_y = obstacleRow - ty;
    const vec_tx_target_x = targetCol - tx;
    const vec_tx_target_y = targetRow - ty;

    const dist_tx_obs_sq = vec_tx_obs_x * vec_tx_obs_x + vec_tx_obs_y * vec_tx_obs_y;
    const dist_tx_target_sq = vec_tx_target_x * vec_tx_target_x + vec_tx_target_y * vec_tx_target_y;

    if (dist_tx_target_sq <= dist_tx_obs_sq) {
        return { isShadowed: false, baseAttenuation: 0, distanceInShadow: 0, lateralScale: 0 };
    }

    const dotProduct = vec_tx_obs_x * vec_tx_target_x + vec_tx_obs_y * vec_tx_target_y;
    if (dotProduct <= 0 || dotProduct < dist_tx_obs_sq) {
        return { isShadowed: false, baseAttenuation: 0, distanceInShadow: 0, lateralScale: 0 };
    }

    const dist_tx_obs = Math.sqrt(dist_tx_obs_sq);
    if (dist_tx_obs < 0.1) {
        return { isShadowed: false, baseAttenuation: 0, distanceInShadow: 0, lateralScale: 0 };
    }
    
    const perpendicularDistance = Math.abs(vec_tx_obs_x * vec_tx_target_y - vec_tx_obs_y * vec_tx_target_x) / dist_tx_obs;
    const distanceInShadow = Math.sqrt(dist_tx_target_sq) - dist_tx_obs;

    const INITIAL_SHADOW_WIDTH = 0.6; 
    const SHADOW_SPREAD_FACTOR = 0.35; 
    const CORE_PERCENTAGE_OF_CONE = 0.3; 
    const PENUMBRA_TOTAL_PERCENTAGE_OF_CONE = 1.0; 
    const currentMaxConeHalfWidth = INITIAL_SHADOW_WIDTH + (distanceInShadow * SHADOW_SPREAD_FACTOR);

    let lateralScale = 0; 

    if (perpendicularDistance <= currentMaxConeHalfWidth * CORE_PERCENTAGE_OF_CONE) {
        lateralScale = 1.0;
    } else if (perpendicularDistance <= currentMaxConeHalfWidth * PENUMBRA_TOTAL_PERCENTAGE_OF_CONE) {
        const coreEdge = currentMaxConeHalfWidth * CORE_PERCENTAGE_OF_CONE;
        const penumbraEdge = currentMaxConeHalfWidth * PENUMBRA_TOTAL_PERCENTAGE_OF_CONE;
        if (penumbraEdge > coreEdge) {
            lateralScale = 1.0 - (perpendicularDistance - coreEdge) / (penumbraEdge - coreEdge);
            lateralScale = Math.max(0, Math.min(1, lateralScale)); 
        } else { 
            lateralScale = (coreEdge === 0 && penumbraEdge === 0 && perpendicularDistance === 0) ? 1.0 : 0;
        }
    } else {
        return { isShadowed: false, baseAttenuation: 0, distanceInShadow: 0, lateralScale: 0 };
    }

    let baseAttenuationDb = 0;
    if (obstacleType === "heavy") {
        baseAttenuationDb = 35; 
    } else if (obstacleType === "normal") {
        baseAttenuationDb = 18;
    }
    
    const scaledBaseAttenuation = baseAttenuationDb * lateralScale;

    return { 
        isShadowed: lateralScale > 0.001, 
        baseAttenuation: scaledBaseAttenuation, 
        distanceInShadow: distanceInShadow,
        lateralScale: lateralScale 
    };
}

function getEffectiveShadowProperties(targetRow, targetCol, allObstacles) {
    let strongestEffectiveAttenuation = 0;
    let isVisuallyShadowedByAny = false;
    let distanceForTingeVisual = MAX_SHADOW_FADE_DISTANCE_GRID_UNITS + 1;
    let strongestLateralScaleForTinge = 0; 

    for (const obs of allObstacles) {
        const shadowDetails = isPointShadowed(targetCol, targetRow, obs.x, obs.y, obs.type);

        if (shadowDetails.isShadowed) { 
            isVisuallyShadowedByAny = true; 

            const distanceFadeFactor = Math.max(0, 1 - (shadowDetails.distanceInShadow / MAX_SHADOW_FADE_DISTANCE_GRID_UNITS));
            const currentEffectiveAttenuation = shadowDetails.baseAttenuation * distanceFadeFactor;

            if (currentEffectiveAttenuation > strongestEffectiveAttenuation) {
                strongestEffectiveAttenuation = currentEffectiveAttenuation;
                distanceForTingeVisual = shadowDetails.distanceInShadow;
                strongestLateralScaleForTinge = shadowDetails.lateralScale;
            } else if (currentEffectiveAttenuation === strongestEffectiveAttenuation) {
                if (shadowDetails.lateralScale > strongestLateralScaleForTinge) {
                    distanceForTingeVisual = shadowDetails.distanceInShadow;
                    strongestLateralScaleForTinge = shadowDetails.lateralScale;
                } else if (shadowDetails.lateralScale === strongestLateralScaleForTinge && shadowDetails.distanceInShadow < distanceForTingeVisual) {
                    distanceForTingeVisual = shadowDetails.distanceInShadow;
                }
            }
        }
    }
    return {
        attenuation: strongestEffectiveAttenuation,
        isVisuallyShadowed: isVisuallyShadowedByAny,
        distanceForTinge: distanceForTingeVisual,
        lateralScaleForTinge: strongestLateralScaleForTinge 
    };
}

function powerToColor(Pr) {
    const weakPowerThreshold = -80;    
    const strongPowerThreshold = -60;  
    const mediumPowerPoint = (weakPowerThreshold + strongPowerThreshold) / 2; 

    const R_RED = 255, G_RED = 0, B_RED = 0;         
    const R_YELLOW = 255, G_YELLOW = 255, B_YELLOW = 0; 
    const R_GREEN = 0, G_GREEN = 255, B_GREEN = 0;    

    let r, g, b;

    if (Pr <= weakPowerThreshold) { 
        [r, g, b] = [R_RED, G_RED, B_RED];
    } else if (Pr < mediumPowerPoint) { 
        const t = (Pr - weakPowerThreshold) / (mediumPowerPoint - weakPowerThreshold);
        r = Math.round(R_RED * (1 - t) + R_YELLOW * t);
        g = Math.round(G_RED * (1 - t) + G_YELLOW * t);
        b = Math.round(B_RED * (1 - t) + B_YELLOW * t);
    } else if (Pr < strongPowerThreshold) { 
        const t = (Pr - mediumPowerPoint) / (strongPowerThreshold - mediumPowerPoint);
        r = Math.round(R_YELLOW * (1 - t) + R_GREEN * t);
        g = Math.round(G_YELLOW * (1 - t) + G_GREEN * t);
        b = Math.round(B_YELLOW * (1 - t) + B_GREEN * t);
    } else { 
        [r, g, b] = [R_GREEN, G_GREEN, B_GREEN];
    }
    return `rgb(${Math.max(0, Math.min(255, r))},${Math.max(0, Math.min(255, g))},${Math.max(0, Math.min(255, b))})`;
}


function updateCellPathloss(row, col, obstaclesData) {
  const cell = cells[row][col];
  const Pt = parseFloat(document.getElementById('Pt').value); 

  cell.isVisuallyShadowed = false; 
  cell.distanceForTinge = MAX_SHADOW_FADE_DISTANCE_GRID_UNITS + 1; 
  cell.lateralScaleForTinge = 0;

  if (row === transmitter.y && col === transmitter.x) {
    cell.receivedPower = Pt; cell.currentPathloss = 0; cell.isOutage = false; cell.distance = 0;
    cell.lossComponents = { base: 0, obstacleShadow: 0 };
    updateCellAppearance(cell); return cell;
  }
  
  if (cell.obstacleType) {
    cell.receivedPower = -200; cell.currentPathloss = Pt - cell.receivedPower; cell.isOutage = true; 
    cell.distance = Math.sqrt((col - transmitter.x)**2 + (row - transmitter.y)**2) * CELL_SIZE_METERS;
    cell.lossComponents = { base: cell.currentPathloss, obstacleShadow: 0 };
    updateCellAppearance(cell); return cell;
  }

  const distanceGrid = Math.sqrt((col - transmitter.x)**2 + (row - transmitter.y)**2);
  const distanceM = distanceGrid * CELL_SIZE_METERS;
  cell.distance = distanceM;

  const Pmin = parseFloat(document.getElementById('Pmin').value);
  const frequencyVal = parseFloat(document.getElementById('frequency').value);
  const environmentVal = document.getElementById('setting').value;

  cell.basePathloss = calculatePathLoss(distanceM, frequencyVal, environmentVal);
  cell.lossComponents.base = cell.basePathloss;

  const shadowProps = getEffectiveShadowProperties(row, col, obstaclesData);
  const obstacleShadowAttenuation = shadowProps.attenuation;
  cell.isVisuallyShadowed = shadowProps.isVisuallyShadowed;
  cell.distanceForTinge = shadowProps.distanceForTinge; 
  cell.lateralScaleForTinge = shadowProps.lateralScaleForTinge;

  cell.lossComponents.obstacleShadow = obstacleShadowAttenuation;
  
  cell.currentPathloss = cell.basePathloss + obstacleShadowAttenuation;
  cell.receivedPower = Pt - cell.currentPathloss;
  cell.isOutage = cell.receivedPower < Pmin;

  updateCellAppearance(cell);
  return cell;
}

function updateCellAppearance(cell) {
  const cellElement = cell.element;
  cellElement.classList.remove('outage-cell', 'shadowed-cell');
  cellElement.style.removeProperty('--shadow-alpha'); 

  if (cellElement.classList.contains("transmitter")) return; 
  
  if (cell.obstacleType) {
    cellElement.classList.add('outage-cell'); 
    return;
  }

  cellElement.style.backgroundColor = powerToColor(cell.receivedPower);

  if (cell.isVisuallyShadowed && cell.lateralScaleForTinge > 0.001) {
      cellElement.classList.add('shadowed-cell');
      
      const distanceFadeRatio = Math.max(0, 1 - (cell.distanceForTinge / MAX_SHADOW_FADE_DISTANCE_GRID_UNITS));
      const maxAlphaAtThisDistance = MIN_VISUAL_ALPHA + (MAX_VISUAL_ALPHA - MIN_VISUAL_ALPHA) * (1 - (1 - distanceFadeRatio) * (1 - distanceFadeRatio));
      const currentAlpha = maxAlphaAtThisDistance * cell.lateralScaleForTinge;

      cellElement.style.setProperty('--shadow-alpha', Math.max(0, currentAlpha).toFixed(3)); 
  }

  if (cell.isOutage) {
    cellElement.classList.add("outage-cell"); 
  }
}

function updatePathlossAndMetrics() {
  const obstaclesData = [];
  let totalPathlossSum = 0, totalReceivedPowerSum = 0, totalObstacleShadowSum = 0;
  let simulatedCellsCount = 0, outageCellsCount = 0;
  let minRxPowerCovered = Infinity, maxRxPowerCovered = -Infinity, maxCoverageDist = 0;
  let obstacleCount = 0;

  for (let r = 0; r < rows; r++) for (let c = 0; c < cols; c++) {
    if (cells[r][c].obstacleType) {
      obstaclesData.push({ x: c, y: r, type: cells[r][c].obstacleType });
      obstacleCount++;
    }
  }

  for (let r = 0; r < rows; r++) for (let c = 0; c < cols; c++) {
    const cellData = updateCellPathloss(r, c, obstaclesData); 
    if ((r === transmitter.y && c === transmitter.x) || cellData.obstacleType) continue; 

    simulatedCellsCount++;
    totalPathlossSum += cellData.currentPathloss;
    if (cellData.lossComponents) {
        totalObstacleShadowSum += cellData.lossComponents.obstacleShadow;
    }
    
    if (cellData.isOutage) outageCellsCount++;
    else {
      totalReceivedPowerSum += cellData.receivedPower; 
      minRxPowerCovered = Math.min(minRxPowerCovered, cellData.receivedPower);
      maxRxPowerCovered = Math.max(maxRxPowerCovered, cellData.receivedPower);
      maxCoverageDist = Math.max(maxCoverageDist, cellData.distance);
    }
  }
  
  const coveredCellsCount = simulatedCellsCount - outageCellsCount; 
  const outageProb = simulatedCellsCount > 0 ? (outageCellsCount / simulatedCellsCount) * 100 : 0;
  const coverageArea = simulatedCellsCount > 0 ? (coveredCellsCount / simulatedCellsCount) * 100 : 0;
  const avgPathloss = simulatedCellsCount > 0 ? totalPathlossSum / simulatedCellsCount : 0;
  const avgReceivedPower = coveredCellsCount > 0 ? totalReceivedPowerSum / coveredCellsCount : (simulatedCellsCount > 0 ? NaN : 0);
  const avgObstacleShadow = simulatedCellsCount > 0 ? totalObstacleShadowSum / simulatedCellsCount : 0;
  const signalRange = (maxRxPowerCovered !== -Infinity && minRxPowerCovered !== Infinity && maxRxPowerCovered > minRxPowerCovered) ? (maxRxPowerCovered - minRxPowerCovered) : 0;

  updateMetricDisplays({
    outageProb, coverageArea, 
    outageCells: outageCellsCount, 
    totalSimulatedCells: simulatedCellsCount, 
    avgPathloss, avgReceivedPower, 
    avgShadowLoss: avgObstacleShadow, 
    minRxPower: minRxPowerCovered === Infinity ? NaN : minRxPowerCovered,
    maxRxPower: maxRxPowerCovered === -Infinity ? NaN : maxRxPowerCovered,
    signalRange, maxCoverageDist: maxCoverageDist / 1000, obstacleCount
  });
}

function updateMetricDisplays(metrics) {
  document.getElementById('outageProb').textContent = `${metrics.outageProb.toFixed(2)}%`;
  document.getElementById('outageProgress').style.width = `${metrics.outageProb.toFixed(2)}%`;
  document.getElementById('coverageArea').textContent = `${metrics.coverageArea.toFixed(2)}%`;
  document.getElementById('outageCells').textContent = `${metrics.outageCells} / ${metrics.totalSimulatedCells}`; 
  document.getElementById('avgReceivedPower').textContent = `${isNaN(metrics.avgReceivedPower) ? 'N/A' : metrics.avgReceivedPower.toFixed(2)} dBm`;
  document.getElementById('minReceivedPower').textContent = `${isNaN(metrics.minRxPower) ? 'N/A' : metrics.minRxPower.toFixed(2)} dBm`;
  document.getElementById('maxReceivedPower').textContent = `${isNaN(metrics.maxRxPower) ? 'N/A' : metrics.maxRxPower.toFixed(2)} dBm`;
  document.getElementById('signalRange').textContent = `${metrics.signalRange.toFixed(2)} dB`;
  document.getElementById('avgPathloss').textContent = `${metrics.avgPathloss.toFixed(2)} dB`;
  document.getElementById('avgShadowLoss').textContent = `${metrics.avgShadowLoss.toFixed(2)} dB`; 
  document.getElementById('maxDistance').textContent = `${metrics.maxCoverageDist.toFixed(2)} km`;
  const environment = document.getElementById('setting').value;
  document.getElementById('envFactor').textContent = environmentFactors[environment].name;
  document.getElementById('obstacleCount').textContent = metrics.obstacleCount;
  document.getElementById('shadowingFactor').textContent = "Cone (Fading w/ Penumbra)"; 
  const statusIndicator = document.getElementById('systemStatus');
  statusIndicator.classList.remove('status-excellent', 'status-good', 'status-fair', 'status-poor');
  if (metrics.outageProb <= 5) { statusIndicator.textContent = "System Status: Excellent Coverage"; statusIndicator.classList.add('status-excellent');}
  else if (metrics.outageProb <= 15) { statusIndicator.textContent = "System Status: Good Coverage"; statusIndicator.classList.add('status-good');}
  else if (metrics.outageProb <= 30) { statusIndicator.textContent = "System Status: Fair Coverage"; statusIndicator.classList.add('status-fair');}
  else { statusIndicator.textContent = "System Status: Poor Coverage"; statusIndicator.classList.add('status-poor');}
}

function handleCellClick(row, col) {
  if (row === transmitter.y && col === transmitter.x) return; 
  const cell = cells[row][col];
  const cellElement = cell.element;
  cellElement.classList.remove('obstacle-normal', 'obstacle-heavy', 'outage-cell', 'shadowed-cell');
  cellElement.style.removeProperty('--shadow-alpha'); 
  cellElement.style.backgroundColor = ''; 
  if (currentMode === 'erase' || cell.obstacleType === currentMode) cell.obstacleType = null;
  else if (currentMode === 'normal') { cell.obstacleType = 'normal'; cellElement.classList.add('obstacle-normal'); }
  else if (currentMode === 'heavy') { cell.obstacleType = 'heavy'; cellElement.classList.add('obstacle-heavy'); }
  updatePathlossAndMetrics();
}

function showTooltip(event, row, col) {
    const cell = cells[row][col];
    if (!cell) return;
    let content = `Cell (${col}, ${row})<br>`;
    if (row === transmitter.y && col === transmitter.x) {
        content += `Type: Transmitter<br>Power: ${document.getElementById('Pt').value} dBm`;
    } else if (cell.obstacleType) {
        content += `Type: ${cell.obstacleType.charAt(0).toUpperCase() + cell.obstacleType.slice(1)} Obstacle`;
    } else {
        content += `Rx Power: ${cell.receivedPower.toFixed(2)} dBm<br>`;
        content += `Total PL: ${cell.currentPathloss.toFixed(2)} dB<br>`;
        if (cell.lossComponents) {
            content += `  Base Model PL: ${cell.lossComponents.base.toFixed(2)} dB<br>`;
            content += `  Obstacle Shadow: ${cell.lossComponents.obstacleShadow.toFixed(2)} dB<br>`;
        }
        content += `Distance: ${(cell.distance / 1000).toFixed(2)} km<br>`;
        
        if (cell.isOutage) {
            content += `Status: <span style="color: #ff6b6b; font-weight: bold;">Outage</span>`;
        } else {
            content += `Status: <span style="color: #69f0ae; font-weight: bold;">Covered</span>`;
        }
        
        if(cell.isVisuallyShadowed && cell.lateralScaleForTinge > 0.001) {
            const alpha = cell.element.style.getPropertyValue('--shadow-alpha');
            content += `<br><i>(In shadow, Tinge Alpha: ${alpha ? parseFloat(alpha).toFixed(3) : 'N/A'})</i>`;
        }
    }
    tooltip.innerHTML = content;
    tooltip.style.display = "block";
    const offset = 15; 
    let newX = event.clientX + offset, newY = event.clientY + offset;
    const tooltipRect = tooltip.getBoundingClientRect(), bodyRect = document.body.getBoundingClientRect();
    if (newX + tooltipRect.width > bodyRect.right) newX = event.clientX - tooltipRect.width - offset;
    if (newY + tooltipRect.height > bodyRect.bottom) newY = event.clientY - tooltipRect.height - offset;
    tooltip.style.left = `${Math.max(0, newX)}px`;
    tooltip.style.top = `${Math.max(0, newY)}px`;
}

function hideTooltip() { tooltip.style.display = "none"; }
function setMode(mode) {
  currentMode = mode;
  document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
  document.querySelector(`.mode-btn[onclick="setMode('${mode}')"]`).classList.add('active');
}

function clearAll() {
  for (let r = 0; r < rows; r++) for (let c = 0; c < cols; c++) {
    if (cells[r][c].obstacleType) {
      cells[r][c].obstacleType = null;
      cells[r][c].element.classList.remove('obstacle-normal', 'obstacle-heavy');
    }
  }
  updatePathlossAndMetrics();
}

function generatePoisson(mean) {
    if (mean <= 0) return 0;
    const L = Math.exp(-mean);
    let p = 1.0;
    let k = 0;
    do {
        k++;
        p *= Math.random();
    } while (p > L);
    return k - 1;
}

function randomObstacles() {
  clearAll(); 

  const densityPer100 = parseFloat(document.getElementById('obstacleDensity').value);
  const gridArea = rows * cols;
  const meanObstacles = (densityPer100 / 100) * gridArea;

  const numObstaclesToPlace = generatePoisson(meanObstacles);
  
  const maxPlaceable = gridArea - 1; 
  const numObstacles = Math.min(numObstaclesToPlace, maxPlaceable);

  for (let i = 0; i < numObstacles; i++) {
    let r, c;
    do { r = Math.floor(Math.random()*rows); c = Math.floor(Math.random()*cols); }
    while ((r === transmitter.y && c === transmitter.x) || cells[r][c].obstacleType);
    
    const type = Math.random() < 0.7 ? 'normal' : 'heavy'; 
    cells[r][c].obstacleType = type;
    cells[r][c].element.classList.add(type === 'normal' ? 'obstacle-normal' : 'obstacle-heavy');
  }
  updatePathlossAndMetrics();
}

function setupInputListeners() {
  const inputsToWatch = ['Pt', 'Pmin', 'frequency', 'setting']; 
  inputsToWatch.forEach(id => {
    const element = document.getElementById(id);
    element.addEventListener('change', updatePathlossAndMetrics);
    if (element.type === 'number') element.addEventListener('input', updatePathlossAndMetrics);
  });
}

// Chart functionality
let analysisChart = null;

function initializeChart() {
  const ctx = document.getElementById('analysisChart');
  if (!ctx) return;
  if (analysisChart) { analysisChart.destroy(); }
  
  analysisChart = new Chart(ctx, {
    type: 'scatter',
    data: {
      datasets: [{
        label: 'Data Points', data: [],
        backgroundColor: 'rgba(102, 126, 234, 0.6)',
        borderColor: 'rgba(102, 126, 234, 1)',
        borderWidth: 2, pointRadius: 4
      }]
    },
    options: {
      responsive: true, maintainAspectRatio: false,
      scales: {
        x: { title: { display: true, text: 'Distance (km)' } },
        y: { title: { display: true, text: 'Value' } }
      },
      plugins: {
        legend: { display: true },
        tooltip: {
          callbacks: {
            label: function(context) { return `(${context.parsed.x.toFixed(2)}, ${context.parsed.y.toFixed(2)})`; }
          }
        }
      }
    }
  });
}

function updateChart() {
  if (!analysisChart) {
    initializeChart();
    if (!analysisChart) return;
  }
  
  const chartType = document.getElementById('chartType').value;
  const dataFilter = document.getElementById('chartData').value;
  const dataPoints = [];
  const Pmin = parseFloat(document.getElementById('Pmin').value);
  
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const cell = cells[r][c];
      if ((r === transmitter.y && c === transmitter.x) || cell.obstacleType) continue;
      if (dataFilter === 'covered' && cell.isOutage) continue;
      if (dataFilter === 'outage' && !cell.isOutage) continue;
      
      const distanceKm = cell.distance / 1000;
      let yValue;
      
      switch (chartType) {
        case 'snr-distance': const noiseFloor = -100; yValue = cell.receivedPower - noiseFloor; break;
        case 'power-distance': yValue = cell.receivedPower; break;
        case 'pathloss-distance': yValue = cell.currentPathloss; break;
        case 'outage-distance': yValue = cell.isOutage ? 1 : 0; break;
        default: yValue = cell.receivedPower;
      }
      dataPoints.push({ x: distanceKm, y: yValue });
    }
  }
  
  analysisChart.data.datasets[0].data = dataPoints;
  
  const chartLabels = {
    'snr-distance': { title: 'SNR vs Distance', yLabel: 'SNR (dB)', color: 'rgba(46, 204, 113, 0.6)' },
    'power-distance': { title: 'Received Power vs Distance', yLabel: 'Received Power (dBm)', color: 'rgba(52, 152, 219, 0.6)' },
    'pathloss-distance': { title: 'Path Loss vs Distance', yLabel: 'Path Loss (dB)', color: 'rgba(231, 76, 60, 0.6)' },
    'outage-distance': { title: 'Outage vs Distance', yLabel: 'Outage (1=Yes, 0=No)', color: 'rgba(155, 89, 182, 0.6)' }
  };
  
  const currentLabel = chartLabels[chartType];
  analysisChart.data.datasets[0].label = currentLabel.title;
  analysisChart.data.datasets[0].backgroundColor = currentLabel.color;
  analysisChart.data.datasets[0].borderColor = currentLabel.color.replace('0.6', '1');
  analysisChart.options.scales.y.title.text = currentLabel.yLabel;
  
  const correlation = calculateCorrelation(dataPoints);
  const trend = dataPoints.length > 1 ? (dataPoints[dataPoints.length-1].y > dataPoints[0].y ? 'Increasing' : 'Decreasing') : 'N/A';
  
  document.getElementById('chartDataPoints').textContent = dataPoints.length;
  document.getElementById('chartCorrelation').textContent = isNaN(correlation) ? 'N/A' : correlation.toFixed(3);
  document.getElementById('chartTrend').textContent = trend;
  
  analysisChart.update();
}

function calculateCorrelation(points) {
  if (points.length < 2) return NaN;
  const n = points.length;
  const sumX = points.reduce((sum, p) => sum + p.x, 0);
  const sumY = points.reduce((sum, p) => sum + p.y, 0);
  const sumXY = points.reduce((sum, p) => sum + (p.x * p.y), 0);
  const sumX2 = points.reduce((sum, p) => sum + (p.x * p.x), 0);
  const sumY2 = points.reduce((sum, p) => sum + (p.y * p.y), 0);
  const numerator = (n * sumXY) - (sumX * sumY);
  const denominator = Math.sqrt(((n * sumX2) - (sumX * sumX)) * ((n * sumY2) - (sumY * sumY)));
  return denominator === 0 ? 0 : (numerator / denominator) ** 2; // R-squared
}

function loadChartJS() {
  if (typeof Chart !== 'undefined') { initializeChart(); return; }
  const script = document.createElement('script');
  script.src = 'https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js';
  script.onload = function() { initializeChart(); };
  document.head.appendChild(script);
}

document.addEventListener('DOMContentLoaded', initialize);

// --- END OF ORIGINAL JAVASCRIPT --- //
</script>
</body>
</html>