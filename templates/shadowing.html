<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shadowing Experiment</title>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            display: grid;
            grid-template-columns: 1fr 2fr 1fr;
            height: 100vh;
        }

        #inputs, #simulation, #outputs {
            border: 1px solid #ccc;
            padding: 10px;
            overflow: auto;
        }

        #simulation {
            display: grid;
            position: relative;
            margin: auto;
        }

        .cell {
            width: 20px;
            height: 20px;
            box-sizing: border-box;
            border: none; /* Remove visible grid lines */
        }

        .obstacle {
            background-color: black !important;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px;
            border-radius: 5px;
            font-size: 12px;
            pointer-events: none;
            white-space: nowrap;
            transform: translate(-50%, -120%);
        }
    </style>
</head>
<body>
    <div id="inputs">
        <h3>Inputs</h3>
        <label for="setting">Environment:</label>
        <select id="setting">
            <option value="urban">Urban</option>
            <option value="rural">Rural</option>
        </select>
        <p>Click on the grid to place obstacles.</p>
    </div>
    <div id="simulation"></div>
    <div id="outputs">
        <h3>Outputs</h3>
        <div id="output-info">Average Pathloss: N/A</div>
    </div>

    <script>
        // Basic layout setup
        const gridSize = 20; // Size of each grid cell in pixels
        const rows = 30; // Number of rows in the grid
        const cols = 30; // Number of columns in the grid
        const transmitter = { x: 15, y: 15 }; // Transmitter position (grid coordinates)

        const simulationArea = document.getElementById("simulation");
        simulationArea.style.gridTemplateRows = `repeat(${rows}, ${gridSize}px)`;
        simulationArea.style.gridTemplateColumns = `repeat(${cols}, ${gridSize}px)`;

        const tooltip = document.createElement("div");
        tooltip.className = "tooltip";
        tooltip.style.display = "none";
        document.body.appendChild(tooltip);

        const cells = []; // Store cells for easy manipulation

        // Generate grid with pathloss values
        for (let row = 0; row < rows; row++) {
            cells[row] = [];
            for (let col = 0; col < cols; col++) {
                const cell = document.createElement("div");
                cell.classList.add("cell");

                // Calculate distance from transmitter
                const distance = Math.sqrt((col - transmitter.x) ** 2 + (row - transmitter.y) ** 2);

                // Compute pathloss value (example formula)
                const pathloss = 20 * Math.log10(distance + 1); // Adding 1 to avoid log(0)

                // Set background color based on pathloss value (heatmap effect)
                const intensity = Math.min(255, Math.max(0, 255 - pathloss * 5));
                cell.style.backgroundColor = `rgb(${255 - intensity}, ${intensity}, ${intensity})`;

                simulationArea.appendChild(cell);
                cells[row][col] = { element: cell, pathloss, shadowCount: 0 }; // Store cell and its pathloss value
            }
        }

        // Place obstacles
        simulationArea.addEventListener("click", (e) => {
            const cell = e.target;
            if (cell && cell.classList.contains("cell")) {
                cell.classList.toggle("obstacle"); // Mark as obstacle
                updatePathloss();
            }
        });

        // Display pathloss near cursor on hover
        simulationArea.addEventListener("mousemove", (e) => {
            const cell = e.target;
            if (cell && cell.classList.contains("cell")) {
                const row = Math.floor(Array.from(simulationArea.children).indexOf(cell) / cols);
                const col = Array.from(simulationArea.children).indexOf(cell) % cols;
                const pathloss = cells[row][col].pathloss.toFixed(2);
                tooltip.textContent = `Pathloss: ${pathloss}`;
                tooltip.style.left = `${e.pageX}px`;
                tooltip.style.top = `${e.pageY}px`;
                tooltip.style.display = "block";
            }
        });

        simulationArea.addEventListener("mouseleave", () => {
            tooltip.style.display = "none";
        });

        // Update pathloss values when obstacles are placed
        function updatePathloss() {
            let totalPathloss = 0;
            let cellCount = 0;
            const shadowAngle = Math.PI / 6; // 30-degree shadow cone

            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const cell = cells[row][col];
                    cell.shadowCount = 0; // Reset shadow count

                    if (!cell.element.classList.contains("obstacle")) {
                        // Recalculate pathloss (add extra attenuation if blocked by obstacles)
                        cells.forEach((obstacleRow, r) => {
                            obstacleRow.forEach((obstacleCell, c) => {
                                if (obstacleCell.element.classList.contains("obstacle")) {
                                    const dxObstacle = c - transmitter.x;
                                    const dyObstacle = r - transmitter.y;
                                    const angleObstacle = Math.atan2(dyObstacle, dxObstacle);

                                    const dxCell = col - c;
                                    const dyCell = row - r;
                                    const angleCell = Math.atan2(dyCell, dxCell);

                                    const angularDifference = Math.abs(angleCell - angleObstacle);
                                    const weight = Math.max(0, 1 - angularDifference / shadowAngle);

                                    if (angularDifference <= shadowAngle) {
                                        cell.shadowCount += weight; // Increment shadow count based on weight
                                    }
                                }
                            });
                        });

                        const attenuation = cell.shadowCount * 2; // 2 units per shadow count
                        const adjustedPathloss = cell.pathloss + attenuation;
                        totalPathloss += adjustedPathloss;
                        cellCount++;

                        // Update cell color based on new pathloss
                        const intensity = Math.min(255, Math.max(0, 255 - adjustedPathloss * 5));
                        cell.element.style.backgroundColor = `rgb(${255 - intensity}, ${intensity}, ${intensity})`;
                    }
                }
            }

            // Update average pathloss in outputs
            const averagePathloss = (totalPathloss / cellCount).toFixed(2);
            document.getElementById("output-info").textContent = `Average Pathloss: ${averagePathloss}`;
        }
    </script>
</body>
</html>
