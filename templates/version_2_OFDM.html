<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OFDM Virtual Experiment</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 2.5rem 1rem;
            box-sizing: border-box;
        }

        .container {
            background-color: #ffffff;
            border-radius: 1.5rem;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.1);
            padding: 2rem;
            width: 100%;
            max-width: 1600px;
            min-height: 600px;
        }

        @media (max-width: 1400px) {
            .container {
                grid-template-columns: 260px 1fr 320px;
                gap: 1rem;
            }
        }

        @media (max-width: 1200px) {
            .container {
                grid-template-columns: 1fr;
                gap: 2rem;
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 1.5rem;
            }
        }

        .block-diagram-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 1.5rem;
            overflow: visible;
            padding: 10px;
            width: 100%;
        }

        h2 {
            font-size: 1.5rem;
            font-weight: 700;
            color: #1e293b;
            text-align: center;
            margin-bottom: 1.5rem;
        }

        @media (max-width: 768px) {
            h2 {
                font-size: 1.25rem;
            }
        }

        .input-section {
            border-right: 2px solid #e2e8f0;
            padding-right: 1.5rem;
            min-width: 280px;
        }

        @media (max-width: 1200px) {
            .input-section {
                border-right: none;
                border-bottom: 2px solid #e2e8f0;
                padding-right: 0;
                padding-bottom: 2rem;
            }
        }

        .input-group {
            display: flex;
            flex-direction: column;
            margin-bottom: 1rem;
        }

        .input-group label {
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: #475569;
        }

        .input-group input, .input-group select {
            padding: 0.75rem 1rem;
            border: 1px solid #cbd5e1;
            border-radius: 0.5rem;
            font-size: 1rem;
            color: #334155;
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }

        .input-group input:focus, .input-group select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }

        .button-primary {
            background-color: #3b82f6;
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            border: none;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            width: 100%;
        }

        .button-primary:hover {
            background-color: #2563eb;
            transform: translateY(-1px);
        }

        .button-primary:active {
            background-color: #1d4ed8;
            transform: translateY(0);
        }

        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3b82f6;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            display: none;
            margin: 1rem auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-message {
            color: #ef4444;
            background-color: #fee2e2;
            border: 1px solid #fca5a5;
            padding: 0.75rem;
            border-radius: 0.5rem;
            margin-top: 1rem;
            display: none;
        }

        .simulation-area {
            grid-column: 2;
            min-width: 0;
        }

        @media (max-width: 1200px) {
            .simulation-area {
                grid-column: 1;
            }
        }

        .ofdm-block {
            fill: #e0e7ff;
            stroke: #3b82f6;
            stroke-width: 2;
            transition: fill 0.3s ease, stroke 0.3s ease, transform 0.3s ease;
        }

        .ofdm-block-text {
            font-family: 'Inter', sans-serif;
            font-size: 12px;
            font-weight: 600;
            fill: #1e293b;
            text-anchor: middle;
            dominant-baseline: central;
            pointer-events: none;
        }

        .ofdm-block.highlighted {
            fill: #93c5fd;
            stroke: #1d4ed8;
            stroke-width: 3;
            transform: scale(1.05);
        }

        .ofdm-block-text.highlighted {
            font-weight: 700;
        }

        .arrow {
            stroke: #64748b;
            stroke-width: 2;
            fill: none;
            marker-end: url(#arrowhead);
            transition: stroke 0.3s ease;
        }

        .arrowhead {
            fill: #64748b;
        }

        .arrow.highlighted {
            stroke: #1d4ed8;
        }

        .chart-container {
            margin-top: 1.5rem;
            width: 100%;
            overflow: hidden;
        }

        .chart-container canvas {
            max-width: 100% !important;
            max-height: 350px !important;
            height: 350px !important;
            width: 100% !important;
        }

        .chart-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: #374151;
            text-align: center;
            margin-bottom: 1rem;
        }

        @media (max-width: 768px) {
            .chart-title {
                font-size: 1.125rem;
            }
        }

        .nav-buttons {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1.5rem;
            flex-wrap: wrap;
        }

        .nav-buttons button {
            min-width: 120px;
            flex: 0 1 auto;
        }

        .output-area {
            grid-column: 3;
            border-left: 2px solid #e2e8f0;
            padding-left: 1.5rem;
            min-width: 350px;
        }

        @media (max-width: 1200px) {
            .output-area {
                grid-column: 1;
                border-left: none;
                border-top: 2px solid #e2e8f0;
                padding-left: 0;
                padding-top: 2rem;
            }
        }

        .simulation-info {
            background-color: #f1f5f9;
            border-radius: 0.75rem;
            padding: 1.5rem;
            margin-top: 1.5rem;
            border: 1px solid #e2e8f0;
        }

        .simulation-info h3 {
            font-size: 1.125rem;
            font-weight: 600;
            color: #1e293b;
            margin-bottom: 0.75rem;
        }

        .simulation-info p {
            font-family: 'monospace', sans-serif;
            font-size: 0.875rem;
            color: #334155;
            line-height: 1.5;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 200px;
            overflow-y: auto;
        }

        #ofdmBlockDiagram {
            max-width: 100%;
            height: auto;
            width: 500px;
            max-height: 280px;
        }

        /* Add to existing styles */
        .symbol-display {
            display: flex;
            flex-wrap: wrap;
            gap: 2px;
            justify-content: center;
            align-items: center;
            margin-top: 12px;
            padding: 12px;
            background: #f8fafc;
            border-radius: 8px;
            border: 1px solid var(--border-gray);
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Monaco', 'Menlo', monospace;
        }

        .symbol-item {
            min-width: 45px;
            height: 28px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: 600;
            border: 1.5px solid;
            white-space: nowrap;
            text-overflow: ellipsis;
            overflow: hidden;
            position: relative;
        }

        .symbol-item.data {
            background: #dbeafe;
            border-color: var(--primary-blue);
            color: var(--text-primary);
        }

        .symbol-item.cp {
            background: #fed7d7;
            border-color: var(--error-red);
            color: var(--error-red);
            font-weight: 700;
        }

        .symbol-item.ellipsis {
            background: #f1f5f9;
            border-color: var(--secondary-gray);
            color: var(--text-secondary);
            border-style: dashed;
            min-width: 30px;
        }

        .symbol-separator {
            font-size: 14px;
            color: var(--text-secondary);
            margin: 0 4px;
            font-weight: bold;
        }

        /* === Add this entire block to your main.css file === */
        .symbol-display {
            display: flex;
            flex-wrap: wrap;
            gap: 3px;
            justify-content: center;
            align-items: center;
            margin-top: 12px;
            padding: 12px;
            background-color: #f1f5f9; /* Light gray background */
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            max-height: 180px;
            overflow-y: auto;
            font-family: 'Menlo', 'Monaco', monospace;
        }

        .symbol-item {
            min-width: 50px;
            height: 30px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: 600;
            border: 1.5px solid;
            white-space: nowrap;
            text-overflow: ellipsis;
            overflow: hidden;
            position: relative;
            padding: 0 5px;
        }

        .symbol-item.data {
            background: #dbeafe;   /* Light blue */
            border-color: #60a5fa;  /* Blue border */
            color: #1e3a8a;       /* Dark blue text */
        }

        .symbol-item.cp {
            background: #fee2e2;   /* Light red */
            border-color: #fca5a5;  /* Red border */
            color: #991b1b;       /* Dark red text */
            font-weight: 700;
        }

        .symbol-item.ellipsis {
            background: #f1f5f9;
            border-color: #94a3b8; /* Gray border */
            color: #475569;      /* Gray text */
            border-style: dashed;
            min-width: 30px;
        }

        .symbol-separator {
            font-size: 16px;
            color: #64748b;
            margin: 0 4px;
            font-weight: bold;
        }

        @media (max-width: 768px) {
            #ofdmBlockDiagram {
                width: 100%;
                max-width: 450px;
            }
        }

        .tab-nav {
            display: flex;
            justify-content: center;
            margin-bottom: 2rem;
            border-bottom: 2px solid #e2e8f0;
        }

        .tab-link {
            padding: 0.75rem 1.5rem;
            background: none;
            border: none;
            font-size: 1rem;
            font-weight: 600;
            color: #64748b;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.3s ease;
        }

        .tab-link:hover {
            color: #3b82f6;
        }

        .tab-link.active {
            color: #3b82f6;
            border-bottom-color: #3b82f6;
        }

        .tab-content {
            display: none;
        }

        .main-content-grid {
            display: grid;
            grid-template-columns: 280px 1fr 350px;
            gap: 1.5rem;
            min-height: 600px;
        }

        @media (max-width: 1400px) {
            .main-content-grid {
                grid-template-columns: 260px 1fr 320px;
                gap: 1rem;
            }
        }

        @media (max-width: 1200px) {
            .main-content-grid {
                grid-template-columns: 1fr;
                gap: 2rem;
            }
            
            .input-section {
                border-right: none;
                border-bottom: 2px solid #e2e8f0;
                padding-right: 0;
                padding-bottom: 2rem;
            }
            
            .output-area {
                border-left: none;
                border-top: 2px solid #e2e8f0;
                padding-left: 0;
                padding-top: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="w-full col-span-full">
            <h2 class="text-3xl font-bold text-center text-gray-800 mb-6">OFDM Virtual Experiment</h2>
            
            <div class="tab-nav">
                <button class="tab-link active" onclick="openTab(event, 'simulationTab')">Signal Flow Simulation</button>
                <button class="tab-link" onclick="openTab(event, 'berAnalysisTab')">BER Performance Analysis</button>
            </div>
        </div>

        <!-- Signal Flow Simulation Tab -->
        <div id="simulationTab" class="tab-content" style="display: block;">
            <div class="main-content-grid">
                <div class="input-section">
                    <h3 class="text-xl font-bold text-gray-800 mb-4">Step-by-Step Controls</h3>
                    <!-- Your existing input controls here -->
                    <div class="input-group">
                        <label for="nFFTSize">FFT Size (N):</label>
                        <input type="number" id="nFFTSize" value="64" min="16" step="16">
                    </div>
                    <div class="input-group">
                        <label for="numSubcarriers">Number of Data Subcarriers:</label>
                        <input type="number" id="numSubcarriers" value="52" min="12" step="4">
                    </div>
                    <div class="input-group">
                        <label for="modulationScheme">Modulation Scheme:</label>
                        <select id="modulationScheme">
                            <option value="BPSK">BPSK</option>
                            <option value="QPSK">QPSK</option>
                            <option value="16QAM">16-QAM</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label for="cpLength">Cyclic Prefix Length:</label>
                        <input type="number" id="cpLength" value="16" min="4" step="4">
                    </div>
                    <div class="input-group">
                        <label for="snrDb">SNR (dB) for Plots:</label>
                        <input type="number" id="snrDb" value="20" min="-10" max="50" step="1">
                    </div>
                    <div class="input-group">
                        <label for="equalization">Equalization Method:</label>
                        <select id="equalization">
                            <option value="ZF">Zero-Forcing (ZF)</option>
                            <option value="MMSE">MMSE</option>
                        </select>
                    </div>
                    <button id="runStepByStepBtn" class="button-primary">Run Simulation</button>
                    <div id="loadingSpinner" class="loading-spinner"></div>
                    <div id="errorMessage" class="error-message"></div>
                </div>

                <div class="simulation-area">
                    <h3 class="text-xl font-bold text-center text-gray-800 mb-4">OFDM Signal Flow</h3>
                    <div class="block-diagram-container">
                        <svg id="ofdmBlockDiagram" viewBox="0 0 490 240">
                            <defs>
                                <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
                                    <polygon points="0 0, 10 3.5, 0 7" class="arrowhead" />
                                </marker>
                            </defs>
                            
                            <!-- Transmitter blocks -->
                            <rect id="block-tx" class="ofdm-block" x="10" y="10" width="90" height="45" rx="6"></rect>
                            <text class="ofdm-block-text" x="55" y="27">S/P</text>
                            <text class="ofdm-block-text" x="55" y="42">+ Mapping</text>
                            
                            <line id="mapping-to-idft" class="arrow" x1="100" y1="32.5" x2="120" y2="32.5" />
                            
                            <rect id="block-idft" class="ofdm-block" x="120" y="10" width="90" height="45" rx="6"></rect>
                            <text class="ofdm-block-text" x="165" y="32.5">IDFT</text>
                            
                            <line id="idft-to-addcp" class="arrow" x1="210" y1="32.5" x2="230" y2="32.5" />
                            
                            <rect id="block-addcp" class="ofdm-block" x="230" y="10" width="90" height="45" rx="6"></rect>
                            <text class="ofdm-block-text" x="275" y="32.5">Add CP</text>
                            
                            <!-- Channel block -->
                            <rect id="block-channel" class="ofdm-block" x="390" y="95" width="90" height="45" rx="6"></rect>
                            <text class="ofdm-block-text" x="435" y="117.5">Channel</text>
                            
                            <!-- Receiver blocks -->
                            <rect id="block-rx" class="ofdm-block" x="10" y="180" width="90" height="45" rx="6"></rect>
                            <text class="ofdm-block-text" x="55" y="197">Demapping</text>
                            <text class="ofdm-block-text" x="55" y="212">+ P/S</text>
                            
                            <line id="equalizer-to-demapping" class="arrow" x1="120" y1="202.5" x2="100" y2="202.5" />
                            
                            <rect id="block-equalizer" class="ofdm-block" x="120" y="180" width="90" height="45" rx="6"></rect>
                            <text class="ofdm-block-text" x="165" y="202.5">Equalizer</text>
                            
                            <line id="fft-to-equalizer" class="arrow" x1="230" y1="202.5" x2="210" y2="202.5" />
                            
                            <rect id="block-fft" class="ofdm-block" x="230" y="180" width="90" height="45" rx="6"></rect>
                            <text class="ofdm-block-text" x="275" y="202.5">FFT</text>
                            
                            <line id="removecp-to-fft" class="arrow" x1="390" y1="202.5" x2="320" y2="202.5" />
                            
                            <rect id="block-removecp" class="ofdm-block" x="390" y="180" width="90" height="45" rx="6"></rect>
                            <text class="ofdm-block-text" x="435" y="202.5">Remove CP</text>
                            
                            <!-- Arrows connecting transmitter to receiver through channel -->
                            <line id="addcp-to-channel" class="arrow" x1="275" y1="55" x2="435" y2="95" />
                            <line id="channel-to-removecp" class="arrow" x1="435" y1="140" x2="435" y2="180" />
                        </svg>
                        </svg>
                    </div>
                    <div class="nav-buttons">
                        <button id="nextBlockBtn" class="button-primary" disabled>Next</button>
                        <button id="prevBlockBtn" class="button-primary" disabled>Previous</button>
                    </div>
                    
                    <div class="simulation-info">
                        <h3 id="blockOutputTitle">Simulation Step Output</h3>
                        <div id="symbolDisplay" class="symbol-display" style="display: none;"></div>
                        <p id="blockOutputDisplay">Run a simulation to see the step-by-step output here.</p>
                    </div>
                </div>

                <div class="output-area">
                    <!-- Chart containers for simulation tab -->
                    <div class="chart-container">
                        <h3 class="chart-title" id="constellationChartTitle">Transmitted Constellation</h3>
                        <canvas id="constellationChart"></canvas>
                    </div>
                    <div class="chart-container" style="display: none;">
                        <h3 class="chart-title" id="preChannelSpectrumChartTitle">Pre-Channel Spectrum</h3>
                        <canvas id="preChannelSpectrumChart"></canvas>
                    </div>
                    <div class="chart-container" style="display: none;">
                        <h3 class="chart-title" id="postChannelSpectrumChartTitle">Post-Channel Spectrum</h3>
                        <canvas id="postChannelSpectrumChart"></canvas>
                    </div>
                    <div class="chart-container" style="display: none;">
                        <h3 class="chart-title" id="receivedConstellationChartTitle">Received Constellation</h3>
                        <canvas id="receivedConstellationChart"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <!-- BER Analysis Tab -->
        <div id="berAnalysisTab" class="tab-content" style="display: none;">
            <div class="main-content-grid">
                <div class="input-section">
                    <h3 class="text-xl font-bold text-gray-800 mb-4">BER Simulation Controls</h3>
                    <div class="input-group">
                        <label for="ber_nFFTSize">FFT Size (N):</label>
                        <input type="number" id="ber_nFFTSize" value="64" min="16" step="16">
                    </div>
                    <div class="input-group">
                        <label for="ber_numSubcarriers">Data Subcarriers:</label>
                        <input type="number" id="ber_numSubcarriers" value="52" min="12" step="4">
                    </div>
                    <div class="input-group">
                        <label for="ber_modulationScheme">Modulation Scheme:</label>
                        <select id="ber_modulationScheme">
                            <option value="BPSK">BPSK</option>
                            <option value="QPSK">QPSK</option>
                            <option value="16QAM">16-QAM</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label for="ber_cpLength">Cyclic Prefix Length:</label>
                        <input type="number" id="ber_cpLength" value="16" min="4" step="4">
                    </div>
                    <div class="input-group">
                        <label for="ber_channelTaps">Channel Taps (Fading):</label>
                        <input type="number" id="ber_channelTaps" value="1" min="1" max="10">
                    </div>
                    <div class="input-group">
                        <label for="ber_equalization">Equalization Method:</label>
                        <select id="ber_equalization">
                            <option value="ZF">Zero-Forcing (ZF)</option>
                            <option value="MMSE">MMSE</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label for="numSymbolsBer">Number of OFDM Symbols:</label>
                        <input type="number" id="numSymbolsBer" value="500" min="100" max="5000" step="100">
                    </div>
                    <button id="runBerSimBtn" class="button-primary">Run BER Simulation</button>
                    <div id="loadingSpinnerBER" class="loading-spinner"></div>
                    <div id="errorMessageBER" class="error-message"></div>
                </div>
                
                <div class="w-full" style="grid-column: 2 / -1;">
                    <div class="chart-container">
                        <h3 class="chart-title" id="berCurveChartTitle">BER vs. SNR Performance</h3>
                        <canvas id="berCurveChart"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Complex Number Class and DSP Helper Functions ---
        class Complex {
            constructor(re, im = 0) {
                this.re = re;
                this.im = im;
            }
            add(other) {
                return new Complex(this.re + other.re, this.im + other.im);
            }
            sub(other) {
                return new Complex(this.re - other.re, this.im - other.im);
            }
            mul(other) {
                return new Complex(
                    this.re * other.re - this.im * other.im,
                    this.re * other.im + this.im * other.re
                );
            }
            div(other) {
                if (other.re === 0 && other.im === 0) return new Complex(Infinity, Infinity);
                const den = other.re * other.re + other.im * other.im;
                return new Complex(
                    (this.re * other.re + this.im * other.im) / den,
                    (this.im * other.re - this.re * other.im) / den
                );
            }
            magSq() {
                return this.re * this.re + this.im * this.im;
            }
            mag() {
                return Math.sqrt(this.magSq());
            }
            conj() {
                return new Complex(this.re, -this.im);
            }
            toString() {
                if (this.im === 0) return this.re.toFixed(3);
                if (this.re === 0) return `${this.im.toFixed(3)}i`;
                const sign = this.im > 0 ? '+' : '';
                return `${this.re.toFixed(3)}${sign}${this.im.toFixed(3)}i`;
            }
        }
        function fft(x) {
            const N = x.length;
            if (N <= 1) return x;
            const even = [];
            const odd = [];
            for (let i = 0; i < N / 2; i++) {
                even[i] = x[i * 2];
                odd[i] = x[i * 2 + 1];
            }
            const Y_even = fft(even);
            const Y_odd = fft(odd);
            const Y = new Array(N);
            for (let k = 0; k < N / 2; k++) {
                const t = new Complex(Math.cos(-2 * Math.PI * k / N), Math.sin(-2 * Math.PI * k / N)).mul(Y_odd[k]);
                Y[k] = Y_even[k].add(t);
                Y[k + N / 2] = Y_even[k].sub(t);
            }
            return Y;
        }
        function ifft(X) {
            const N = X.length;
            if (N <= 1) return X;
            const X_conj = X.map(c => new Complex(c.re, -c.im));
            const y_conj = fft(X_conj);
            return y_conj.map(c => new Complex(c.re / N, -c.im / N));
        }
        function fftshift(arr) {
            const mid = Math.floor(arr.length / 2);
            return [...arr.slice(mid), ...arr.slice(0, mid)];
        }
        function dbToLinear(db) {
            return Math.pow(10, db / 10);
        }
        function linearToDb(linear) {
            if (linear <= 0 || !isFinite(linear)) return -100;
            const dbValue = 10 * Math.log10(linear);
            return isFinite(dbValue) ? dbValue : -100;
        }
        function randn() {
            let u = 0, v = 0;
            while (u === 0) u = Math.random();
            while (v === 0) v = Math.random();
            return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
        }
        function bpskModulate(bit) { return new Complex(2 * bit - 1); }
        function qpskModulate(bits) {
            const real = (2 * bits[0] - 1) / Math.sqrt(2);
            const imag = (2 * bits[1] - 1) / Math.sqrt(2);
            return new Complex(real, imag);
        }
        function qam16Modulate(bits) {
            const map = {
                "0000": new Complex(-3 / Math.sqrt(10), -3 / Math.sqrt(10)), "0001": new Complex(-3 / Math.sqrt(10), -1 / Math.sqrt(10)),
                "0010": new Complex(-3 / Math.sqrt(10), 3 / Math.sqrt(10)), "0011": new Complex(-3 / Math.sqrt(10), 1 / Math.sqrt(10)),
                "0100": new Complex(-1 / Math.sqrt(10), -3 / Math.sqrt(10)), "0101": new Complex(-1 / Math.sqrt(10), -1 / Math.sqrt(10)),
                "0110": new Complex(-1 / Math.sqrt(10), 3 / Math.sqrt(10)), "0111": new Complex(-1 / Math.sqrt(10), 1 / Math.sqrt(10)),
                "1000": new Complex(3 / Math.sqrt(10), -3 / Math.sqrt(10)), "1001": new Complex(3 / Math.sqrt(10), -1 / Math.sqrt(10)),
                "1010": new Complex(3 / Math.sqrt(10), 3 / Math.sqrt(10)), "1011": new Complex(3 / Math.sqrt(10), 1 / Math.sqrt(10)),
                "1100": new Complex(1 / Math.sqrt(10), -3 / Math.sqrt(10)), "1101": new Complex(1 / Math.sqrt(10), -1 / Math.sqrt(10)),
                "1110": new Complex(1 / Math.sqrt(10), 3 / Math.sqrt(10)), "1111": new Complex(1 / Math.sqrt(10), 1 / Math.sqrt(10)),
            };
            return map[bits.join('')];
        }
        function bpskDemodulate(symbol) { return symbol.re > 0 ? 1 : 0; }
        function qpskDemodulate(symbol) {
            return [symbol.re > 0 ? 1 : 0, symbol.im > 0 ? 1 : 0];
        }
        function qam16Demodulate(symbol) {
            const constellationPoints = {
                "0000": new Complex(-3 / Math.sqrt(10), -3 / Math.sqrt(10)), "0001": new Complex(-3 / Math.sqrt(10), -1 / Math.sqrt(10)),
                "0010": new Complex(-3 / Math.sqrt(10), 3 / Math.sqrt(10)), "0011": new Complex(-3 / Math.sqrt(10), 1 / Math.sqrt(10)),
                "0100": new Complex(-1 / Math.sqrt(10), -3 / Math.sqrt(10)), "0101": new Complex(-1 / Math.sqrt(10), -1 / Math.sqrt(10)),
                "0110": new Complex(-1 / Math.sqrt(10), 3 / Math.sqrt(10)), "0111": new Complex(-1 / Math.sqrt(10), 1 / Math.sqrt(10)),
                "1000": new Complex(3 / Math.sqrt(10), -3 / Math.sqrt(10)), "1001": new Complex(3 / Math.sqrt(10), -1 / Math.sqrt(10)),
                "1010": new Complex(3 / Math.sqrt(10), 3 / Math.sqrt(10)), "1011": new Complex(3 / Math.sqrt(10), 1 / Math.sqrt(10)),
                "1100": new Complex(1 / Math.sqrt(10), -3 / Math.sqrt(10)), "1101": new Complex(1 / Math.sqrt(10), -1 / Math.sqrt(10)),
                "1110": new Complex(1 / Math.sqrt(10), 3 / Math.sqrt(10)), "1111": new Complex(1 / Math.sqrt(10), 1 / Math.sqrt(10)),
            };
            let minDistanceSq = Infinity;
            let demodulatedBits = '';
            for (const bitString in constellationPoints) {
                const idealPoint = constellationPoints[bitString];
                const distanceSq = (symbol.re - idealPoint.re) ** 2 + (symbol.im - idealPoint.im) ** 2;
                if (distanceSq < minDistanceSq) {
                    minDistanceSq = distanceSq;
                    demodulatedBits = bitString;
                }
            }
            return demodulatedBits.split('').map(Number);
        }
        function generateBits(numBits) { return Array.from({ length: numBits }, () => Math.random() > 0.5 ? 1 : 0); }

        function openTab(evt, tabName) {
            // Hide all tab contents
            const tabContents = document.getElementsByClassName("tab-content");
            for (let i = 0; i < tabContents.length; i++) {
                tabContents[i].style.display = "none";
            }

            // Remove active class from all tab links
            const tabLinks = document.getElementsByClassName("tab-link");
            for (let i = 0; i < tabLinks.length; i++) {
                tabLinks[i].classList.remove("active");
            }

            // Show the selected tab and mark button as active
            document.getElementById(tabName).style.display = "block";
            evt.currentTarget.classList.add("active");

            // Reset charts and UI state when switching tabs
            hideStepByStepCharts();
            hideOutputCharts();
            
            if (tabName === 'simulationTab') {
                // Reset to first block for step-by-step
                currentBlockIndex = 0;
                highlightBlock(currentBlockIndex);
            }
        }

        function modulate(bits, modulationScheme, bitsPerSymbol) {
            const modulatedSymbols = [];
            let modulateFunc;
            switch (modulationScheme) {
                case 'BPSK': modulateFunc = bpskModulate; break;
                case 'QPSK': modulateFunc = qpskModulate; break;
                case '16QAM': modulateFunc = qam16Modulate; break;
                default: throw new Error('Invalid modulation scheme.');
            }
            for (let i = 0; i < bits.length; i += bitsPerSymbol) {
                const currentBits = bits.slice(i, i + bitsPerSymbol);
                if (bitsPerSymbol === 1) {
                    modulatedSymbols.push(modulateFunc(currentBits[0]));
                } else {
                    modulatedSymbols.push(modulateFunc(currentBits));
                }
            }
            return modulatedSymbols;
        }
        function mapToSubcarriers(symbols, nFFTSize, numSubcarriers) {
            const inputiFFT = Array.from({ length: nFFTSize }, () => new Complex(0));
            let symbolIdx = 0;
            if (nFFTSize === 64 && numSubcarriers === 52) {
                const subcarrierIndices80211a = [-26, -25, -24, -23, -22, -21, -20, -19, -18, -17, -16, -15, -14, -13, -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1,
                                                 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26];
                for (const scIdx of subcarrierIndices80211a) {
                    let arrayIdx = scIdx > 0 ? scIdx : nFFTSize + scIdx;
                    if (symbolIdx < symbols.length) {
                        inputiFFT[arrayIdx] = symbols[symbolIdx++];
                    }
                }
            } else {
                const halfSubcarriers = Math.floor(numSubcarriers / 2);
                for (let i = 1; i <= halfSubcarriers && symbolIdx < symbols.length; i++) { inputiFFT[i] = symbols[symbolIdx++]; }
                for (let i = nFFTSize - halfSubcarriers; i < nFFTSize && symbolIdx < symbols.length; i++) { inputiFFT[i] = symbols[symbolIdx++]; }
            }
            return inputiFFT;
        }
        function addCyclicPrefix(signal, cpLength) {
            const cyclicPrefix = signal.slice(signal.length - cpLength);
            return [...cyclicPrefix, ...signal];
        }
        function applyRayleighFading(signal) {
            const fadedSignal = [];
            const channelGains = [];
            for (let i = 0; i < signal.length; i++) {
                const h_real = randn() / Math.sqrt(2);
                const h_imag = randn() / Math.sqrt(2);
                const h = new Complex(h_real, h_imag);
                channelGains.push(h);
                fadedSignal.push(signal[i].mul(h));
            }
            return { fadedSignal, channelGains };
        }
        function addAwgn(signal, snrDb) {
            const signalPower = signal.reduce((sum, val) => sum + val.magSq(), 0) / signal.length;
            const snrLinear = dbToLinear(snrDb);
            const noisePower = signalPower / snrLinear;
            const noiseStdDev = Math.sqrt(noisePower / 2);
            return signal.map(sample => {
                const noiseReal = randn() * noiseStdDev;
                const noiseImag = randn() * noiseStdDev;
                return sample.add(new Complex(noiseReal, noiseImag));
            });
        }
        function removeCyclicPrefix(signalWithCP, cpLength, nFFTSize) {
            return signalWithCP.slice(cpLength, cpLength + nFFTSize);
        }
        // Replace your existing equalize function with this one
        function equalize(receivedSymbolsFFT, channelGainsFFT, method, snrDb) {
            const snrLinear = dbToLinear(snrDb);
            return receivedSymbolsFFT.map((sym, i) => {
                const channelGain = channelGainsFFT[i];
                if (channelGain.magSq() < 1e-10) {
                    return new Complex(0, 0); // Avoid division by zero
                }

                let equalizedSymbol;
                switch (method) {
                    case 'MMSE':
                        const channelMagSq = channelGain.magSq();
                        const mmseWeight = channelGain.conj().div(new Complex(channelMagSq + 1 / snrLinear));
                        equalizedSymbol = sym.mul(mmseWeight);
                        break;
                    
                    case 'ZF':
                    default:
                        equalizedSymbol = sym.div(channelGain);
                        break;
                }

                // Safety check for huge numbers after equalization
                if (!isFinite(equalizedSymbol.re) || !isFinite(equalizedSymbol.im) || Math.abs(equalizedSymbol.re) > 100 || Math.abs(equalizedSymbol.im) > 100) {
                    return new Complex(0, 0);
                }
                return equalizedSymbol;
            });
        }
        function demodulate(symbols, modulationScheme) {
            const demodulatedBits = [];
            let demodulateFunc;
            switch (modulationScheme) {
                case 'BPSK': demodulateFunc = bpskDemodulate; break;
                case 'QPSK': demodulateFunc = qpskDemodulate; break;
                case '16QAM': demodulateFunc = qam16Demodulate; break;
                default: throw new Error('Invalid modulation scheme.');
            }
            for (const symbol of symbols) {
                const bits = demodulateFunc(symbol);
                if (Array.isArray(bits)) {
                    demodulatedBits.push(...bits);
                } else {
                    demodulatedBits.push(bits);
                }
            }
            return demodulatedBits;
        }
        function calculateBer(originalBits, receivedBits) {
            let errors = 0;
            const minLength = Math.min(originalBits.length, receivedBits.length);
            for (let i = 0; i < minLength; i++) {
                if (originalBits[i] !== receivedBits[i]) {
                    errors++;
                }
            }
            return errors / originalBits.length;
        }

        // --- Utility Functions ---
        function formatComplexArrayForDisplay(arr, count = 5) {
            if (!arr || arr.length === 0) return "N/A";
            const sample = arr.slice(0, count).map(c => c.toString()).join(', ');
            return `[${sample}${arr.length > count ? ', ...' : ''}]`;
        }
        function formatBitArrayForDisplay(arr, count = 20) {
            if (!arr || arr.length === 0) return "N/A";
            const sample = arr.slice(0, count).join('');
            return `${sample}${arr.length > count ? '...' : ''}`;
        }
        
        // --- Global Variables & Simulation Logic ---
        let globalTransmittedBits = [];
        let globalModulatedSymbols = [];
        let globalTxWaveformPreChannel = [];
        let globalRxWaveformPostChannel = [];
        let globalRxNoCP = [];
        let globalRxFFTOutput = [];
        let globalReceivedSymbols = [];
        let globalChannelGainsFFT = [];

        const fsMHz = 20;
        const fftLengthForSpectrum = 4096;
        const frequencies = Array.from({ length: fftLengthForSpectrum }, (_, i) =>
            (i - fftLengthForSpectrum / 2) * fsMHz / fftLengthForSpectrum
        );

        async function runStepByStepSimulation() {
            const nFFTSize = parseInt(document.getElementById('nFFTSize').value);
            const numSubcarriers = parseInt(document.getElementById('numSubcarriers').value);
            const modulationScheme = document.getElementById('modulationScheme').value;
            const cpLength = parseInt(document.getElementById('cpLength').value);
            const snrDb = parseFloat(document.getElementById('snrDb').value);
            const equalizationMethod = document.getElementById('equalization').value; // <-- Add this line


            document.getElementById('loadingSpinner').style.display = 'block';
            document.getElementById('errorMessage').style.display = 'none';
            document.getElementById('errorMessage').textContent = '';

            const bitsPerSymbol = (modulationScheme === 'BPSK') ? 1 : (modulationScheme === 'QPSK' ? 2 : 4);
            const numBitsPerOFDMSymbol = numSubcarriers * bitsPerSymbol;

            try {
                globalTransmittedBits = generateBits(numBitsPerOFDMSymbol);
                globalModulatedSymbols = modulate(globalTransmittedBits, modulationScheme, bitsPerSymbol);
                let ifftInput = mapToSubcarriers(globalModulatedSymbols, nFFTSize, numSubcarriers);
                let ifftOutput = ifft(ifftInput);
                globalTxWaveformPreChannel = addCyclicPrefix(ifftOutput, cpLength);

                const { fadedSignal, channelGains } = applyRayleighFading(globalTxWaveformPreChannel);
                globalRxWaveformPostChannel = addAwgn(fadedSignal, snrDb);

                globalRxNoCP = removeCyclicPrefix(globalRxWaveformPostChannel, cpLength, nFFTSize);
                globalRxFFTOutput = fft(globalRxNoCP);
                
                const channelGainsNoCP = channelGains.slice(cpLength, cpLength + nFFTSize);
                globalChannelGainsFFT = fft(channelGainsNoCP);
                globalReceivedSymbols = equalize(globalRxFFTOutput, globalChannelGainsFFT, equalizationMethod, snrDb);

                updateTransmittedConstellationChart(globalModulatedSymbols, modulationScheme);
                updateReceivedConstellationChart(globalReceivedSymbols, modulationScheme);

                const preChannelPadded = [...globalTxWaveformPreChannel];
                if (preChannelPadded.length < fftLengthForSpectrum) {
                    preChannelPadded.push(...Array(fftLengthForSpectrum - preChannelPadded.length).fill(new Complex(0)));
                } else if (preChannelPadded.length > fftLengthForSpectrum) {
                    preChannelPadded.length = fftLengthForSpectrum;
                }
                const preChannelSpectrumFFT = fft(preChannelPadded);
                const preChannelPsd = preChannelSpectrumFFT.map(c => Math.max(c.magSq(), 1e-12));
                const preChannelPsd_db = fftshift(preChannelPsd).map(val => {
                    const dbVal = linearToDb(val);
                    return isFinite(dbVal) ? Math.max(dbVal, -100) : -100;
                });
                updateSpectrumChart(preChannelSpectrumChart, frequencies, preChannelPsd_db);

                const postChannelPadded = [...globalRxWaveformPostChannel];
                if (postChannelPadded.length < fftLengthForSpectrum) {
                    postChannelPadded.push(...Array(fftLengthForSpectrum - postChannelPadded.length).fill(new Complex(0)));
                } else if (postChannelPadded.length > fftLengthForSpectrum) {
                    postChannelPadded.length = fftLengthForSpectrum;
                }
                const postChannelSpectrumFFT = fft(postChannelPadded);
                const postChannelPsd = postChannelSpectrumFFT.map(c => Math.max(c.magSq(), 1e-12));
                const postChannelPsd_db = fftshift(postChannelPsd).map(val => {
                    const dbVal = linearToDb(val);
                    return isFinite(dbVal) ? Math.max(dbVal, -100) : -100;
                });
                updateSpectrumChart(postChannelSpectrumChart, frequencies, postChannelPsd_db);

                currentBlockIndex = 0;
                highlightBlock(currentBlockIndex);
                document.getElementById('nextBlockBtn').disabled = false;
                document.getElementById('prevBlockBtn').disabled = true;

            } catch (error) {
                console.error("Step-by-step simulation error:", error);
                displayError(`Step-by-step simulation failed: ${error.message}. Please check inputs.`);
            } finally {
                document.getElementById('loadingSpinner').style.display = 'none';
            }
        }

        async function runBerSimulation() {
            document.getElementById('loadingSpinnerBER').style.display = 'block';
            document.getElementById('errorMessageBER').style.display = 'none';

            const nFFTSize = parseInt(document.getElementById('ber_nFFTSize').value);
            const numSubcarriers = parseInt(document.getElementById('ber_numSubcarriers').value);
            const modulationScheme = document.getElementById('ber_modulationScheme').value;
            const cpLength = parseInt(document.getElementById('ber_cpLength').value);
            const numSymbolsBer = parseInt(document.getElementById('numSymbolsBer').value);
            const equalizationMethod = document.getElementById('ber_equalization').value;

            let bitsPerSymbol;
            switch (modulationScheme) {
                case 'BPSK': bitsPerSymbol = 1; break;
                case 'QPSK': bitsPerSymbol = 2; break;
                case '16QAM': bitsPerSymbol = 4; break;
                default: 
                    displayErrorBER('Invalid modulation scheme selected.'); 
                    document.getElementById('loadingSpinnerBER').style.display = 'none'; 
                    return;
            }
            
            const numBitsPerOFDMSymbol = numSubcarriers * bitsPerSymbol;
            const snrRangeDb = Array.from({ length: 26 }, (_, i) => i);
            const berResults = [];

            try {
                for (const snr of snrRangeDb) {
                    let totalErrorsForThisSNR = 0;
                    let totalBitsForThisSNR = 0;

                    for (let s = 0; s < numSymbolsBer; s++) {
                        const originalBits = generateBits(numBitsPerOFDMSymbol);
                        const modulatedSymbols = modulate(originalBits, modulationScheme, bitsPerSymbol);
                        const ifftInput = mapToSubcarriers(modulatedSymbols, nFFTSize, numSubcarriers);
                        const ifftOutput = ifft(ifftInput);
                        const txWaveform = addCyclicPrefix(ifftOutput, cpLength);
                        
                        const { fadedSignal, channelGains } = applyRayleighFading(txWaveform);
                        const rxWaveform = addAwgn(fadedSignal, snr);
                        
                        const rxNoCP = removeCyclicPrefix(rxWaveform, cpLength, nFFTSize);
                        const rxFFT = fft(rxNoCP);

                        // Get channel gains for equalization
                        const channelGainsNoCP = channelGains.slice(cpLength, cpLength + nFFTSize);
                        const channelGainsFFT = fft(channelGainsNoCP);

                        // Extract data subcarriers and equalize
                        const dataSubcarrierIndices = [];
                        if (nFFTSize === 64 && numSubcarriers === 52) {
                            const subcarrierIndices80211a = [-26, -25, -24, -23, -22, -21, -20, -19, -18, -17, -16, -15, -14, -13, -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1,
                                                            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26];
                            for (const scIdx of subcarrierIndices80211a) {
                                let arrayIdx = scIdx > 0 ? scIdx : nFFTSize + scIdx;
                                dataSubcarrierIndices.push(arrayIdx);
                            }
                        } else {
                            const halfSubcarriers = Math.floor(numSubcarriers / 2);
                            for (let i = 1; i <= halfSubcarriers; i++) { dataSubcarrierIndices.push(i); }
                            for (let i = nFFTSize - halfSubcarriers; i < nFFTSize; i++) { dataSubcarrierIndices.push(i); }
                        }
                        
                        const receivedDataSymbols = dataSubcarrierIndices.map(idx => rxFFT[idx]);
                        const channelGainsData = dataSubcarrierIndices.map(idx => channelGainsFFT[idx]);
                        const equalizedSymbols = equalize(receivedDataSymbols, channelGainsData, equalizationMethod, snr);
                        const receivedBits = demodulate(equalizedSymbols, modulationScheme);

                        let bitErrorsForSymbol = 0;
                        for (let i = 0; i < originalBits.length; i++) {
                            if (originalBits[i] !== receivedBits[i]) {
                                bitErrorsForSymbol++;
                            }
                        }
                        totalErrorsForThisSNR += bitErrorsForSymbol;
                        totalBitsForThisSNR += originalBits.length;
                    }
                    
                    const ber = totalBitsForThisSNR > 0 ? totalErrorsForThisSNR / totalBitsForThisSNR : 0;
                    berResults.push(Math.max(ber, 1e-6));
                }

                updateBerChart(snrRangeDb, berResults);
                hideStepByStepCharts();
                showChart('berCurveChart');

            } catch (error) {
                console.error("BER simulation error:", error);
                displayErrorBER(`BER simulation failed: ${error.message}. Please check inputs.`);
            } finally {
                document.getElementById('loadingSpinnerBER').style.display = 'none';
            }
        }

        function displayErrorBER(message) {
            const errorMessageDiv = document.getElementById('errorMessageBER');
            errorMessageDiv.textContent = message;
            errorMessageDiv.style.display = 'block';
            document.getElementById('loadingSpinnerBER').style.display = 'none';
        }
        
        // Find and modify these arrays
        const allOfdmBlockIds = ['block-tx', 'block-idft', 'block-addcp', 'block-channel', 'block-removecp', 'block-fft', 'block-equalizer', 'block-rx'];
        const blockOutputTitles = [
            'S/P & Mapping Output',
            'IDFT Output',
            'Add CP Output',
            'Channel Output',
            'Remove CP Output',
            'FFT Output',
            'Equalizer Output', // New title
            'Demapping & P/S Output'
        ];
        let currentBlockIndex = 0;

        function highlightBlock(index) {
            const nextBtn = document.getElementById('nextBlockBtn');
            const prevBtn = document.getElementById('prevBlockBtn');
            nextBtn.disabled = (index === allOfdmBlockIds.length - 1);
            prevBtn.disabled = (index === 0);

            allOfdmBlockIds.forEach(id => {
                const block = document.getElementById(id);
                if (block) block.classList.remove('highlighted');
                const text = block.querySelector('.ofdm-block-text');
                if (text) text.classList.remove('highlighted');
            });
            
            document.querySelectorAll('.arrow').forEach(arrow => arrow.classList.remove('highlighted'));

            if (index >= 0 && index < allOfdmBlockIds.length) {
                const currentBlockElement = document.getElementById(allOfdmBlockIds[index]);
                if (currentBlockElement) {
                    currentBlockElement.classList.add('highlighted');
                    currentBlockElement.querySelectorAll('.ofdm-block-text').forEach(t => t.classList.add('highlighted'));
                }
                if (index > 0) {
                    const prevArrowId = getArrowId(index - 1, index);
                    document.getElementById(prevArrowId)?.classList.add('highlighted');
                }
            }

            updateChartVisibility(index);
            updateBlockOutputDisplayContent(index);
        }
        
        // Replace your getArrowId function with this one
        function getArrowId(fromIndex, toIndex) {
            const transitions = {
                '0-1': 'mapping-to-idft',
                '1-2': 'idft-to-addcp',
                '2-3': 'addcp-to-channel',
                '3-4': 'channel-to-removecp',
                '4-5': 'removecp-to-fft',
                '5-6': 'fft-to-equalizer',
                '6-7': 'equalizer-to-demapping'
            };
            return transitions[`${fromIndex}-${toIndex}`] || '';
        }

        function hideStepByStepCharts() {
            document.getElementById('constellationChart').style.display = 'none';
            document.getElementById('preChannelSpectrumChart').style.display = 'none';
            document.getElementById('postChannelSpectrumChart').style.display = 'none';
            document.getElementById('constellationChartTitle').style.display = 'none';
            document.getElementById('preChannelSpectrumChartTitle').style.display = 'none';
            document.getElementById('postChannelSpectrumChartTitle').style.display = 'none';
        }

        function showOutputChart(chartId) {
            hideOutputCharts();
            document.getElementById(chartId).style.display = 'block';
            document.getElementById(`${chartId}Title`).style.display = 'block';
        }

        function hideOutputCharts() {
            document.getElementById('receivedConstellationChart').style.display = 'none';
            document.getElementById('berCurveChart').style.display = 'none';
            document.getElementById('receivedConstellationChartTitle').style.display = 'none';
            document.getElementById('berCurveChartTitle').style.display = 'none';
        }

        function updateChartVisibility(blockIndex) {
            hideStepByStepCharts();
            hideOutputCharts();
            switch (allOfdmBlockIds[blockIndex]) {
                case 'block-tx':
                    showChart('constellationChart');
                    break;
                case 'block-addcp':
                    showChart('preChannelSpectrumChart');
                    break;
                case 'block-channel':
                    showChart('postChannelSpectrumChart');
                    break;
                case 'block-rx':
                    showChart('receivedConstellationChart');
                    break;
            }
        }
        function showChart(chartId) {
            document.getElementById(chartId).style.display = 'block';
            document.getElementById(`${chartId}Title`).style.display = 'block';
        }

        /**
         * Updates the step-by-step info panel with a text description and styled symbol boxes.
         */
        function updateBlockOutputDisplayContent(blockIndex) {
            const titleDiv = document.getElementById('blockOutputTitle');
            const descriptionDiv = document.getElementById('blockOutputDisplay');
            titleDiv.textContent = blockOutputTitles[blockIndex];

            const nFFTSize = parseInt(document.getElementById('nFFTSize').value);
            const cpLength = parseInt(document.getElementById('cpLength').value);
            
            let description = "Run a simulation to see the step-by-step output here.";
            let showSymbols = false;
            let symbolData = [];

            switch (allOfdmBlockIds[blockIndex]) {
                case 'block-tx':
                    if (globalTransmittedBits.length) {
                        description = `Generated Bits: ${formatBitArrayForDisplay(globalTransmittedBits)}\n`
                                    + `Modulated to ${globalModulatedSymbols.length} ${document.getElementById('modulationScheme').value} symbols.`;
                        showSymbols = true;
                        symbolData = formatSymbolDisplay(
                            globalModulatedSymbols.map((s, i) => ({
                                value: s,
                                label: `X[${i}]`, // Capital X for frequency-domain
                                type: 'data'
                            }))
                        );
                    }
                    break;

                case 'block-idft':
                    if (globalTxWaveformPreChannel.length) {
                        description = `Converted frequency-domain symbols to a time-domain signal of ${nFFTSize} samples.`;
                        showSymbols = true;
                        symbolData = formatSymbolDisplay(
                            globalTxWaveformPreChannel.slice(cpLength).map((s, i) => ({
                                value: s,
                                label: `x[${i}]`, // Lowercase x for time-domain
                                type: 'data'
                            }))
                        );
                    }
                    break;

                case 'block-addcp':
                    if (globalTxWaveformPreChannel.length) {
                        description = `Prepended ${cpLength} samples from the end to the beginning. Total signal length is now ${nFFTSize + cpLength}.`;
                        showSymbols = true;
                        symbolData = formatCPSymbolDisplay(globalTxWaveformPreChannel, nFFTSize, cpLength);
                    }
                    break;

                case 'block-channel':
                    if (globalRxWaveformPostChannel.length) {
                        description = `Signal passed through a simulated channel with fading and noise.`;
                        showSymbols = true;
                        symbolData = formatSymbolDisplay(
                            globalRxWaveformPostChannel.map((s, i) => ({
                                value: s,
                                label: `y[${i}]`,
                                type: 'data'
                            }))
                        );
                    }
                    break;

                case 'block-removecp':
                    if (globalRxNoCP.length) {
                        description = `Removed the ${cpLength}-sample cyclic prefix. Remaining signal length is ${globalRxNoCP.length}.`;
                        showSymbols = true;
                        symbolData = formatSymbolDisplay(
                            globalRxNoCP.map((s, i) => ({
                                value: s,
                                label: `r[${i}]`,
                                type: 'data'
                            }))
                        );
                    }
                    break;

                case 'block-fft':
                    if (globalRxFFTOutput.length) {
                        description = `Converted the time-domain signal back to the frequency domain to recover symbols on each subcarrier.`;
                        showSymbols = true;
                        symbolData = formatSymbolDisplay(
                            globalRxFFTOutput.map((s, i) => ({
                                value: s,
                                label: `R[${i}]`,
                                type: 'data'
                            }))
                        );
                    }
                    break;

                // Add this new case for the equalizer
                case 'block-equalizer':
                    if (globalReceivedSymbols.length) {
                        const method = document.getElementById('equalization').value;
                        description = `Applied ${method} equalization to compensate for channel distortion and noise.`;
                        showSymbols = true;
                        symbolData = formatSymbolDisplay(
                            globalReceivedSymbols.map((s, i) => ({
                                value: s,
                                label: `X[${i}]`,
                                type: 'data'
                            }))
                        );
                    }
                    break;

                case 'block-rx':
                    if (globalReceivedSymbols.length) {
                        const modulationScheme = document.getElementById('modulationScheme').value;
                        const demodulatedBits = demodulate(globalReceivedSymbols, modulationScheme);
                        const ber = calculateBer(globalTransmittedBits, demodulatedBits).toExponential(2);
                        description = `Equalized and demapped symbols back into a bitstream.\nCalculated Bit Error Rate (BER): ${ber}`;
                        showSymbols = true;
                        // Show a comparison of transmitted vs. received bits
                        symbolData = formatSymbolDisplay(
                            globalTransmittedBits.slice(0, 40).map((txBit, i) => ({
                                value: `Tx: ${txBit}, Rx: ${demodulatedBits[i]}`,
                                label: `${txBit}${demodulatedBits[i]}`,
                                type: txBit === demodulatedBits[i] ? 'data' : 'cp'
                            }))
                        );
                    }
                    break;
            }

            descriptionDiv.textContent = description;
            updateSymbolDisplay(showSymbols, symbolData);
        }

        function clearAllChartData() {
            const charts = [constellationChart, preChannelSpectrumChart, postChannelSpectrumChart, receivedConstellationChart, berCurveChart];
            charts.forEach(chart => {
                if (chart) {
                    chart.data.labels = [];
                    chart.data.datasets.forEach(dataset => { dataset.data = []; });
                    chart.update();
                }
            });
        }

        function resetSimulation() {
            clearAllChartData();
            hideStepByStepCharts();
            hideOutputCharts();

            currentBlockIndex = 0;
            highlightBlock(currentBlockIndex);
            
            document.getElementById('errorMessage').style.display = 'none';
            document.getElementById('loadingSpinner').style.display = 'none';
            document.getElementById('blockOutputTitle').textContent = "Simulation Step Output";
            document.getElementById('blockOutputDisplay').innerHTML = "Run a simulation to see the step-by-step output here.";

            document.getElementById('nFFTSize').value = 64;
            document.getElementById('numSubcarriers').value = 52;
            document.getElementById('modulationScheme').value = 'BPSK';
            document.getElementById('cpLength').value = 16;
            document.getElementById('snrDb').value = 20;
            document.getElementById('numSymbolsBer').value = 1000;
        }
        
        function getIdealConstellationPoints(modulationScheme) {
            switch (modulationScheme) {
                case 'BPSK':
                    return [new Complex(-1), new Complex(1)];
                case 'QPSK':
                    const qpskScale = 1 / Math.sqrt(2);
                    return [
                        new Complex(qpskScale, qpskScale), new Complex(qpskScale, -qpskScale),
                        new Complex(-qpskScale, qpskScale), new Complex(-qpskScale, -qpskScale)
                    ];
                case '16QAM':
                    const qam16Scale = 1 / Math.sqrt(10);
                    const levels = [-3, -1, 1, 3];
                    const points = [];
                    for (const re of levels) {
                        for (const im of levels) {
                            points.push(new Complex(re * qam16Scale, im * qam16Scale));
                        }
                    }
                    return points;
                default:
                    return [];
            }
        }

        let constellationChart, preChannelSpectrumChart, postChannelSpectrumChart, receivedConstellationChart, berCurveChart;

        // Updated initializeCharts function for better responsiveness
        function initializeCharts() {
            // Set canvas dimensions based on container size
            const setCanvasDimensions = (id) => {
                const canvas = document.getElementById(id);
                if (canvas) {
                    const container = canvas.parentElement;
                    const containerWidth = container.offsetWidth;
                    canvas.style.width = '100%';
                    canvas.style.height = '350px';
                    canvas.width = Math.min(containerWidth, 800);
                    canvas.height = 350;
                }
            };

            const canvases = ['constellationChart', 'preChannelSpectrumChart', 'postChannelSpectrumChart', 'receivedConstellationChart', 'berCurveChart'];
            canvases.forEach(setCanvasDimensions);

            const constellationConfig = {
                type: 'scatter',
                data: { datasets: [{ label: 'Constellation Diagram', data: [], backgroundColor: 'rgb(236, 72, 153)', pointRadius: 4, pointHoverRadius: 6 }] },
                options: {
                    responsive: true,  // Changed back to true for better responsiveness
                    maintainAspectRatio: false,
                    plugins: {
                        title: { display: false },
                        legend: { display: false },
                        tooltip: { callbacks: { label: c => `(${c.parsed.x.toFixed(2)}, ${c.parsed.y.toFixed(2)}i)` } }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            min: -2,
                            max: 2,
                            title: { display: true, text: 'In-phase (Real)', font: { size: 12, weight: 'bold' }, color: '#4b5563' },
                            grid: { color: '#e5e7eb' },
                            ticks: { color: '#6b7280', font: { size: 10 } }
                        },
                        y: {
                            type: 'linear',
                            position: 'left',
                            min: -2,
                            max: 2,
                            title: { display: true, text: 'Quadrature (Imaginary)', font: { size: 12, weight: 'bold' }, color: '#4b5563' },
                            grid: { color: '#e5e7eb' },
                            ticks: { color: '#6b7280', font: { size: 10 } }
                        }
                    }
                }
            };

            const spectrumConfig = {
                type: 'line',
                data: { datasets: [{ data: [], borderWidth: 2, pointRadius: 0, fill: false, tension: 0.1 }] },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        x: { 
                            title: { display: true, text: 'Frequency (MHz)', font: { size: 12, weight: 'bold' }, color: '#4b5563' }, 
                            grid: { color: '#e2e8f0' },
                            ticks: { font: { size: 10 } }
                        },
                        y: { 
                            title: { display: true, text: 'PSD (dB)', font: { size: 12, weight: 'bold' }, color: '#4b5563' }, 
                            grid: { color: '#e2e8f0' },
                            ticks: { font: { size: 10 } }
                        }
                    }
                }
            };

            const berConfig = {
                type: 'line',
                data: { labels: [], datasets: [{ label: 'BER', data: [], borderColor: 'rgb(34, 197, 94)', backgroundColor: 'rgba(34, 197, 94, 0.2)', borderWidth: 2, pointRadius: 3, pointBackgroundColor: 'rgb(34, 197, 94)', fill: false, tension: 0.1 }] },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        x: { 
                            min: 0, max: 25, 
                            title: { display: true, text: 'SNR (dB)', font: { size: 12, weight: 'bold' }, color: '#4b5563' },
                            ticks: { font: { size: 10 } }
                        },
                        y: { 
                            type: 'logarithmic', 
                            title: { display: true, text: 'BER', font: { size: 12, weight: 'bold' }, color: '#4b5563' }, 
                            min: 1e-6, max: 1,
                            ticks: { 
                                callback: v => (v === 1e-1 || v === 1e-2 || v === 1e-3 || v === 1e-4 || v === 1e-5 || v === 1e-6) ? v.toExponential() : null,
                                font: { size: 10 }
                            }
                        }
                    }
                }
            };

            constellationChart = new Chart(document.getElementById('constellationChart').getContext('2d'), constellationConfig);
            preChannelSpectrumChart = new Chart(document.getElementById('preChannelSpectrumChart').getContext('2d'), { ...spectrumConfig, data: { datasets: [{ ...spectrumConfig.data.datasets[0], borderColor: 'rgb(59, 130, 246)', backgroundColor: 'rgba(59, 130, 246, 0.2)' }] } });
            postChannelSpectrumChart = new Chart(document.getElementById('postChannelSpectrumChart').getContext('2d'), { ...spectrumConfig, data: { datasets: [{ ...spectrumConfig.data.datasets[0], borderColor: 'rgb(234, 88, 12)', backgroundColor: 'rgba(234, 88, 12, 0.2)' }] } });
            receivedConstellationChart = new Chart(document.getElementById('receivedConstellationChart').getContext('2d'), { ...constellationConfig, data: { datasets: [{ ...constellationConfig.data.datasets[0], label: 'Received Constellation', backgroundColor: 'rgb(34, 197, 94)' }] } });
            berCurveChart = new Chart(document.getElementById('berCurveChart').getContext('2d'), berConfig);

            // Add window resize handler
            window.addEventListener('resize', () => {
                setTimeout(() => {
                    canvases.forEach(setCanvasDimensions);
                    [constellationChart, preChannelSpectrumChart, postChannelSpectrumChart, receivedConstellationChart, berCurveChart].forEach(chart => {
                        if (chart) chart.resize();
                    });
                }, 100);
            });
        }

        /**
         * Renders the symbol boxes in the dedicated symbol display area.
         */
        function updateSymbolDisplay(show, symbolData) {
            const symbolDisplay = document.getElementById('symbolDisplay');
            if (!symbolDisplay) return;

            if (show && symbolData && symbolData.length > 0) {
                symbolDisplay.innerHTML = '';
                symbolDisplay.style.display = 'flex';

                symbolData.forEach(symbol => {
                    if (symbol.type === 'separator') {
                        const separator = document.createElement('div');
                        separator.className = 'symbol-separator';
                        separator.textContent = symbol.label;
                        symbolDisplay.appendChild(separator);
                    } else {
                        const item = document.createElement('div');
                        item.className = `symbol-item ${symbol.type}`;
                        item.textContent = symbol.label;
                        
                        if (symbol.value) {
                            item.title = `${symbol.label}: ${symbol.value.toString()}`;
                        }
                        symbolDisplay.appendChild(item);
                    }
                });
            } else {
                symbolDisplay.style.display = 'none';
            }
        }

        /**
         * Formats a long array of symbols to show the first few, an ellipsis, and the last one.
         */
        function formatSymbolDisplay(symbols) {
            if (symbols.length <= 12) {
                return symbols;
            }
            // Show first 5, ellipsis, and last 2
            return [
                ...symbols.slice(0, 5),
                { label: '...', type: 'ellipsis' },
                ...symbols.slice(symbols.length - 2)
            ];
        }

        /**
         * Specifically formats the signal with a styled cyclic prefix.
         */
        function formatCPSymbolDisplay(cpAddedSignal, M, L) {
            const result = [];
            const cpData = cpAddedSignal.slice(0, L).map((s, i) => ({
                label: `x[${M - L + i}]`,
                type: 'cp',
                value: s
            }));
            
            const dataPart = cpAddedSignal.slice(L).map((s, i) => ({
                label: `x[${i}]`,
                type: 'data',
                value: s
            }));

            if (L > 4) {
                result.push(cpData[0], { label: '...', type: 'ellipsis' }, cpData[L - 1]);
            } else {
                result.push(...cpData);
            }

            result.push({ label: '|', type: 'separator' });

            if (M > 8) {
                result.push(...dataPart.slice(0, 3), { label: '...', type: 'ellipsis' }, ...dataPart.slice(M - 2));
            } else {
                result.push(...dataPart);
            }
            return result;
        }

        // Fixed updateConstellationChart function
        function updateConstellationChart(chart, symbols, modulationScheme) {
            if (!chart) return;

            let axisMax = 2.0; // Default axis range
            
            const idealPoints = getIdealConstellationPoints(modulationScheme);
            if (idealPoints.length > 0) {
                const maxMag = Math.max(...idealPoints.map(p => Math.max(Math.abs(p.re), Math.abs(p.im))));
                axisMax = Math.max(maxMag * 1.5, 2.0);
            }
            
            // Cap the range to reasonable limits
            axisMax = Math.min(axisMax, 5.0);

            const validData = symbols.filter(s => 
                isFinite(s.re) && isFinite(s.im) &&
                Math.abs(s.re) <= 10 && Math.abs(s.im) <= 10
            ).map(s => ({ x: s.re, y: s.im }));

            chart.options.scales.x.min = -axisMax;
            chart.options.scales.x.max = axisMax;
            chart.options.scales.y.min = -axisMax;
            chart.options.scales.y.max = axisMax;

            chart.data.datasets[0].data = validData;
            chart.update();
        }

        function updateSpectrumChart(chartInstance, labels, data) {
            if (chartInstance) {
                const validLabels = [];
                const validData = [];
                
                for (let i = 0; i < data.length; i++) {
                    const value = data[i];
                    if (isFinite(value) && !isNaN(value) && value > -200 && value < 100) {
                        validLabels.push(parseFloat(labels[i]).toFixed(2));
                        validData.push(value);
                    }
                }
                
                chartInstance.data.labels = validLabels;
                chartInstance.data.datasets[0].data = validData;
                chartInstance.update();
            }
        }
        
        function updateConstellationChart(chart, symbols, modulationScheme) {
    if (!chart) return;

    let maxMag = 0;
    const idealPoints = getIdealConstellationPoints(modulationScheme);
    if (idealPoints.length > 0) {
        maxMag = Math.max(...idealPoints.map(p => Math.max(Math.abs(p.re), Math.abs(p.im))));
    }
    
    // Set a minimum axis range and ensure it's finite
    let axisMax = Math.max(maxMag * 1.5, 2.0); // Minimum range of 2.0
    
    // Safety check to prevent infinite or NaN values
    if (!isFinite(axisMax) || axisMax <= 0) {
        axisMax = 2.0; // Default fallback value
    }
    
    // Cap the maximum range to prevent overly large plots
    axisMax = Math.min(axisMax, 10.0); // Maximum range of 10.0

    const validData = symbols.filter(s => 
        isFinite(s.re) && isFinite(s.im) &&
        Math.abs(s.re) <= 20 && Math.abs(s.im) <= 20 // Filter out extreme values
    ).map(s => ({ x: s.re, y: s.im }));

    chart.options.scales.x.min = -axisMax;
    chart.options.scales.x.max = axisMax;
    chart.options.scales.y.min = -axisMax;
    chart.options.scales.y.max = axisMax;

    chart.data.datasets[0].data = validData;
    chart.update();
}
        
        function updateTransmittedConstellationChart(symbols, modulationScheme) {
            updateConstellationChart(constellationChart, symbols, modulationScheme);
        }

        function updateReceivedConstellationChart(symbols, modulationScheme) {
            updateConstellationChart(receivedConstellationChart, symbols, modulationScheme);
        }

        function updateBerChart(snrLabels, berData) {
            if (berCurveChart) {
                berCurveChart.data.labels = snrLabels;
                berCurveChart.data.datasets[0].data = berData;
                berCurveChart.update();
            }
        }

        function displayError(message) {
            const errorMessageDiv = document.getElementById('errorMessage');
            errorMessageDiv.textContent = message;
            errorMessageDiv.style.display = 'block';
            document.getElementById('loadingSpinner').style.display = 'none';
        }

        window.onload = function() {
            initializeCharts();
            document.getElementById('runStepByStepBtn').addEventListener('click', runStepByStepSimulation);
            document.getElementById('runBerSimBtn').addEventListener('click', runBerSimulation);
            
            document.getElementById('nextBlockBtn').addEventListener('click', () => {
                if (currentBlockIndex < allOfdmBlockIds.length - 1) {
                    currentBlockIndex++;
                    highlightBlock(currentBlockIndex);
                }
            });
            document.getElementById('prevBlockBtn').addEventListener('click', () => {
                if (currentBlockIndex > 0) {
                    currentBlockIndex--;
                    highlightBlock(currentBlockIndex);
                }
            });
            
            // Show the simulation tab by default
            document.getElementById('simulationTab').style.display = 'block';
            resetSimulation();
        };
    </script>
</body>
</html>