<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced MIMO Wireless Communication Equalizer</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #eef2f5;
            min-height: 100vh;
            color: #333;
        }

        .container-fluid {
            padding: 15px;
        }

        .main-header {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
        }

        .main-header h1 {
            font-size: clamp(2rem, 5vw, 3rem);
            font-weight: 800;
            margin-bottom: 10px;
        }

        .main-header p {
            font-size: clamp(1rem, 2.5vw, 1.3rem);
            opacity: 0.9;
        }

        .experiment-container {
            background: #ffffff;
            border-radius: 25px;
            box-shadow: 0 15px 40px rgba(0,0,0,0.1);
            border: 1px solid #dee2e6;
            overflow: hidden;
            margin-bottom: 30px;
        }

        .tab-container {
            background: #f8f9fa;
            padding: 0;
            border-bottom: 1px solid #dee2e6;
        }

        .nav-tabs {
            border: none;
            justify-content: center;
            flex-wrap: wrap;
        }

        .nav-tabs .nav-link {
            background: transparent;
            border: none;
            color: #495057;
            font-weight: 700;
            padding: 15px 25px;
            margin: 0 5px;
            border-radius: 0;
            transition: all 0.3s ease;
            font-size: clamp(0.9rem, 2vw, 1.1rem);
            white-space: nowrap;
        }

        .nav-tabs .nav-link:hover {
            background: rgba(13, 110, 253, 0.05);
            color: #0d6efd;
        }

        .nav-tabs .nav-link.active {
            background: white;
            color: #0d6efd;
            border-radius: 15px 15px 0 0;
            border-top: 4px solid #0d6efd;
            box-shadow: 0 -5px 15px rgba(0,0,0,0.05);
        }

        .tab-content {
            padding: 20px;
        }

        .instructions-card {
            background: linear-gradient(135deg, #e3f2fd, #f3e5f5);
            color: #1a237e;
            border-radius: 20px;
            padding: 20px;
            margin-bottom: 30px;
            border: 1px solid rgba(63, 81, 181, 0.1);
            box-shadow: 0 8px 25px rgba(63, 81, 181, 0.1);
        }

        .instructions-card h3 {
            margin-bottom: 15px;
            font-weight: 700;
            color: #3f51b5;
            font-size: clamp(1.2rem, 3vw, 1.5rem);
        }

        .instructions-card ol, .instructions-card p {
            padding-left: 20px;
        }

        .instructions-card li {
            margin-bottom: 10px;
            font-size: clamp(0.9rem, 2vw, 1.1rem);
            line-height: 1.6;
        }
        
        .control-panel, .visualization-area, .output-panel {
            background: #f8f9fa;
            border-radius: 20px;
            padding: 15px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.05);
            border: 1px solid #e9ecef;
            height: 100%;
        }

        .input-group {
            margin-bottom: 10px;
            display: flex;
            flex-direction: column;
        }

        .input-group.horizontal {
            flex-direction: row;
            justify-content: space-between;
            align-items: center;
            background: white;
            padding: 10px 15px;
            border-radius: 10px;
            border: 1px solid #e9ecef;
            box-shadow: 0 4px 10px rgba(0,0,0,0.05);
            margin-bottom: 10px;
        }

        .input-group.horizontal label {
            margin-bottom: 0;
            flex-grow: 1;
            text-align: left;
        }

        .input-group.horizontal .form-select,
        .input-group.horizontal .form-control {
            flex-grow: 0;
            width: 120px;
            text-align: center;
            border: none;
            box-shadow: none;
            padding: 8px;
            border-radius: 5px;
            background-color: #f8f9fa;
            border: 1px solid #e0e0e0;
        }
        
        .form-control, .form-select {
            border-radius: 10px;
            border: 2px solid #e0e0e0;
            padding: 12px 15px;
            font-size: clamp(14px, 2vw, 16px);
            transition: all 0.3s ease;
            background: white;
        }

        .form-control:focus, .form-select:focus {
            border-color: #0d6efd;
            box-shadow: 0 0 0 0.25rem rgba(13, 110, 253, 0.25);
        }

        .control-panel h4 {
            text-align: center;
            font-weight: 800;
            margin-bottom: 20px;
            color: #2c3e50;
            font-size: 1.5rem;
        }
        .control-panel .btn {
            font-size: 1rem;
            padding: 10px;
        }

        .btn-primary, .btn-secondary {
            border-radius: 12px;
            padding: 12px 20px;
            font-weight: 700;
            transition: all 0.3s ease;
            border: none;
            font-size: clamp(14px, 2vw, 16px);
        }

        .btn-primary {
            background: linear-gradient(135deg, #0d6efd, #6610f2);
            box-shadow: 0 8px 25px rgba(13, 110, 253, 0.3);
            color: white;
        }
        
        .btn-secondary {
            background: #6c757d;
            box-shadow: 0 8px 25px rgba(108, 117, 125, 0.2);
            color: white;
        }

        .technique-selector {
            background: white;
            border-radius: 15px;
            padding: 15px;
            margin-top: 15px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.05);
        }

        .technique-options {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .technique-option {
            flex: 1;
            position: relative;
            min-width: 80px;
        }

        .technique-option input[type="radio"] { display: none; }

        .technique-option label {
            display: block;
            padding: 10px 8px;
            background: #f8f9fa;
            border: 3px solid #e0e0e0;
            border-radius: 15px;
            text-align: center;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: clamp(12px, 2vw, 14px);
        }

        .technique-option input[type="radio"]:checked + label {
            background: linear-gradient(135deg, #0d6efd, #6610f2);
            color: white;
            border-color: #0d6efd;
            transform: scale(1.05);
            box-shadow: 0 8px 25px rgba(13, 110, 253, 0.3);
        }

        .visualization-area {
            min-height: 350px;
            display: flex;
            align-items: center;
            padding: 10px;
            justify-content: flex-start;
            position: relative;
            overflow-x: auto;
        }

        .signal-flow {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: nowrap;
            justify-content: flex-start;
            min-width: max-content;
        }

        .signal-block {
            background: white;
            border-radius: 15px;
            padding: 10px;
            box-shadow: 0 12px 35px rgba(0,0,0,0.08);
            text-align: center;
            min-width: 140px;
            transition: all 0.3s ease;
            flex-shrink: 0;
            border: 1px solid #e9ecef;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .signal-block h4 {
            font-size: clamp(0.8rem, 2vw, 1rem);
            font-weight: 700;
            margin-bottom: 8px;
            color: #333;
        }

        .signal-value {
            font-family: 'JetBrains Mono', 'Courier New', monospace;
            font-size: clamp(0.7rem, 1.5vw, 0.9rem);
            color: #666;
            word-break: break-all;
            line-height: 1.4;
            text-align: left;
            padding: 0 5px;
            flex-grow: 1;
        }

        .arrow {
            font-size: clamp(1.5rem, 4vw, 2.5rem);
            color: #0d6efd;
            animation: pulse 2s infinite;
            align-self: center;
        }

        .noise-adder {
            align-self: center;
            text-align: center;
            font-size: clamp(1.5rem, 4vw, 2.5rem);
            color: #333;
            margin: 0 5px;
            animation: fadein 1s;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            /* New rule to adjust the vertical position */
            transform: translateY(10px); 
        }
        .noise-adder-circle {
            border: 2px solid #333;
            border-radius: 50%;
            width: 2em;
            height: 2em;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2rem;
            line-height: 1;
            font-weight: bold;
        }
        .noise-adder-label {
            font-size: 0.8rem;
            color: #6c757d;
            margin-top: 5px;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.1); }
        }

        .results-panel {
            background: #f8f9fa;
            border-radius: 20px;
            padding: 15px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.05);
            border: 1px solid #e9ecef;
        }

        .results-panel h4 {
            color: #333;
            margin-bottom: 15px;
            font-weight: 700;
            font-size: clamp(1.1rem, 2.5vw, 1.3rem);
        }

        .metric-card {
            background: white;
            border-radius: 15px;
            padding: 12px;
            margin-bottom: 12px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.05);
            border: 1px solid #e9ecef;
        }

        .metric-label {
            font-weight: 700;
            color: #666;
            font-size: clamp(0.8rem, 1.8vw, 0.95rem);
            margin-bottom: 5px;
        }

        .metric-value {
            font-size: clamp(1.3rem, 3vw, 1.8rem);
            font-weight: 800;
            color: #333;
        }

        /* Replace the .chart-container CSS rule with this fixed version */

        .chart-container {
            background: white;
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 12px 35px rgba(0,0,0,0.08);
            position: relative;
            border: 1px solid #e9ecef;
            height: 500px; /* Fixed height to prevent infinite stretching */
            max-height: 500px; /* Ensure it doesn't exceed this height */
        }

        .chart-container canvas {
            max-height: 400px !important; /* Limit canvas height */
        }

        .chart-container .loading {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.9);
            z-index: 10;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            border-radius: 20px;
        }

        .constellation-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .constellation-plot {
            background: white;
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.08);
            border: 1px solid #e9ecef;
        }

        .constellation-plot h5 {
            text-align: center;
            margin-bottom: 10px;
            font-weight: 700;
            color: #333;
            font-size: clamp(0.9rem, 2vw, 1.1rem);
        }

        .loading {
            display: none;
            text-align: center;
            padding: 30px;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.95);
            z-index: 10;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            border-radius: 20px;
            backdrop-filter: blur(5px);
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #0d6efd;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        #loadingIndicator p, #chartLoadingIndicator p {
            font-weight: 700;
            color: #333;
            font-size: clamp(0.9rem, 2vw, 1.1rem);
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media (max-width: 1199px) {
            .tab-content {
                padding: 15px;
            }
            .control-panel, .visualization-area, .output-panel {
                margin-bottom: 15px;
            }
        }

        @media (max-width: 991px) {
            .control-panel, .visualization-area, .output-panel {
                margin-bottom: 20px;
            }
            .constellation-container {
                grid-template-columns: 1fr;
            }
            .input-group {
                margin-bottom: 10px;
            }
            .signal-flow {
                gap: 10px;
            }
            .signal-block {
                min-width: 120px;
                padding: 12px;
            }
        }

        @media (max-width: 768px) {
            .container-fluid {
                padding: 10px;
            }
            .tab-content {
                padding: 10px;
            }
            .control-panel, .visualization-area, .output-panel {
                padding: 10px;
            }
            .instructions-card {
                padding: 15px;
            }
            .technique-options {
                gap: 5px;
            }
            .nav-tabs .nav-link {
                padding: 12px 15px;
                margin: 0 2px;
            }
        }

        @media (max-width: 576px) {
            .signal-flow {
                flex-direction: column;
                align-items: center;
            }
            .arrow, .noise-adder {
                transform: rotate(90deg);
            }
            .signal-block {
                width: 100%;
                min-width: auto;
            }
            .technique-options {
                flex-direction: column;
            }
            .technique-option {
                min-width: auto;
            }
        }
    </style>
</head>
<body>
    <div class="container-fluid">
        <div class="main-header">
            <h1>Advanced MIMO Wireless Communication Equalizer</h1>
            <p>Interactive Simulation with Complex Channels & Constellation Analysis</p>
        </div>

        <div class="experiment-container">
            <div class="tab-container">
                <ul class="nav nav-tabs" id="myTab" role="tablist">
                    <li class="nav-item" role="presentation">
                        <button class="nav-link active" id="equalizer-tab" data-bs-toggle="tab" data-bs-target="#equalizer" type="button" role="tab">Equalizer Simulation</button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="performance-tab" data-bs-toggle="tab" data-bs-target="#performance" type="button" role="tab">Performance Analysis</button>
                    </li>
                </ul>
            </div>

            <div class="tab-content">
                <div class="tab-pane fade show active" id="equalizer" role="tabpanel">
                    <div class="instructions-card">
                        <h3>MIMO Experiment Instructions</h3>
                        <ol>
                            <li>Select your modulation scheme and MIMO configuration (Nt transmit × Nr receive antennas).</li>
                            <li>Set the desired SNR and click **Simulate Channel** to run equalization.</li>
                            <li>Observe the signal flow, performance metrics, and constellation plots.</li>
                            <li>Click **Run with New Symbols** to repeat with new random symbols.</li>
                        </ol>
                    </div>

                    <div class="row">
                        <div class="col-xl-3 col-lg-4 col-md-12">
                            <div class="control-panel">
                                <h4>Inputs</h4>
                                <div class="input-group horizontal">
                                    <label for="modulationScheme">Modulation:</label>
                                    <select class="form-select" id="modulationScheme">
                                        <option value="BPSK">BPSK</option>
                                        <option value="QPSK" selected>QPSK</option>
                                        <option value="16QAM">16-QAM</option>
                                        <option value="64QAM">64-QAM</option>
                                    </select>
                                </div>
                                <div class="input-group horizontal">
                                    <label for="numTxAntennas">Tx Antennas (Nt):</label>
                                    <select class="form-select" id="numTxAntennas">
                                        <option value="2" selected>2</option>
                                        <option value="3">3</option>
                                        <option value="4">4</option>
                                        <option value="6">6</option>
                                        <option value="8">8</option>
                                        <option value="16">16</option>
                                    </select>
                                </div>
                                <div class="input-group horizontal">
                                    <label for="numRxAntennas">Rx Antennas (Nr):</label>
                                    <select class="form-select" id="numRxAntennas">
                                        <option value="2" selected>2</option>
                                        <option value="3">3</option>
                                        <option value="4">4</option>
                                        <option value="6">6</option>
                                        <option value="8">8</option>
                                        <option value="16">16</option>
                                    </select>
                                </div>
                                <div class="input-group horizontal">
                                    <label for="snrInput">SNR (dB):</label>
                                    <input type="number" class="form-control" id="snrInput" value="10" min="0" max="40" step="1">
                                </div>
                                
                                <button class="btn btn-primary w-100 mt-3" id="simulateBtn" onclick="runSimulation()">Simulate Channel</button>
                                <button class="btn btn-secondary w-100 mt-3" id="regenerateBtn" onclick="runSimulation()" style="display:none;">Run with New Symbols</button>

                                <div class="technique-selector" id="techniqueSelector" style="display: none;">
                                    <h5>Equalizer Type:</h5>
                                    <div class="technique-options">
                                        <div class="technique-option">
                                            <input type="radio" id="zf" name="technique" value="ZF" checked onchange="updateDisplay()">
                                            <label for="zf">ZF</label>
                                        </div>
                                        <div class="technique-option">
                                            <input type="radio" id="mmse" name="technique" value="MMSE" onchange="updateDisplay()">
                                            <label for="mmse">MMSE</label>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="col-xl-6 col-lg-8 col-md-12">
                            <div class="visualization-area">
                                <div id="loadingIndicator" class="loading"><div class="spinner"></div><p>Processing...</p></div>
                                <div class="signal-flow" id="signalFlow">
                                    </div>
                            </div>
                        </div>

                        <div class="col-xl-3 col-lg-12 col-md-12">
                            <div class="output-panel" id="resultsContainer" style="display: none;">
                                <div class="results-panel">
                                    <h4>Performance</h4>
                                    <div class="metric-card"><div class="metric-label">Symbol Error Rate (SER)</div><div class="metric-value" id="serValue">-</div></div>
                                    <div class="metric-card"><div class="metric-label">Symbols in Error</div><div class="metric-value" id="errorCount">-</div></div>
                                    <div class="metric-card"><div class="metric-label">Channel Condition</div><div class="metric-value" id="conditionNumber">-</div></div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="row mt-4">
                        <div class="col-12" id="constellationSection" style="display: none;">
                            <div class="constellation-container">
                                <div class="constellation-plot"><h5>Original Transmitted</h5><canvas id="originalConstellation"></canvas></div>
                                <div class="constellation-plot"><h5>Channel Distorted + Noise</h5><canvas id="distortedConstellation"></canvas></div>
                                <div class="constellation-plot" id="equalizedPlot"><h5>Equalized (ZF)</h5><canvas id="equalizedConstellation"></canvas></div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="tab-pane fade" id="performance" role="tabpanel">
                    <div class="instructions-card">
                        <h3>Performance Analysis</h3>
                        <p>This chart shows the theoretical Symbol Error Rate (SER) versus the Signal-to-Noise Ratio (SNR) for the selected modulation scheme and MIMO configuration. It compares the performance of Zero-Forcing (ZF) and Minimum Mean Square Error (MMSE) equalizers across different noise levels.</p>
                    </div>

                    <div class="row mt-4">
                        <div class="col-12">
                            <div class="chart-container" id="serChartContainer" >
                                <div id="chartLoadingIndicator" class="loading" style="display:flex;"><div class="spinner"></div><p>Calculating SER vs SNR curve...</p></div>
                                <h4>Symbol Error Rate vs. SNR</h4>
                                <canvas id="serChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // --- GLOBAL STATE ---
        let originalSymbolIndices = [], modulatedSymbols = [], currentModulation = 'QPSK';
        let zfResults = null, mmseResults = null, serChart = null, constellationCharts = {};
        let distortedSymbols = [], currentNt = 2, currentNr = 2;

        // --- COMPLEX NUMBER CLASS ---
        class Complex {constructor(r,i=0){this.real=r;this.imag=i}add(o){return new Complex(this.real+o.real,this.imag+o.imag)}subtract(o){return new Complex(this.real-o.real,this.imag-o.imag)}multiply(o){if(typeof o==='number')return new Complex(this.real*o,this.imag*o);return new Complex(this.real*o.real-this.imag*o.imag,this.real*o.imag+this.imag*o.real)}divide(o){const d=o.real*o.real+o.imag*o.imag;if(d===0)return new Complex(Infinity,Infinity);return new Complex((this.real*o.real+this.imag*o.imag)/d,(this.imag*o.real-this.real*o.imag)/d)}conjugate(){return new Complex(this.real,-this.imag)}magnitudeSq(){return this.real*this.real+this.imag*this.imag}toString(p=2){return`${this.real.toFixed(p)}${this.imag>=0?'+':''}${this.imag.toFixed(p)}j`}}

        // --- MODULATION CONSTANTS ---
        const constellations={BPSK:[new Complex(-1,0),new Complex(1,0)],QPSK:[new Complex(1,1),new Complex(-1,1),new Complex(-1,-1),new Complex(1,-1)].map(c=>c.multiply(1/Math.sqrt(2))),'16QAM':(()=>{const p=[];for(let i of[-3,-1,1,3])for(let q of[-3,-1,1,3])p.push(new Complex(i,q));return p.map(c=>c.multiply(1/Math.sqrt(10)))})(),'64QAM':(()=>{const p=[];for(let i of[-7,-5,-3,-1,1,3,5,7])for(let q of[-7,-5,-3,-1,1,3,5,7])p.push(new Complex(i,q));return p.map(c=>c.multiply(1/Math.sqrt(42)))})()};

        // --- UI & CONTROL FUNCTIONS ---
        document.addEventListener('DOMContentLoaded',() => {
            calculateSERvsSNR();
            resetSignalFlow();
        });

        function generateRandomSymbols(){
            currentModulation = document.getElementById('modulationScheme').value;
            currentNt = parseInt(document.getElementById('numTxAntennas').value);
            currentNr = parseInt(document.getElementById('numRxAntennas').value);
            const constPoints = constellations[currentModulation];
            originalSymbolIndices = [];
            modulatedSymbols = [];
            for (let i = 0; i < currentNt; i++) {
                const idx = Math.floor(Math.random() * constPoints.length);
                originalSymbolIndices.push(idx);
                modulatedSymbols.push(constPoints[idx]);
            }
        }

        async function runSimulation() {
            document.getElementById('loadingIndicator').style.display = 'flex';
            document.getElementById('simulateBtn').disabled = true;
            document.getElementById('regenerateBtn').disabled = true;
            await new Promise(r => setTimeout(r, 50));

            generateRandomSymbols();
            const Nt = currentNt;
            const Nr = currentNr;

            const snr_dB = parseFloat(document.getElementById('snrInput').value);
            const constPoints = constellations[currentModulation];
            const E_avg = constPoints.reduce((s, v) => s + v.magnitudeSq(), 0) / constPoints.length;
            const noiseVariance = E_avg / (10 ** (snr_dB / 10));

            // Generate Nr x Nt channel matrix
            const H = generateComplexChannel(Nr, Nt);
            const receivedSymbols = multiplyMatrixVector(H, modulatedSymbols);
            const noise = Array.from({length: Nr}, () => generateComplexGaussian().multiply(Math.sqrt(noiseVariance)));
            const noisyReceivedSymbols = receivedSymbols.map((s, i) => s.add(noise[i]));

            // Store distorted symbols (before adding noise) for visualization
            distortedSymbols = receivedSymbols.slice();

            // Calculate condition number for channel quality assessment
            const condNum = calculateConditionNumber(H);

            let zf_eq, mmse_eq;
            let zf_demod, mmse_demod;

            // Replace the MMSE equalizer sections in runSimulation() function

            // In runSimulation() - replace the MMSE calculation parts:

            if (Nr >= Nt) {
                // Overdetermined or square system - use pseudoinverse
                const H_H = transposeConjugateMatrix(H);
                const H_H_H = multiplyComplexMatrices(H_H, H);
                const H_inv = invertMatrix(H_H_H);
                const W_zf = H_inv ? multiplyComplexMatrices(H_inv, H_H) : null;

                // MMSE equalizer - Fixed noise variance scaling
                const I = identityMatrix(Nt);
                const noiseTerm = multiplyMatrixScalar(I, noiseVariance / E_avg); // Normalize by signal power
                const mmse_inv = invertMatrix(addMatrices(H_H_H, noiseTerm));
                const W_mmse = mmse_inv ? multiplyComplexMatrices(mmse_inv, H_H) : null;

                zf_eq = W_zf ? multiplyMatrixVector(W_zf, noisyReceivedSymbols) : Array(Nt).fill(new Complex(0,0));
                mmse_eq = W_mmse ? multiplyMatrixVector(W_mmse, noisyReceivedSymbols) : Array(Nt).fill(new Complex(0,0));
            } else {
                // Underdetermined system - use left pseudoinverse
                const H_H = transposeConjugateMatrix(H);
                const H_H_H = multiplyComplexMatrices(H, H_H);
                const H_inv = invertMatrix(H_H_H);
                const W_zf = H_inv ? multiplyComplexMatrices(H_H, H_inv) : null;

                // MMSE for underdetermined - Fixed implementation
                const I = identityMatrix(Nr);
                const noiseTerm = multiplyMatrixScalar(I, noiseVariance / E_avg); // Normalize by signal power
                const mmse_inv = invertMatrix(addMatrices(H_H_H, noiseTerm));
                const W_mmse = mmse_inv ? multiplyComplexMatrices(H_H, mmse_inv) : null;

                zf_eq = W_zf ? multiplyMatrixVector(W_zf, noisyReceivedSymbols) : Array(Nt).fill(new Complex(0,0));
                mmse_eq = W_mmse ? multiplyMatrixVector(W_mmse, noisyReceivedSymbols) : Array(Nt).fill(new Complex(0,0));
            }

            zf_demod = demodulate(zf_eq, currentModulation);
            mmse_demod = demodulate(mmse_eq, currentModulation);

            zfResults = { equalized: zf_eq, ser: calculateSER(originalSymbolIndices, zf_demod.indices), errors: zf_demod.indices.filter((s, i) => s !== originalSymbolIndices[i]).length, conditionNumber: condNum };
            mmseResults = { equalized: mmse_eq, ser: calculateSER(originalSymbolIndices, mmse_demod.indices), errors: mmse_demod.indices.filter((s, i) => s !== originalSymbolIndices[i]).length, conditionNumber: condNum };

            document.getElementById('techniqueSelector').style.display = 'block';
            document.getElementById('resultsContainer').style.display = 'block';
            document.getElementById('constellationSection').style.display = 'block';
            document.getElementById('simulateBtn').style.display = 'none';
            document.getElementById('regenerateBtn').style.display = 'block';

            updateSignalFlow(H, noisyReceivedSymbols);
            updateDisplay();
            updateConstellationPlots();

            document.getElementById('loadingIndicator').style.display = 'none';
            document.getElementById('simulateBtn').disabled = false;
            document.getElementById('regenerateBtn').disabled = false;
        }

        function updateDisplay() {
            const t = document.querySelector('input[name="technique"]:checked').value;
            const r = (t === 'ZF') ? zfResults : mmseResults;
            if (!r) return;

            document.getElementById('serValue').innerText = r.ser.toFixed(3);
            document.getElementById('errorCount').innerText = `${r.errors} / ${originalSymbolIndices.length}`;
            document.getElementById('conditionNumber').innerText = r.conditionNumber.toFixed(2);

            // Update equalized plot title
            const equalizedPlot = document.getElementById('equalizedPlot');
            if (equalizedPlot) {
                equalizedPlot.querySelector('h5').innerText = `Equalized (${t})`;
            }

            const eqBlock = document.getElementById('flow-equalized');
            if (eqBlock) {
                eqBlock.innerHTML = `<h4>${t} Equalized (x̂)</h4><div class="signal-value">${r.equalized.map(s => s.toString(2)).join('<br>')}</div>`;
            }

            // Update constellation plot
            updateConstellationPlots();
        }

        function updateSignalFlow(channelMatrix, noisyReceivedSymbols) {
            const Nt = currentNt;
            const Nr = currentNr;
            document.getElementById('signalFlow').innerHTML = `
                <div class="signal-block"><h4>Transmitted (x)</h4><div class="signal-value">${modulatedSymbols.map(s => s.toString(2)).join('<br>')}<br><small>${Nt} streams</small></div></div>
                <div class="arrow">→</div>
                <div class="signal-block"><h4>Channel (H)</h4><div class="signal-value">${Nr}×${Nt} MIMO<br><small>Rayleigh fading</small></div></div>
                <div class="arrow">→</div>
                <div class="noise-adder">
                    <div class="noise-adder-circle">+</div>
                    <div class="noise-adder-label">AWGN</div>
                </div>
                <div class="arrow">→</div>
                <div class="signal-block"><h4>Received (y)</h4><div class="signal-value">${noisyReceivedSymbols.map(s => s.toString(2)).join('<br>')}<br><small>${Nr} antennas</small></div></div>
                <div class="arrow">→</div>
                <div class="signal-block" id="flow-equalized"></div>
            `;
            updateDisplay();
        }

        function resetSignalFlow(){document.getElementById('signalFlow').innerHTML='<div class="signal-block" style="width:100%"><h4>MIMO Simulation Flow</h4><div class="signal-value" style="text-align:center; padding-top:20px;">Configure MIMO parameters and click "Simulate Channel" to begin.</div></div>'}

        // --- CORE LOGIC & MATH ---
        function generateComplexGaussian(){const u1=Math.random(),u2=Math.random();return new Complex(Math.sqrt(-2*Math.log(u1))*Math.cos(2*Math.PI*u2)/Math.sqrt(2),Math.sqrt(-2*Math.log(u1))*Math.sin(2*Math.PI*u2)/Math.sqrt(2))}

        function generateComplexChannel(Nr, Nt){
            return Array.from({length:Nr},()=>Array.from({length:Nt},()=>generateComplexGaussian()))
        }

        function demodulate(r,m){const c=constellations[m];if(!r||r.length===0||!c)return{indices:[],symbols:[]};const i=r.map(s=>{let best=0,min=Infinity;for(let j=0;j<c.length;j++){const d=s.subtract(c[j]).magnitudeSq();if(d<min){min=d;best=j;}}return best;});return{indices:i,symbols:i.map(j=>c[j])}}

        function calculateSER(o,r){if(o.length!==r.length||o.length===0)return 0;return o.reduce((a,v,i)=>a+(v!==r[i]?1:0),0)/o.length}

        function calculateConditionNumber(H) {
            // Simplified condition number estimation using Frobenius norms
            const H_H = transposeConjugateMatrix(H);
            const HHH = multiplyComplexMatrices(H_H, H);

            // Calculate trace (sum of diagonal elements) as approximation
            let trace = 0;
            let minDiag = Infinity;
            for (let i = 0; i < Math.min(HHH.length, HHH[0].length); i++) {
                const diagVal = HHH[i][i].magnitudeSq();
                trace += Math.sqrt(diagVal);
                if (Math.sqrt(diagVal) < minDiag) minDiag = Math.sqrt(diagVal);
            }

            return minDiag > 0 ? trace / (HHH.length * minDiag) : Infinity;
        }

        // --- COMPLEX MATRIX ALGEBRA ---
        function multiplyMatrixVector(m,v){return m.map(r=>r.reduce((a,c,j)=>a.add(c.multiply(v[j])),new Complex(0,0)))}
        function multiplyComplexMatrices(A,B){const C=Array(A.length).fill(0).map(()=>Array(B[0].length).fill(new Complex(0,0)));for(let i=0;i<A.length;i++)for(let j=0;j<B[0].length;j++)for(let k=0;k<A[0].length;k++)C[i][j]=C[i][j].add(A[i][k].multiply(B[k][j]));return C}
        function transposeConjugateMatrix(m){const r=Array(m[0].length).fill(0).map(()=>Array(m.length));for(let i=0;i<m.length;i++)for(let j=0;j<m[0].length;j++)r[j][i]=m[i][j].conjugate();return r}
        function addMatrices(A,B){return A.map((r,i)=>r.map((v,j)=>v.add(B[i][j])))}
        function multiplyMatrixScalar(m,s){return m.map(r=>r.map(v=>v.multiply(s)))}
        function identityMatrix(s){const I=Array(s).fill(0).map(()=>Array(s).fill(new Complex(0,0)));for(let i=0;i<s;i++)I[i][i]=new Complex(1,0);return I}
        function invertMatrix(m){const n=m.length;if(n===0) return [];const A=m.map((r,i)=>[...r.map(c=>new Complex(c.real,c.imag)),...identityMatrix(n)[i]]);for(let i=0;i<n;i++){let p=i;while(p<n&&A[p][i].magnitudeSq()<1e-12)p++;if(p===n)return null;[A[i],A[p]]=[A[p],A[i]];let d=A[i][i];for(let j=i;j<2*n;j++)A[i][j]=A[i][j].divide(d);for(let k=0;k<n;k++)if(i!==k){let M=A[k][i];for(let j=i;j<2*n;j++)A[k][j]=A[k][j].subtract(M.multiply(A[i][j]));}}return A.map(r=>r.slice(n))}

        // --- CHARTING FUNCTIONS ---
        async function calculateSERvsSNR() {
            document.getElementById('chartLoadingIndicator').style.display = 'flex';
            await new Promise(r => setTimeout(r, 50));
            const T = 100; // Reduced trials for faster computation
            const Nt = parseInt(document.getElementById('numTxAntennas').value);
            const Nr = parseInt(document.getElementById('numRxAntennas').value);
            const snr_dB = Array.from({length: 11}, (_, i) => i * 2);
            const mod = document.getElementById('modulationScheme').value;
            const c = constellations[mod];
            const E_avg = c.reduce((s, v) => s + v.magnitudeSq(), 0) / c.length;

            let zf_d = [], mmse_d = [];
            for (const db of snr_dB) {
                const N0 = E_avg / (10 ** (db / 10));
                let zf_e = 0, mmse_e = 0, total_s = 0;
                for (let t = 0; t < T; t++) {
                    const H = generateComplexChannel(Nr, Nt);
                    const o = Array.from({ length: Nt }, () => Math.floor(Math.random() * c.length));
                    const m = o.map(i => c[i]);
                    const r = multiplyMatrixVector(H, m);
                    const noise = Array.from({ length: Nr }, () => generateComplexGaussian().multiply(Math.sqrt(N0)));
                    const y = r.map((s, i) => s.add(noise[i]));

                    // ZF equalizer
                    let zf_eq;
                    if (Nr >= Nt) {
                        const H_H = transposeConjugateMatrix(H);
                        const H_H_H = multiplyComplexMatrices(H_H, H);
                        const H_inv = invertMatrix(H_H_H);
                        const W_zf = H_inv ? multiplyComplexMatrices(H_inv, H_H) : null;
                        zf_eq = W_zf ? multiplyMatrixVector(W_zf, y) : Array(Nt).fill(new Complex(0,0));
                    } else {
                        const H_H = transposeConjugateMatrix(H);
                        const H_H_H = multiplyComplexMatrices(H, H_H);
                        const H_inv = invertMatrix(H_H_H);
                        const W_zf = H_inv ? multiplyComplexMatrices(H_H, H_inv) : null;
                        zf_eq = W_zf ? multiplyMatrixVector(W_zf, y) : Array(Nt).fill(new Complex(0,0));
                    }

                    // MMSE equalizer
                    // Replace the MMSE equalizer section in calculateSERvsSNR() function

                    // In calculateSERvsSNR() - replace the MMSE equalizer calculation:

                    // MMSE equalizer - Fixed implementation
                    let mmse_eq;
                    if (Nr >= Nt) {
                        const H_H = transposeConjugateMatrix(H);
                        const H_H_H = multiplyComplexMatrices(H_H, H);
                        const I = identityMatrix(Nt);
                        const noiseTerm = multiplyMatrixScalar(I, N0 / E_avg); // Normalize by signal power
                        const mmse_inv = invertMatrix(addMatrices(H_H_H, noiseTerm));
                        const W_mmse = mmse_inv ? multiplyComplexMatrices(mmse_inv, H_H) : null;
                        mmse_eq = W_mmse ? multiplyMatrixVector(W_mmse, y) : Array(Nt).fill(new Complex(0,0));
                    } else {
                        const H_H = transposeConjugateMatrix(H);
                        const H_H_H = multiplyComplexMatrices(H, H_H);
                        const I = identityMatrix(Nr);
                        const noiseTerm = multiplyMatrixScalar(I, N0 / E_avg); // Normalize by signal power
                        const mmse_inv = invertMatrix(addMatrices(H_H_H, noiseTerm));
                        const W_mmse = mmse_inv ? multiplyComplexMatrices(H_H, mmse_inv) : null;
                        mmse_eq = W_mmse ? multiplyMatrixVector(W_mmse, y) : Array(Nt).fill(new Complex(0,0));
                    }

                    zf_e += calculateSER(o, demodulate(zf_eq, mod).indices) * Nt;
                    mmse_e += calculateSER(o, demodulate(mmse_eq, mod).indices) * Nt;
                    total_s += Nt;
                }
                zf_d.push(total_s > 0 ? zf_e / total_s : 1);
                mmse_d.push(total_s > 0 ? mmse_e / total_s : 1);
            }
            plotSERChart(snr_dB, zf_d, mmse_d, mod, Nt, Nr);
            document.getElementById('chartLoadingIndicator').style.display = 'none';
        }

        // Replace the plotSERChart function with this fixed version

        function plotSERChart(labels, zfData, mmseData, mod, Nt, Nr) {
            if (serChart) serChart.destroy();
            const ctx = document.getElementById('serChart').getContext('2d');
            serChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels,
                    datasets: [{
                        label: 'ZF SER',
                        data: zfData,
                        borderColor: '#e74c3c',
                        backgroundColor: '#e74c3c',
                        fill: false,
                        tension: 0.1
                    }, {
                        label: 'MMSE SER',
                        data: mmseData,
                        borderColor: '#3498db',
                        backgroundColor: '#3498db',
                        fill: false,
                        tension: 0.1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false, // This allows the chart to fill the container
                    aspectRatio: 2, // Width to height ratio
                    layout: {
                        padding: 10
                    },
                    scales: {
                        y: {
                            type: 'logarithmic',
                            title: {
                                display: true,
                                text: 'Symbol Error Rate (SER)'
                            },
                            min: 1e-4,
                            max: 1,
                            ticks: {
                                callback: function(v) {
                                    return v.toExponential(1);
                                },
                                color: '#555'
                            },
                            grid: {
                                color: 'rgba(0,0,0,0.1)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'SNR (dB)'
                            },
                            grid: {
                                color: 'rgba(0,0,0,0.1)'
                            },
                            ticks: {
                                color: '#555'
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: `SER Performance for ${mod} (${Nt}×${Nr} MIMO)`,
                            font: {
                                size: 16
                            }
                        },
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    }
                }
            });
        }
        function updateConstellationPlots() {
            const p = constellations[currentModulation];
            const selectedTechnique = document.querySelector('input[name="technique"]:checked').value;
            const results = (selectedTechnique === 'ZF') ? zfResults : mmseResults;

            if (!p || !results) return;

            const axisLimit = Math.max(
                ...results.equalized.flatMap(pt=>[Math.abs(pt.real),Math.abs(pt.imag)]),
                ...distortedSymbols.flatMap(pt=>[Math.abs(pt.real),Math.abs(pt.imag)]),
                ...p.flatMap(pt=>[Math.abs(pt.real),Math.abs(pt.imag)]),
                0.5
            ) * 1.2;

            plotConstellation('originalConstellation', modulatedSymbols, p);
            plotConstellation('distortedConstellation', distortedSymbols, p, axisLimit);
            plotConstellation('equalizedConstellation', results.equalized, p, axisLimit);
        }

        function resetConstellationPlots(){Object.values(constellationCharts).forEach(c=>c.destroy());constellationCharts={};['originalConstellation','distortedConstellation','equalizedConstellation'].forEach(id=>{const el=document.getElementById(id);if(el)el.getContext('2d').clearRect(0,0,el.width,el.height)})}

        function plotConstellation(id, data, ideal, axisLimit = null) {
            const canvas = document.getElementById(id);
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            if (constellationCharts[id]) constellationCharts[id].destroy();
            const dataPts = data ? data.map(p => ({ x: p.real, y: p.imag })) : [];
            const idealPts = ideal ? ideal.map(p => ({ x: p.real, y: p.imag })) : [];
            const maxVal = axisLimit ? axisLimit : Math.max(...dataPts.flatMap(p=>[Math.abs(p.x),Math.abs(p.y)]),...idealPts.flatMap(p=>[Math.abs(p.x),Math.abs(p.y)]),0.5) * 1.2;
            constellationCharts[id] = new Chart(ctx, {type:'scatter',data:{datasets:[{label:'Ideal',data:idealPts,backgroundColor:'rgba(231,76,60,0.9)',pointRadius:7,pointStyle:'crossRot',borderWidth:2},{label:'Signal',data:dataPts,backgroundColor:'rgba(13,110,253,0.7)',pointRadius:6}]},options:{responsive:true,maintainAspectRatio:true,aspectRatio:1,scales:{x:{title:{display:true,text:'In-Phase(I)'},min:-maxVal,max:maxVal,grid:{color:c=>c.tick.value===0?'rgba(0,0,0,0.6)':'rgba(0,0,0,0.1)',lineWidth:c=>c.tick.value===0?2:1},ticks:{color:'#555'}},y:{title:{display:true,text:'Quadrature(Q)'},min:-maxVal,max:maxVal,grid:{color:c=>c.tick.value===0?'rgba(0,0,0,0.6)':'rgba(0,0,0,0.1)',lineWidth:c=>c.tick.value===0?2:1},ticks:{color:'#555'}}},plugins:{legend:{display:false}}}});
        }

        // Update performance chart when MIMO configuration changes
        document.getElementById('numTxAntennas').addEventListener('change', calculateSERvsSNR);
        document.getElementById('numRxAntennas').addEventListener('change', calculateSERvsSNR);
        document.getElementById('modulationScheme').addEventListener('change', calculateSERvsSNR);
    </script>
</body>
</html>