<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ZF vs MMSE Equalizer Experiment</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f9fafb; /* bg-gray-50 */
            color: #374151; /* text-gray-700 (default) */
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align to top for long content */
            padding: 1.5rem; /* p-6 equivalent for body */
            box-sizing: border-box;
        }

        .container {
            width: 100%;
            max-width: 1120px; /* max-w-7xl */
            background-color: #ffffff; /* bg-white */
            border-radius: 0.5rem; /* rounded-lg */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* shadow-lg */
            padding: 1.5rem; /* p-6 */
            margin-bottom: 1.5rem; /* mb-6 */
        }

        h1 {
            font-size: 1.875rem; /* text-3xl */
            font-weight: 700; /* font-bold */
            color: #1f2937; /* text-gray-800 */
            margin-bottom: 0.5rem; /* mb-2 */
        }

        .description {
            color: #4b5563; /* text-gray-600 */
            margin-bottom: 1rem; /* mb-4 */
        }

        .control-panel {
            background-color: #eff6ff; /* bg-blue-50 */
            border-radius: 0.5rem; /* rounded-lg */
            padding: 1rem; /* p-4 */
            margin-bottom: 1.5rem; /* mb-6 */
        }

        .control-panel h2 {
            font-size: 1.25rem; /* text-xl */
            font-weight: 600; /* font-semibold */
            margin-bottom: 1rem; /* mb-4 */
            display: flex;
            align-items: center;
            gap: 0.5rem; /* gap-2 */
        }

        .grid {
            display: grid;
            gap: 1rem; /* gap-4 */
            margin-bottom: 1rem; /* mb-4 */
        }

        .grid-cols-1 { grid-template-columns: repeat(1, minmax(0, 1fr)); }
        
        @media (min-width: 768px) { /* md: */
            .md-grid-cols-3 { grid-template-columns: repeat(3, minmax(0, 1fr)); }
            .md-grid-cols-2 { grid-template-columns: repeat(2, minmax(0, 1fr)); }
        }
        
        @media (min-width: 1024px) { /* lg: */
            .lg-grid-cols-2 { grid-template-columns: repeat(2, minmax(0, 1fr)); }
        }


        label {
            display: block;
            font-size: 0.875rem; /* text-sm */
            font-weight: 500; /* font-medium */
            margin-bottom: 0.5rem; /* mb-2 */
        }

        input[type="text"],
        input[type="number"],
        select {
            width: 100%;
            padding: 0.5rem; /* p-2 */
            border: 1px solid #d1d5db; /* border */
            border-radius: 0.25rem; /* rounded */
            box-sizing: border-box;
        }
        
        input[type="number"]:disabled {
            background-color: #e5e7eb;
            cursor: not-allowed;
        }


        .button-group {
            display: flex;
            gap: 0.75rem; /* gap-3 */
        }

        button {
            display: flex;
            align-items: center;
            gap: 0.5rem; /* gap-2 */
            padding: 0.5rem 1rem; /* px-4 py-2 */
            border-radius: 0.25rem; /* rounded */
            font-weight: 500; /* font-medium */
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .btn-start {
            background-color: #22c55e; /* bg-green-500 */
        }
        .btn-start:hover {
            background-color: #16a34a; /* hover:bg-green-600 */
        }
        .btn-pause {
            background-color: #ef4444; /* bg-red-500 */
        }
        .btn-pause:hover {
            background-color: #dc2626; /* hover:bg-red-600 */
        }
        .btn-reset {
            background-color: #6b7280; /* bg-gray-500 */
        }
        .btn-reset:hover {
            background-color: #4b5563; /* hover:bg-gray-600 */
        }

        .status-bar {
            margin-top: 1rem; /* mt-4 */
            padding: 0.75rem; /* p-3 */
            background-color: #dbeafe; /* bg-blue-100 */
            border-radius: 0.25rem; /* rounded */
            font-size: 0.875rem; /* text-sm */
        }

        .chart-container, .constellation-container-outer {
            background-color: #ffffff; /* bg-white */
            border: 1px solid #e5e7eb; /* border */
            border-radius: 0.5rem; /* rounded-lg */
            padding: 1rem; /* p-4 */
        }
        
        .chart-container h3, .constellation-container-outer h3 {
            font-size: 1.125rem; /* text-lg */
            font-weight: 600; /* font-semibold */
            margin-bottom: 0.75rem; /* mb-3 */
        }
        
        .chart-area {
            height: 20rem; /* h-80 */
        }
        .constellation-grid {
            display: grid;
            grid-template-columns: 1fr; /* default for small screens */
            gap: 1rem;
        }
        .constellation-plot-area {
            height: 8rem; /* h-32 */
        }
        .constellation-plot-area h4 {
            font-size: 0.875rem; /* text-sm */
            font-weight: 500; /* font-medium */
            margin-bottom: 0.25rem; /* mb-1 */
            text-transform: capitalize;
        }

        .theory-summary {
            margin-top: 1.5rem; /* mt-6 */
            background-color: #fefce8; /* bg-yellow-50 */
            border: 1px solid #fde68a; /* border-yellow-200 */
            border-radius: 0.5rem; /* rounded-lg */
            padding: 1rem; /* p-4 */
        }
        .theory-summary h3 {
            font-size: 1.125rem; /* text-lg */
            font-weight: 600; /* font-semibold */
            margin-bottom: 0.5rem; /* mb-2 */
            display: flex;
            align-items: center;
            gap: 0.5rem; /* gap-2 */
        }
        .theory-summary p {
            font-size: 0.875rem; /* text-sm */
            margin-bottom: 0.5rem; /* space-y-2 */
        }
        .theory-summary p:last-child {
            margin-bottom: 0;
        }

        .icon {
            width: 1em;
            height: 1em;
            vertical-align: -0.125em;
            fill: currentColor;
        }
        .input-note {
            font-size: 0.75rem;
            color: #4b5563;
            margin-top: 0.25rem;
        }

    </style>
</head>
<body>
    <div class="container">
        <h1>Virtual Lab: ZF vs MMSE Equalizer Performance</h1>
        <p class="description">Compare Zero Forcing and MMSE equalizers in frequency-selective fading channels</p>

        <div class="control-panel">
            <h2>
                <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 .25 1l-.08.15a2 2 0 0 1 0 2l-.25.43a2 2 0 0 1-1.73 1L2 12.22v.44a2 2 0 0 0 2 2h.18a2 2 0 0 1 1.73 1l.25.43a2 2 0 0 1 0 2l-.08.15a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.38a2 2 0 0 0-.73-2.73l-.15-.1a2 2 0 0 1-.25-1l.08-.15a2 2 0 0 1 0-2l.25-.43a2 2 0 0 1 1.73-1L22 11.78v-.44a2 2 0 0 0-2-2h-.18a2 2 0 0 1-1.73-1l-.25-.43a2 2 0 0 1 0-2l.08-.15a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg>
                Experiment Parameters
            </h2>
            <div class="grid md-grid-cols-3">
                <div>
                    <label for="modulation">Modulation Scheme</label>
                    <select id="modulation">
                        <option value="BPSK">BPSK</option>
                        <option value="QPSK" selected>QPSK</option>
                        <option value="16QAM">16-QAM</option>
                    </select>
                </div>
                <div>
                    <label for="numSymbols">Number of Symbols</label>
                    <input type="number" id="numSymbols" value="1000" min="100" max="5000" step="100">
                </div>
                <div>
                    <label for="channelTapsInput">Channel Taps</label>
                    <input type="number" id="channelTapsInput" value="3" min="1" max="5">
                </div>
            </div>
            <div class="grid md-grid-cols-2">
                <div>
                    <label for="channelCoeffsInput">Channel Coefficients (comma-separated)</label>
                    <input type="text" id="channelCoeffsInput" value="0.3, 0.7, 0.2" placeholder="e.g., 0.3, 0.7, 0.2">
                </div>
                <div>
                    <label for="noiseVarianceInput">MMSE Noise Variance Est. (UI only)</label>
                    <input type="number" id="noiseVarianceInput" value="0.1" min="0.01" max="1" step="0.01" disabled>
                    <p class="input-note">Note: For BER curve, MMSE uses adaptive noise based on current SNR.</p>
                </div>
            </div>
            <div class="button-group">
                <button id="startPauseButton" class="btn-start">
                    <svg id="playIcon" class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"/></svg>
                    <svg id="pauseIcon" class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display:none;"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>
                    <span id="startPauseText">Start Simulation</span>
                </button>
                <button id="resetButton" class="btn-reset">
                    <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 2c2.1 0 3.8.8 4.8 2.2A5.5 5.5 0 0 1 12 5.5V8H6.5A3.5 3.5 0 0 0 3 11.5V18a3 3 0 0 0 3 3h12a3 3 0 0 0 3-3v-6.5A3.5 3.5 0 0 0 17.5 8H12V5.4A5.5 5.5 0 0 1 16.2 3C17.3 1.3 19 1 21 2"/><path d="M21 10v4.5a3.5 3.5 0 0 1-3.5 3.5H6.5A3.5 3.5 0 0 1 3 14.5V10"/></svg>
                    Reset
                </button>
            </div>
            <div class="status-bar">
                <p>
                    <strong>Current SNR:</strong> <span id="currentSNRDisplay">-10</span> dB |
                    <strong>Status:</strong> <span id="statusDisplay">Stopped</span> |
                    <strong>Progress:</strong> <span id="progressDisplay">0/31</span> points
                </p>
            </div>
        </div>

        <div class="grid lg-grid-cols-2">
            <div class="chart-container">
                <h3>Bit Error Rate vs SNR</h3>
                <div class="chart-area">
                    <canvas id="berChart"></canvas>
                </div>
            </div>
            <div class="constellation-container-outer">
                <h3>Constellation Diagrams (SNR: <span id="constellationSNRDisplay">-10</span> dB)</h3>
                <div class="constellation-grid">
                    <div class="constellation-plot-area">
                        <h4>Transmitted</h4>
                        <canvas id="transmittedConstellationChart"></canvas>
                    </div>
                    <div class="constellation-plot-area">
                        <h4>ZF Received Equalized</h4>
                        <canvas id="zfConstellationChart"></canvas>
                    </div>
                    <div class="constellation-plot-area">
                        <h4>MMSE Received Equalized</h4>
                        <canvas id="mmseConstellationChart"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <div class="theory-summary">
            <h3>
                <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" y1="16" x2="12" y2="12"/><line x1="12" y1="8" x2="12.01" y2="8"/></svg>
                Key Observations
            </h3>
            <p><strong>Zero Forcing (ZF):</strong> Aims to completely invert the channel. Can significantly amplify noise if the channel has weak spots (low gain), especially at low SNR. These simplified single-tap equalizers primarily show noise amplification differences.</p>
            <p><strong>MMSE:</strong> Balances ISI suppression (less so with single-tap) and noise amplification by minimizing mean square error. Uses an estimate of noise power to avoid excessive noise gain. Generally provides better BER performance, particularly when ZF struggles with noise.</p>
            <p><strong>Trade-off:</strong> With more advanced multi-tap equalizers, ZF offers better ISI cancellation when noise is low, while MMSE offers better overall robustness by considering noise.</p>
        </div>
    </div>

    <script>
        // DOM Elements
        const modulationSelect = document.getElementById('modulation');
        const numSymbolsInput = document.getElementById('numSymbols');
        const channelTapsInput = document.getElementById('channelTapsInput');
        const channelCoeffsInput = document.getElementById('channelCoeffsInput');
        const noiseVarianceInput = document.getElementById('noiseVarianceInput'); // Kept for UI consistency, but not used by MMSE in loop
        const startPauseButton = document.getElementById('startPauseButton');
        const playIcon = document.getElementById('playIcon');
        const pauseIcon = document.getElementById('pauseIcon');
        const startPauseText = document.getElementById('startPauseText');
        const resetButton = document.getElementById('resetButton');
        const currentSNRDisplay = document.getElementById('currentSNRDisplay');
        const statusDisplay = document.getElementById('statusDisplay');
        const progressDisplay = document.getElementById('progressDisplay');
        const constellationSNRDisplay = document.getElementById('constellationSNRDisplay');

        // Simulation Parameters
        let params = {
            snrRange: [-10, 20],
            numSymbols: 1000,
            modulation: 'QPSK',
        };
        
        // Simulation State
        let isRunning = false;
        let currentSNR = -10;
        let results = [];
        let constellations = {
            transmitted: [],
            zf_received: [],
            mmse_received: []
        };
        
        // Channel and noise parameters
        let channelCoeffs = [0.3, 0.7, 0.2]; // MODIFIED: Default to a channel that can show differences
        let uiNoiseVariance = 0.1; // Value from UI, not used by MMSE in BER curve calculation anymore

        let simulationInterval;

        // Chart.js instances
        let berChartInstance, transmittedConstellationChartInstance, zfConstellationChartInstance, mmseConstellationChartInstance;

        const generateConstellation = (modType, numSymbolsVal) => {
            const symbols = [];
            let normFactor = 1;
            if (modType === 'QPSK') normFactor = 1 / Math.sqrt(2);
            else if (modType === '16QAM') normFactor = 1 / Math.sqrt(10); // Avg power of 16QAM with levels -3,-1,1,3 is 10

            switch(modType) {
                case 'BPSK':
                    for(let i = 0; i < numSymbolsVal; i++) {
                        symbols.push({ real: Math.random() > 0.5 ? 1 : -1, imag: 0 });
                    }
                    break;
                case 'QPSK':
                    for(let i = 0; i < numSymbolsVal; i++) {
                        const bits = Math.floor(Math.random() * 4);
                        symbols.push({ real: (bits < 2 ? 1 : -1) * normFactor, imag: ((bits % 2) === 0 ? 1 : -1) * normFactor });
                    }
                    break;
                case '16QAM':
                    const qamLevels = [-3, -1, 1, 3];
                    for(let i = 0; i < numSymbolsVal; i++) {
                        symbols.push({
                            real: qamLevels[Math.floor(Math.random() * 4)] * normFactor,
                            imag: qamLevels[Math.floor(Math.random() * 4)] * normFactor
                        });
                    }
                    break;
            }
            return symbols.map((s, i) => ({ ...s, id: i }));
        };

        const applyChannel = (symbols, coeffs) => {
            const received = [];
            const M = coeffs.length; // Memory of the channel
            for(let i = 0; i < symbols.length; i++) {
                let realSum = 0, imagSum = 0;
                for(let j = 0; j < M; j++) {
                    if (i - j >= 0) { // Check if symbol exists
                        const h_j = coeffs[j]; // Assuming real channel coefficients
                        const s_i_minus_j = symbols[i-j];
                        realSum += s_i_minus_j.real * h_j;
                        imagSum += s_i_minus_j.imag * h_j;
                    }
                }
                // The ISI is now incorporated correctly. 
                // The original simplified applyChannel only convolved the current symbol with taps without summing past symbol contributions correctly for a given output sample.
                // This is still a FIR filter.
                received.push({ real: realSum, imag: imagSum, id: i });
            }
            return received;
        };
        
        function gaussianRandom(mean=0, stdev=1) {
            let u = 1 - Math.random(); 
            let v = Math.random();
            let z = Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );
            return z * stdev + mean;
        }

        const addNoiseGaussian = (symbols, snrDb) => {
            const snrLinear = Math.pow(10, snrDb / 10);
            // Assuming average transmitted symbol power Es = 1 (due to normalization in generateConstellation)
            // SNR = Es / N0 => N0 = Es / SNR = 1 / SNR (where N0 is total noise power for complex noise)
            const noisePowerN0 = 1 / snrLinear;
            // For complex AWGN, N0 is split equally between real and imag parts, so variance per dimension is N0/2.
            // Standard deviation is sqrt(variance).
            const noiseStd = Math.sqrt(noisePowerN0 / 2); 
            
            return symbols.map(s => ({
                ...s,
                real: s.real + gaussianRandom(0, noiseStd),
                imag: s.imag + gaussianRandom(0, noiseStd)
            }));
        };

        const zfEqualize = (received, channelCoeffsVal) => {
            const mainTapGain = channelCoeffsVal[0];
            if (Math.abs(mainTapGain) < 1e-9) { // Avoid division by zero/very small number
                // If main tap is effectively zero, ZF fails spectacularly.
                // Return a very noisy signal or zero to reflect this.
                return received.map(s => ({...s, real: s.real * 1e9, imag: s.imag * 1e9 })); // Amplify to show failure
            }
            const invGain = 1 / mainTapGain;
            
            return received.map(s => ({
                ...s,
                real: s.real * invGain,
                imag: s.imag * invGain
            }));
        };

        const mmseEqualize = (received, channelCoeffsVal, actualNoisePowerEstimate) => {
            // Simplified MMSE for a single tap dominant channel.
            const H1 = channelCoeffsVal[0]; // Main channel coefficient (assuming real)
            const H1MagSq = H1 * H1;
            
            // MMSE weight: H1* / (|H1|^2 + N0_estimate/Es)
            // Since Es (avg symbol energy) is normalized to 1, this is H1 / (H1^2 + N0_estimate)
            // actualNoisePowerEstimate is N0 (total noise power for complex)
            const mmseWeight = H1 / (H1MagSq + actualNoisePowerEstimate); 
            
            return received.map(s => ({
                ...s,
                real: s.real * mmseWeight,
                imag: s.imag * mmseWeight
            }));
        };
        
        const decideSymbol = (rxSymbol, modType) => {
            let decReal = 0;
            let decImag = 0;
            let normFactor = 1;

            if (modType === 'BPSK') {
                decReal = rxSymbol.real > 0 ? 1 : -1;
                decImag = 0;
            } else if (modType === 'QPSK') {
                normFactor = 1 / Math.sqrt(2);
                decReal = rxSymbol.real > 0 ? normFactor : -normFactor;
                decImag = rxSymbol.imag > 0 ? normFactor : -normFactor;
            } else if (modType === '16QAM') {
                normFactor = 1 / Math.sqrt(10);
                const levels = [-3, -1, 1, 3].map(v => v * normFactor);
                
                decReal = levels.reduce((prev, curr) => Math.abs(curr - rxSymbol.real) < Math.abs(prev - rxSymbol.real) ? curr : prev);
                decImag = levels.reduce((prev, curr) => Math.abs(curr - rxSymbol.imag) < Math.abs(prev - rxSymbol.imag) ? curr : prev);
            }
            return { real: decReal, imag: decImag };
        };

        const calculateBER = (transmitted, receivedEq, modType) => {
            let errors = 0;
            let totalBits = 0;
            const numSymbolsToCompare = Math.min(transmitted.length, receivedEq.length);

            for(let i = 0; i < numSymbolsToCompare; i++) {
                const tx = transmitted[i];
                const rxDecided = decideSymbol(receivedEq[i], modType);

                if (modType === 'BPSK') { // 1 bit per symbol
                    if (Math.sign(tx.real) !== Math.sign(rxDecided.real)) errors++;
                    totalBits++;
                } else if (modType === 'QPSK') { // 2 bits per symbol
                    if (Math.sign(tx.real) !== Math.sign(rxDecided.real)) errors++; // Error in I-channel bit
                    if (Math.sign(tx.imag) !== Math.sign(rxDecided.imag)) errors++; // Error in Q-channel bit
                    totalBits += 2;
                } else if (modType === '16QAM') { // 4 bits per symbol
                    // A simple way to count bit errors for 16QAM with Gray coding (approx)
                    // Compare to original levels before normalization for easier bit mapping.
                    const txUnNorm = { real: tx.real * Math.sqrt(10), imag: tx.imag * Math.sqrt(10) };
                    const rxUnNorm = { real: rxDecided.real * Math.sqrt(10), imag: rxDecided.imag * Math.sqrt(10) };

                    // Map un-normalized levels (-3, -1, 1, 3) to bits (e.g., Gray coded)
                    // -3 -> 00, -1 -> 01, 1 -> 11, 3 -> 10 (for MSB, LSB)
                    const toGrayBits = (level) => {
                        if (level < -2) return [0,0]; // for -3
                        if (level < 0) return [0,1];  // for -1
                        if (level < 2) return [1,1];  // for 1
                        return [1,0];                 // for 3
                    };
                    
                    const txBitsReal = toGrayBits(txUnNorm.real);
                    const rxBitsReal = toGrayBits(rxUnNorm.real);
                    if (txBitsReal[0] !== rxBitsReal[0]) errors++;
                    if (txBitsReal[1] !== rxBitsReal[1]) errors++;

                    const txBitsImag = toGrayBits(txUnNorm.imag);
                    const rxBitsImag = toGrayBits(rxUnNorm.imag);
                    if (txBitsImag[0] !== rxBitsImag[0]) errors++;
                    if (txBitsImag[1] !== rxBitsImag[1]) errors++;
                    
                    totalBits += 4;
                }
            }
            return totalBits > 0 ? errors / totalBits : 0;
        };

        const runSingleSNPSimulation = (snrDbVal) => {
            const transmittedSyms = generateConstellation(params.modulation, params.numSymbols);
            // Apply channel introduces ISI. The simplified equalizers here mostly fight noise on the first tap's path.
            const channelOutput = applyChannel(transmittedSyms, channelCoeffs); 
            const noisySignal = addNoiseGaussian(channelOutput, snrDbVal);
            
            const zfOutput = zfEqualize(noisySignal, channelCoeffs);
            
            // MODIFIED: MMSE uses actual noise power for this SNR point
            const snrLinear = Math.pow(10, snrDbVal / 10);
            const actualNoisePowerForMMSE = 1 / snrLinear; // N0 (total noise power), assuming Es=1
            const mmseOutput = mmseEqualize(noisySignal, channelCoeffs, actualNoisePowerForMMSE);
            
            const zfBER = calculateBER(transmittedSyms, zfOutput, params.modulation);
            const mmseBER = calculateBER(transmittedSyms, mmseOutput, params.modulation);
            
            console.log(`SNR: ${snrDbVal.toFixed(1)} dB -> ZF_BER: ${zfBER.toExponential(3)}, MMSE_BER: ${mmseBER.toExponential(3)} (N0_MMSE_est: ${actualNoisePowerForMMSE.toExponential(2)})`);
            
            const displayCount = Math.min(100, params.numSymbols);
            constellations.transmitted = transmittedSyms.slice(0, displayCount).map(s => ({x: s.real, y: s.imag}));
            constellations.zf_received = zfOutput.slice(0, displayCount).map(s => ({x: s.real, y: s.imag}));
            constellations.mmse_received = mmseOutput.slice(0, displayCount).map(s => ({x: s.real, y: s.imag}));
            
            return { snr: snrDbVal, zfBER, mmseBER };
        };

        function startSimulationLoop() {
            if (isRunning) return;
            isRunning = true;
            updateUIState();

            simulationInterval = setInterval(() => {
                const result = runSingleSNPSimulation(currentSNR);
                
                const existingIndex = results.findIndex(r => r.snr === currentSNR);
                if (existingIndex >= 0) {
                    results[existingIndex] = result;
                } else {
                    results.push(result);
                }
                results.sort((a, b) => a.snr - b.snr);
                
                updateBERChart();
                updateConstellationCharts();
                updateUIState();
                
                if (currentSNR < params.snrRange[1]) {
                    currentSNR++;
                } else {
                    pauseSimulationLoop();
                }
            }, 200); // Reduced interval for faster sim
        }

        function pauseSimulationLoop() {
            isRunning = false;
            clearInterval(simulationInterval);
            updateUIState();
        }

        function resetSimulation() {
            pauseSimulationLoop();
            currentSNR = params.snrRange[0];
            results = [];
            constellations = { transmitted: [], zf_received: [], mmse_received: [] };
            
            updateBERChart();
            updateConstellationCharts();
            updateUIState();
        }

        function updateUIState() {
            currentSNRDisplay.textContent = currentSNR;
            constellationSNRDisplay.textContent = currentSNR;
            statusDisplay.textContent = isRunning ? 'Running...' : (currentSNR >= params.snrRange[1] && results.length > 0 ? 'Completed' : 'Stopped');
            
            const totalPoints = params.snrRange[1] - params.snrRange[0] + 1;
            progressDisplay.textContent = `${results.length}/${totalPoints}`;

            if (isRunning) {
                startPauseButton.classList.remove('btn-start');
                startPauseButton.classList.add('btn-pause');
                playIcon.style.display = 'none';
                pauseIcon.style.display = 'inline-block';
                startPauseText.textContent = 'Pause Simulation';
            } else {
                startPauseButton.classList.remove('btn-pause');
                startPauseButton.classList.add('btn-start');
                playIcon.style.display = 'inline-block';
                pauseIcon.style.display = 'none';
                startPauseText.textContent = 'Start Simulation';
            }
        }
        
        function initCharts() {
            const berCtx = document.getElementById('berChart').getContext('2d');
            berChartInstance = new Chart(berCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: 'Zero Forcing BER',
                            data: [],
                            borderColor: '#ff7300',
                            backgroundColor: 'rgba(255, 115, 0, 0.1)',
                            tension: 0.1,
                            fill: false,
                            pointRadius: 3,
                            borderWidth: 2
                        },
                        {
                            label: 'MMSE BER',
                            data: [],
                            borderColor: '#387908',
                            backgroundColor: 'rgba(56, 121, 8, 0.1)',
                            tension: 0.1,
                            fill: false,
                            pointRadius: 3,
                            borderWidth: 2
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: { display: true, text: 'SNR (dB)' }
                        },
                        y: {
                            type: 'logarithmic',
                            title: { display: true, text: 'Bit Error Rate' },
                            min: 1e-6, // Adjusted min for potentially lower BERs
                             ticks: {
                                callback: function(value, index, values) {
                                    return Number(value.toPrecision(1)).toExponential();
                                }
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) { label += ': '; }
                                    if (context.parsed.y !== null) {
                                        label += context.parsed.y.toExponential(2);
                                    }
                                    return label;
                                }
                            }
                        },
                        legend: {
                            labels: {
                                usePointStyle: true,
                                pointStyle: 'rect',
                            }
                        }
                    }
                }
            });

            const commonScatterOptions = (title) => ({
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: { type: 'linear', position: 'bottom', min: -2.5, max: 2.5, title: { display: false }, ticks: { font: {size: 8}}},
                    y: { min: -2.5, max: 2.5, title: { display: false }, ticks: { font: {size: 8}} }
                },
                plugins: {
                    legend: { display: false },
                    tooltip: { enabled: false }
                },
                animation: false // Disable animation for faster updates
            });

            transmittedConstellationChartInstance = new Chart(document.getElementById('transmittedConstellationChart').getContext('2d'), {
                type: 'scatter',
                data: { datasets: [{ data: [], backgroundColor: '#8884d8', pointRadius: 2 }] },
                options: commonScatterOptions('Transmitted')
            });
            zfConstellationChartInstance = new Chart(document.getElementById('zfConstellationChart').getContext('2d'), {
                type: 'scatter',
                data: { datasets: [{ data: [], backgroundColor: '#ff7300', pointRadius: 2 }] },
                options: commonScatterOptions('ZF Received')
            });
            mmseConstellationChartInstance = new Chart(document.getElementById('mmseConstellationChart').getContext('2d'), {
                type: 'scatter',
                data: { datasets: [{ data: [], backgroundColor: '#387908', pointRadius: 2 }] },
                options: commonScatterOptions('MMSE Received')
            });
        }

        function updateBERChart() {
            if (!berChartInstance) return;
            const labels = results.map(r => r.snr);
            const zfData = results.map(r => (r.zfBER > 0 && isFinite(r.zfBER)) ? r.zfBER : null);
            const mmseData = results.map(r => (r.mmseBER > 0 && isFinite(r.mmseBER)) ? r.mmseBER : null);

            console.log("BER Chart Update - Labels:", JSON.stringify(labels));
            console.log("BER Chart Update - ZF Data:", JSON.stringify(zfData));
            console.log("BER Chart Update - MMSE Data:", JSON.stringify(mmseData));

            berChartInstance.data.labels = labels;
            berChartInstance.data.datasets[0].data = zfData;
            berChartInstance.data.datasets[1].data = mmseData;
            berChartInstance.update();
        }

        function updateConstellationCharts() {
            if (!transmittedConstellationChartInstance) return;
            
            const getDynamicDomain = (dataArray, fallbackMin = -1.5, fallbackMax = 1.5) => {
                if (!dataArray || dataArray.length === 0) return [fallbackMin, fallbackMax];
                let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                dataArray.forEach(p => {
                    if (isFinite(p.x)) { minX = Math.min(minX, p.x); maxX = Math.max(maxX, p.x); }
                    if (isFinite(p.y)) { minY = Math.min(minY, p.y); maxY = Math.max(maxY, p.y); }
                });
                if (!isFinite(minX)) return [fallbackMin, fallbackMax]; // All data was non-finite

                const rangeX = maxX - minX;
                const rangeY = maxY - minY;
                const paddingX = Math.max(0.5, rangeX * 0.1);
                const paddingY = Math.max(0.5, rangeY * 0.1);

                return [
                    Math.min(fallbackMin, Math.floor((minX - paddingX) * 2) / 2), // Round down to nearest 0.5
                    Math.max(fallbackMax, Math.ceil((maxX + paddingX) * 2) / 2),  // Round up to nearest 0.5
                    Math.min(fallbackMin, Math.floor((minY - paddingY) * 2) / 2),
                    Math.max(fallbackMax, Math.ceil((maxY + paddingY) * 2) / 2)
                ];
            };

            const txDomain = getDynamicDomain(constellations.transmitted);
            transmittedConstellationChartInstance.data.datasets[0].data = constellations.transmitted;
            transmittedConstellationChartInstance.options.scales.x.min = txDomain[0];
            transmittedConstellationChartInstance.options.scales.x.max = txDomain[1];
            transmittedConstellationChartInstance.options.scales.y.min = txDomain[2];
            transmittedConstellationChartInstance.options.scales.y.max = txDomain[3];
            transmittedConstellationChartInstance.update('none');

            const zfDomain = getDynamicDomain(constellations.zf_received);
            zfConstellationChartInstance.data.datasets[0].data = constellations.zf_received;
            zfConstellationChartInstance.options.scales.x.min = zfDomain[0];
            zfConstellationChartInstance.options.scales.x.max = zfDomain[1];
            zfConstellationChartInstance.options.scales.y.min = zfDomain[2];
            zfConstellationChartInstance.options.scales.y.max = zfDomain[3];
            zfConstellationChartInstance.update('none');

            const mmseDomain = getDynamicDomain(constellations.mmse_received);
            mmseConstellationChartInstance.data.datasets[0].data = constellations.mmse_received;
            mmseConstellationChartInstance.options.scales.x.min = mmseDomain[0];
            mmseConstellationChartInstance.options.scales.x.max = mmseDomain[1];
            mmseConstellationChartInstance.options.scales.y.min = mmseDomain[2];
            mmseConstellationChartInstance.options.scales.y.max = mmseDomain[3];
            mmseConstellationChartInstance.update('none');
        }

        startPauseButton.addEventListener('click', () => {
            if (isRunning) {
                pauseSimulationLoop();
            } else {
                startSimulationLoop();
            }
        });
        resetButton.addEventListener('click', resetSimulation);

        function parseAndUpdateParams() {
            params.modulation = modulationSelect.value;
            params.numSymbols = parseInt(numSymbolsInput.value) || 1000;
            
            const coeffsStrRaw = channelCoeffsInput.value.split(',');
            const parsedCoeffs = coeffsStrRaw.map(x => parseFloat(x.trim())).filter(x => !isNaN(x));
            
            if (parsedCoeffs.length > 0) {
                channelCoeffs = parsedCoeffs;
                channelTapsInput.value = channelCoeffs.length; 
            } else {
                channelCoeffsInput.value = channelCoeffs.join(', '); // Revert to old if invalid
            }
            
            uiNoiseVariance = parseFloat(noiseVarianceInput.value) || 0.1; // Still update this, though not used by MMSE in loop
            resetSimulation();
        }
        
        modulationSelect.addEventListener('change', parseAndUpdateParams);
        numSymbolsInput.addEventListener('change', parseAndUpdateParams);
        channelCoeffsInput.addEventListener('change', parseAndUpdateParams);
        noiseVarianceInput.addEventListener('change', () => { // Only updates uiNoiseVariance
            uiNoiseVariance = parseFloat(noiseVarianceInput.value) || 0.1;
        });
        channelTapsInput.addEventListener('change', () => {
            const numTaps = parseInt(channelTapsInput.value);
            if (numTaps > 0 && numTaps <= 5) {
                if (numTaps !== channelCoeffs.length) {
                    // Generate somewhat random default taps if count changes
                    const newCoeffs = Array(numTaps).fill(0).map((_, i) => {
                        if (i === 0) return parseFloat((0.2 + Math.random()*0.3).toFixed(2)); // First tap weaker
                        return parseFloat((Math.random()*0.8).toFixed(2)); // Other taps
                    });
                    channelCoeffs = newCoeffs;
                    channelCoeffsInput.value = channelCoeffs.join(', ');
                    parseAndUpdateParams(); // This will call reset
                }
            }
        });

        document.addEventListener('DOMContentLoaded', () => {
            modulationSelect.value = params.modulation;
            numSymbolsInput.value = params.numSymbols;
            channelTapsInput.value = channelCoeffs.length;
            channelCoeffsInput.value = channelCoeffs.join(', ');
            noiseVarianceInput.value = uiNoiseVariance;

            initCharts();
            resetSimulation();
        });
    </script>
</body>
</html>