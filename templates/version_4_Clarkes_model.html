<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clarke's Model Virtual Lab</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f0f2f5;
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: #333;
        }

        .header h1 {
            font-size: 3rem;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .lab-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .controls-panel, .environment-panel, .chart-panel {
            background: #fff;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            height: fit-content;
        }

        .input-group-container {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .input-group-container .control-group {
            flex: 1;
            min-width: 250px;
            margin-bottom: 0;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            color: #4a5568;
        }

        .control-group input[type="number"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 16px;
            transition: all 0.3s ease;
        }
        
        .control-group input[type="range"] {
            width: 100%;
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            background: #ddd;
            outline: none;
            border-radius: 4px;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #667eea;
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }

        .control-group input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #667eea;
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }

        .control-group input[type="number"]:focus,
        .control-group input[type="range"]:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .help-text {
            font-size: 12px;
            color: #718096;
            margin-top: 5px;
        }

        .environment-canvas {
            width: 100%;
            height: 400px;
            border-radius: 10px;
            background: #f8fafc;
        }

        .chart-container {
            position: relative;
            height: 300px;
            width: 100%;
        }

        h2 {
            font-size: 1.5rem;
            margin-bottom: 20px;
            color: #2d3748;
        }

        h3 {
            font-size: 1.2rem;
            margin-bottom: 15px;
            color: #4a5568;
        }

        .charts-grid {
            display: grid;
            grid-template-columns: 1fr 1fr; /* Two columns for plots */
            gap: 20px;
        }

        .info-box {
            background: #f0f4ff;
            border-left: 4px solid #667eea;
            padding: 15px;
            margin-top: 20px;
            border-radius: 5px;
        }

        .info-box h4 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .slider-container {
            margin-bottom: 20px;
            display: flex;
            align-items: center;
        }

        .slider-container label {
            white-space: nowrap;
            margin-right: 10px;
        }

        .slider-container input {
            flex-grow: 1;
        }

        .slider-container span {
            margin-left: 10px;
            font-weight: bold;
            min-width: 30px;
            text-align: right;
        }

        #simulate-button {
            width: 100%;
            padding: 15px;
            border: none;
            border-radius: 8px;
            background-color: #667eea;
            color: white;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        #simulate-button:hover {
            background-color: #5a6ac2;
        }
        
        @media (max-width: 1000px) {
            .input-group-container {
                flex-direction: column;
            }
            .charts-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Clarke's Model Virtual Lab</h1>
            <p>Interactive simulation of mobile radio channel fading characteristics</p>
        </div>

        <div class="lab-grid">
            <div class="controls-panel">
                <h2>Parameters</h2>
                
                <div class="input-group-container">
                    <div class="control-group">
                        <label for="velocity">Mobile Velocity (m/s)</label>
                        <input type="number" id="velocity" value="30" min="0" max="100" step="1">
                        <div class="help-text">Controls Doppler spread and fading rate.</div>
                    </div>

                    <div class="control-group">
                        <label for="frequency">Carrier Frequency (MHz)</label>
                        <input type="number" id="frequency" value="900" min="100" max="6000" step="100">
                        <div class="help-text">Affects wavelength and Doppler frequency.</div>
                    </div>

                    <div class="control-group">
                        <label for="scatterers">Number of Scatterers</label>
                        <input type="number" id="scatterers" value="20" min="6" max="50" step="2">
                        <div class="help-text">More scatterers provide a better approximation of the model.</div>
                    </div>
                </div>
                
                <button id="simulate-button">Simulate</button>

                <div class="info-box">
                    <h4>Clarke's Model</h4>
                    <p>Models multipath fading in mobile communications assuming:</p>
                    <ul style="margin: 10px 0 0 20px; line-height: 1.6;">
                        <li>Scatterers uniformly distributed</li>
                        <li>Equal signal strength from all paths</li>
                        <li>Mobile receiver in motion</li>
                    </ul>
                </div>
            </div>

            <div class="environment-panel">
                <h2>Scattering Environment</h2>
                <canvas id="environmentCanvas" class="environment-canvas"></canvas>
            </div>
        </div>

        <div class="charts-grid">
            <div class="chart-panel">
                <h3>Autocorrelation Function R($\tau$)</h3>
                <div class="slider-container">
                    <label for="autocorr-slider">Velocity (m/s):</label>
                    <input type="range" id="autocorr-slider" min="0" max="100" value="30" step="1">
                    <span id="autocorr-value">30</span>
                </div>
                <div class="chart-container">
                    <canvas id="autocorrelationChart"></canvas>
                </div>
            </div>

            <div class="chart-panel">
                <h3>Power Spectral Density S(f)</h3>
                <div class="slider-container">
                    <label for="psd-slider">Velocity (m/s):</label>
                    <input type="range" id="psd-slider" min="0" max="100" value="30" step="1">
                    <span id="psd-value">30</span>
                </div>
                <div class="chart-container">
                    <canvas id="psdChart"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Physical constants
        const SPEED_OF_LIGHT = 3e8;

        // DOM elements
        const velocityInput = document.getElementById('velocity');
        const frequencyInput = document.getElementById('frequency');
        const scatterersInput = document.getElementById('scatterers');
        const simulateButton = document.getElementById('simulate-button');
        const envCanvas = document.getElementById('environmentCanvas');
        const envCtx = envCanvas.getContext('2d');
        
        // Sliders
        const autocorrSlider = document.getElementById('autocorr-slider');
        const psdSlider = document.getElementById('psd-slider');
        const autocorrValueSpan = document.getElementById('autocorr-value');
        const psdValueSpan = document.getElementById('psd-value');

        let autocorrelationChart = null;
        let psdChart = null;

        // Bessel function J0 approximation
        function besselJ0(x) {
            if (Math.abs(x) < 8.0) {
                const y = x * x;
                const ans1 = 57568490574.0 + y * (-13362590354.0 + y * (651619640.7 + 
                    y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456)))));
                const ans2 = 57568490411.0 + y * (1029532985.0 + y * (9494680.718 + 
                    y * (59272.64853 + y * (267.8532712 + y * 1.0))));
                return ans1 / ans2;
            } else {
                const z = 8.0 / x;
                const y = z * z;
                const xx = x - 0.785398164;
                const ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + 
                    y * (-0.2073370639e-5 + y * 0.2093887211e-6)));
                const ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + 
                    y * (-0.6911147651e-5 + y * (0.7621095161e-6 - y * 0.934935152e-7)));
                return Math.sqrt(0.636619772 / x) * (Math.cos(xx) * ans1 - z * Math.sin(xx) * ans2);
            }
        }

        // Draw scattering environment
        function drawEnvironment() {
            const width = envCanvas.width = envCanvas.offsetWidth;
            const height = envCanvas.height = envCanvas.offsetHeight;
            
            envCtx.clearRect(0, 0, width, height);
            
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) * 0.35;
            const numScatterers = parseInt(scatterersInput.value);

            // Draw circle
            envCtx.strokeStyle = '#667eea';
            envCtx.lineWidth = 3;
            envCtx.beginPath();
            envCtx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            envCtx.stroke();

            // Draw scatterers
            envCtx.fillStyle = '#48bb78';
            for (let i = 0; i < numScatterers; i++) {
                const angle = (2 * Math.PI * i) / numScatterers;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                
                envCtx.beginPath();
                envCtx.arc(x, y, 6, 0, 2 * Math.PI);
                envCtx.fill();
                
                // Draw path lines
                envCtx.strokeStyle = 'rgba(102, 126, 234, 0.3)';
                envCtx.lineWidth = 1;
                envCtx.beginPath();
                envCtx.moveTo(centerX, centerY);
                envCtx.lineTo(x, y);
                envCtx.stroke();
            }

            // Draw mobile receiver
            envCtx.fillStyle = '#e53e3e';
            envCtx.beginPath();
            envCtx.arc(centerX, centerY, 10, 0, 2 * Math.PI);
            envCtx.fill();
            
            // Add label
            envCtx.fillStyle = '#2d3748';
            envCtx.font = 'bold 14px Arial';
            envCtx.textAlign = 'center';
            envCtx.fillText('Rx', centerX, centerY + 5);

            // Add velocity arrow
            const velocity = parseFloat(velocityInput.value);
            if (velocity > 0) {
                envCtx.strokeStyle = '#e53e3e';
                envCtx.lineWidth = 3;
                envCtx.beginPath();
                envCtx.moveTo(centerX, centerY - 20);
                envCtx.lineTo(centerX + 30, centerY - 20);
                envCtx.stroke();
                
                // Arrow head
                envCtx.beginPath();
                envCtx.moveTo(centerX + 30, centerY - 20);
                envCtx.lineTo(centerX + 25, centerY - 25);
                envCtx.moveTo(centerX + 30, centerY - 20);
                envCtx.lineTo(centerX + 25, centerY - 15);
                envCtx.stroke();
                
                envCtx.fillStyle = '#2d3748';
                envCtx.font = '12px Arial';
                envCtx.fillText(`v = ${velocity} m/s`, centerX + 15, centerY - 30);
            }
        }

        // Calculate autocorrelation function
        function calculateAutocorrelation(velocity) {
            const frequency = parseFloat(frequencyInput.value) * 1e6;
            const wavelength = SPEED_OF_LIGHT / frequency;
            const fD = velocity / wavelength;
            const maxTau = 2 / Math.max(fD, 1);
            const numPoints = 100;
            const tauStep = maxTau / numPoints;
            
            const data = [];
            for (let i = 0; i <= numPoints; i++) {
                const tau = i * tauStep;
                const correlation = besselJ0(2 * Math.PI * fD * tau);
                data.push({ x: tau * 1000, y: correlation });
            }
            
            return data;
        }

        // Calculate power spectral density (Jakes spectrum)
        function calculatePSD(velocity) {
            const frequency = parseFloat(frequencyInput.value) * 1e6;
            const wavelength = SPEED_OF_LIGHT / frequency;
            const fD = velocity / wavelength;

            if (fD === 0) {
                return [{ x: 0, y: 1 }];
            }

            const numPoints = 200;
            const data = [];
            
            for (let i = 0; i <= numPoints; i++) {
                const f = (-fD * 1.5) + (i * 3 * fD) / numPoints;
                let psd = 0;
                
                if (Math.abs(f) < fD * 0.999) {
                    psd = 1 / (Math.PI * fD * Math.sqrt(1 - (f / fD) ** 2));
                }
                
                data.push({ x: f, y: psd });
            }
            
            return data;
        }

        // Updates all charts and environment with main control panel values
        function updateAllWithMainParams() {
            const currentVelocity = parseFloat(velocityInput.value);
            autocorrSlider.value = currentVelocity;
            psdSlider.value = currentVelocity;
            autocorrValueSpan.textContent = currentVelocity;
            psdValueSpan.textContent = currentVelocity;
            updatePlots(currentVelocity);
            drawEnvironment();
        }

        // Updates only the plots based on a given velocity
        function updatePlots(sourceVelocity) {
            // Autocorrelation chart
            const autocorrData = calculateAutocorrelation(sourceVelocity);
            
            if (autocorrelationChart) {
                autocorrelationChart.destroy();
            }
            
            autocorrelationChart = new Chart(document.getElementById('autocorrelationChart'), {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'R($\\tau$)',
                        data: autocorrData,
                        borderColor: '#667eea',
                        backgroundColor: 'rgba(102, 126, 234, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4,
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Delay Ï„ (ms)'
                            },
                            grid: { color: 'rgba(0,0,0,0.1)' }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Correlation'
                            },
                            min: -1,
                            max: 1,
                            grid: { color: 'rgba(0,0,0,0.1)' }
                        }
                    }
                }
            });

            // PSD chart
            const psdData = calculatePSD(sourceVelocity);
            
            if (psdChart) {
                psdChart.destroy();
            }
            
            psdChart = new Chart(document.getElementById('psdChart'), {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'S(f)',
                        data: psdData,
                        borderColor: '#48bb78',
                        backgroundColor: 'rgba(72, 187, 120, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.2,
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Frequency (Hz)'
                            },
                            grid: { color: 'rgba(0,0,0,0.1)' }
                        },
                        y: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Power Density'
                            },
                            min: 0,
                            grid: { color: 'rgba(0,0,0,0.1)' }
                        }
                    }
                }
            });
        }
        
        // Event listeners
        simulateButton.addEventListener('click', () => {
            updateAllWithMainParams();
        });

        velocityInput.addEventListener('input', () => {
            const newVelocity = parseFloat(velocityInput.value);
            autocorrSlider.value = newVelocity;
            psdSlider.value = newVelocity;
            autocorrValueSpan.textContent = newVelocity;
            psdValueSpan.textContent = newVelocity;
            drawEnvironment();
        });

        frequencyInput.addEventListener('input', () => {
            drawEnvironment();
        });

        scatterersInput.addEventListener('input', () => {
            drawEnvironment();
        });
        
        // Slider event listeners for real-time plot changes
        autocorrSlider.addEventListener('input', (event) => {
            const velocity = parseFloat(event.target.value);
            autocorrValueSpan.textContent = velocity;
            updatePlots(velocity);
        });

        psdSlider.addEventListener('input', (event) => {
            const velocity = parseFloat(event.target.value);
            psdValueSpan.textContent = velocity;
            updatePlots(velocity);
        });
        
        window.addEventListener('resize', () => {
            setTimeout(() => {
                const currentVelocity = parseFloat(velocityInput.value);
                updatePlots(currentVelocity);
                drawEnvironment();
            }, 100);
        });

        // Initial update on page load
        updateAllWithMainParams();
    </script>
</body>
</html>